{"version":3,"file":"jspython-interpreter.esm.js","sources":["../src/common/utils.ts","../src/common/operators.ts","../src/common/token-types.ts","../src/common/ast-types.ts","../src/evaluator/scope.ts","../src/evaluator/evaluator.ts","../src/evaluator/evaluatorAsync.ts","../src/initialScope.ts","../src/parser/parser.ts","../src/tokenizer/tokenizer.ts","../src/interpreter.ts"],"sourcesContent":["import { Token } from \"./token-types\";\r\n\r\nexport function parseDatetimeOrNull(value: string | Date): Date | null {\r\n    if (!value) { return null; }\r\n    if (value instanceof Date && !isNaN(value.valueOf())) { return value; }\r\n    // only string values can be converted to Date\r\n    if (typeof value !== 'string') { return null; }\r\n\r\n    const strValue = String(value);\r\n    if (!strValue.length) { return null; }\r\n\r\n    const parseMonth = (mm: string): number => {\r\n        if (!mm || !mm.length) {\r\n            return NaN;\r\n        }\r\n\r\n        const m = parseInt(mm, 10);\r\n        if (!isNaN(m)) {\r\n            return m - 1;\r\n        }\r\n\r\n        // make sure english months are coming through\r\n        if (mm.startsWith('jan')) { return 0; }\r\n        if (mm.startsWith('feb')) { return 1; }\r\n        if (mm.startsWith('mar')) { return 2; }\r\n        if (mm.startsWith('apr')) { return 3; }\r\n        if (mm.startsWith('may')) { return 4; }\r\n        if (mm.startsWith('jun')) { return 5; }\r\n        if (mm.startsWith('jul')) { return 6; }\r\n        if (mm.startsWith('aug')) { return 7; }\r\n        if (mm.startsWith('sep')) { return 8; }\r\n        if (mm.startsWith('oct')) { return 9; }\r\n        if (mm.startsWith('nov')) { return 10; }\r\n        if (mm.startsWith('dec')) { return 11; }\r\n\r\n        return NaN;\r\n    };\r\n\r\n    const correctYear = (yy: number) => {\r\n        if (yy < 100) {\r\n            return yy < 68 ? yy + 2000 : yy + 1900;\r\n        } else {\r\n            return yy;\r\n        }\r\n    };\r\n\r\n    const validDateOrNull =\r\n        (yyyy: number, month: number, day: number, hours: number, mins: number, ss: number): Date | null => {\r\n            if (month > 11 || day > 31 || hours >= 60 || mins >= 60 || ss >= 60) { return null; }\r\n\r\n            const dd = new Date(yyyy, month, day, hours, mins, ss, 0);\r\n            return !isNaN(dd.valueOf()) ? dd : null;\r\n        };\r\n\r\n    const strTokens = strValue.replace('T', ' ').toLowerCase().split(/[: /-]/);\r\n    const dt = strTokens.map(parseFloat);\r\n\r\n    // try ISO first\r\n    let d = validDateOrNull(dt[0], dt[1] - 1, dt[2], dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    // then UK\r\n    d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[1]), dt[0], dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    // then US\r\n    d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[0]), correctYear(dt[1]), dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    return null;\r\n}\r\n\r\nexport function getImportType(name: string): 'jspyModule' | 'jsPackage' | 'json' {\r\n\r\n    if (name.startsWith('/') || name.startsWith('./')) {\r\n        return (name.endsWith('.json')) ? 'json' : 'jspyModule';\r\n    }\r\n\r\n    return 'jsPackage';\r\n}\r\n\r\nfunction jspyErrorMessage(error: string, module: string, line: number, column: number, message: string): string {\r\n    return `${error}: ${module}(${line},${column}): ${message}`;\r\n}\r\n\r\nexport class JspyTokenizerError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyTokenizerError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyTokenizerError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyParserError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyParserError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyParserError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyEvalError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyEvalError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyEvalError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyError extends Error {\r\n\r\n    constructor(public module: string, public line: number, public column: number, public name: string, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyError\", module || 'name.jspy', line, column, message);\r\n        Object.setPrototypeOf(this, JspyError.prototype);\r\n    }\r\n}\r\n","export enum OperationTypes {\r\n    Arithmetic, Assignment, Comparison, Logical, Membership\r\n};\r\n\r\nexport type AssignmentOperators = \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"++\" | \"--\";\r\nexport type ArithmeticOperators = \"+\" | \"-\" | \"*\" | \"/\" | \"%\" | \"**\" | \"//\";\r\nexport type ComparisonOperators = \">\" | \">=\" | \"==\" | \"!=\" | \"<>\" | \"<\" | \"<=\";\r\nexport type LogicalOperators = \"and\" | \"or\"; // | \"not\" | \"not in\";\r\nexport type MembershipOperators = \"in\";\r\n\r\nexport type Operators = AssignmentOperators | ArithmeticOperators | ComparisonOperators | LogicalOperators | MembershipOperators;\r\n\r\nexport const OperatorsMap: Record<Operators, OperationTypes> = {\r\n    \"+\": OperationTypes.Arithmetic,\r\n    \"-\": OperationTypes.Arithmetic,\r\n    \"*\": OperationTypes.Arithmetic,\r\n    \"/\": OperationTypes.Arithmetic,\r\n    \"%\": OperationTypes.Arithmetic,\r\n    \"**\": OperationTypes.Arithmetic,\r\n    \"//\": OperationTypes.Arithmetic,\r\n\r\n    \">\": OperationTypes.Comparison,\r\n    \">=\": OperationTypes.Comparison,\r\n    \"==\": OperationTypes.Comparison,\r\n    \"!=\": OperationTypes.Comparison,\r\n    \"<>\": OperationTypes.Comparison,\r\n    \"<\": OperationTypes.Comparison,\r\n    \"<=\": OperationTypes.Comparison,\r\n\r\n    \"and\": OperationTypes.Logical,\r\n    \"or\": OperationTypes.Logical,\r\n    // \"not\": OperationTypes.Logical,\r\n    // \"not in\": OperationTypes.Logical,\r\n\r\n    \"in\": OperationTypes.Membership,\r\n\r\n    \"=\": OperationTypes.Assignment,\r\n    \"+=\": OperationTypes.Assignment,\r\n    \"-=\": OperationTypes.Assignment,\r\n    \"*=\": OperationTypes.Assignment,\r\n    \"/=\": OperationTypes.Assignment,\r\n    \"++\": OperationTypes.Assignment,\r\n    \"--\": OperationTypes.Assignment,\r\n};\r\n\r\nexport type Primitive = string | number | boolean | null;\r\n\r\nexport type ExpressionOperators = ArithmeticOperators | ComparisonOperators | LogicalOperators | MembershipOperators;\r\ntype ExpressionOperation = (l: Primitive, r: Primitive) => Primitive;\r\n\r\nexport const OperationFuncs: Record<ExpressionOperators, ExpressionOperation> = {\r\n    \"+\": (l, r) => arithmeticOperation(l, r, \"+\"),\r\n    \"-\": (l, r) => arithmeticOperation(l, r, \"-\"),\r\n    \"/\": (l, r) => arithmeticOperation(l, r, \"/\"),\r\n    \"*\": (l, r) => arithmeticOperation(l, r, \"*\"),\r\n    \"%\": (l, r) => arithmeticOperation(l, r, \"%\"),\r\n    \"**\": (l, r) => arithmeticOperation(l, r, \"**\"),\r\n    \"//\": (l, r) => arithmeticOperation(l, r, \"//\"),\r\n\r\n    \">\": (l, r) => comparissonOperation(l, r, \">\"),\r\n    \">=\": (l, r) => comparissonOperation(l, r, \">=\"),\r\n    \"<\": (l, r) => comparissonOperation(l, r, \"<\"),\r\n    \"<=\": (l, r) => comparissonOperation(l, r, \"<=\"),\r\n    \"==\": (l, r) => comparissonOperation(l, r, \"==\"),\r\n    \"!=\": (l, r) => comparissonOperation(l, r, \"!=\"),\r\n    \"<>\": (l, r) => comparissonOperation(l, r, \"<>\"),\r\n\r\n    \"and\": (l, r) => logicalOperation(l, r, \"and\"),\r\n    \"or\": (l, r) => logicalOperation(l, r, \"or\"),\r\n    // \"not\": (l, r) => logicalOperation(l, r, \"not\"),\r\n    // \"not in\": (l, r) => logicalOperation(l, r, \"not in\"),\r\n\r\n    \"in\": (l, r) => membershipOperation(l, r, \"in\")\r\n}\r\n\r\nfunction membershipOperation(l: Primitive, r: Primitive, op: MembershipOperators): Primitive {\r\n    if(typeof l === 'string'){\r\n        return (l as string).includes(String(r));\r\n    }\r\n\r\n    if(Array.isArray(l)){\r\n        return (l as any[]).includes(r);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction logicalOperation(l: Primitive, r: Primitive, op: LogicalOperators): Primitive {\r\n    switch (op) {\r\n        case 'and':\r\n            return l as any && r as any;\r\n\r\n        case 'or':\r\n            return (l as any) || (r as any);\r\n    }\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction comparissonOperation(l: Primitive, r: Primitive, op: ComparisonOperators): Primitive {\r\n    switch (op) {\r\n        case '==':\r\n            return l as any === r as any;\r\n\r\n        case '!=':\r\n            return (l as any) !== (r as any);\r\n\r\n        case '<>':\r\n            return (l as any) !== (r as any);\r\n\r\n        case '>':\r\n            return (l as number) > (r as number);\r\n\r\n        case '<':\r\n            return (l as number) < (r as number);\r\n\r\n        case '>=':\r\n            return (l as number) >= (r as number);\r\n\r\n        case '<=':\r\n            return (l as number) <= (r as number);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction arithmeticOperation(l: Primitive, r: Primitive, op: ArithmeticOperators): Primitive {\r\n\r\n    switch (op) {\r\n        case '+':\r\n            return l as any + r as any;\r\n\r\n        case '-':\r\n            return (l as any) - (r as any);\r\n\r\n        case '*':\r\n            return (l as number) * (r as number);\r\n\r\n        case '/':\r\n            return (l as number) / (r as number);\r\n\r\n        case '%':\r\n            return (l as number) % (r as number);\r\n\r\n        case '**':\r\n            return Math.pow(l as number, r as number);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}","import { OperationTypes, Operators, OperatorsMap } from \"./operators\";\r\n\r\nexport enum TokenTypes {\r\n    Identifier = 0,\r\n    Keyword = 1,\r\n    Separator = 2,\r\n    Operator = 3,\r\n    LiteralNumber = 4,\r\n    LiteralBool = 5,\r\n    LiteralString = 6,\r\n    LiteralNull = 7,\r\n    Comment = 8\r\n}\r\n/**\r\n * Token represent a single considered token in a script. Is represented as an array, where element at:\r\n *  0 : value\r\n *  1 : token details. For a memory and performance reasons we use Uint16Array with 5 elements in it:\r\n *    [\r\n *      0 - tokenType number equivalent of @TokenTypes\r\n *      1 - beginLine\r\n *      2 - beginColumn\r\n *      3 - endLine\r\n *      4 - endColumn\r\n *    ]\r\n * [(value). Uint16Array[5]([tokenType, beginLine, beginColumn, endLine, endColumn])]\r\n * tokenType\r\n */\r\nexport type Token = [string | number | boolean | null, Uint16Array];\r\nexport type TokenValue = string | number | boolean | null;\r\n\r\nexport function isTokenTypeLiteral(tokenType: TokenTypes): boolean {\r\n    return tokenType === TokenTypes.LiteralString\r\n        || tokenType === TokenTypes.LiteralNumber\r\n        || tokenType === TokenTypes.LiteralBool\r\n        || tokenType === TokenTypes.LiteralNull;\r\n}\r\n\r\nexport function getTokenType(token: Token): TokenTypes {\r\n    return token[1][0] as TokenTypes;\r\n}\r\n\r\nexport function getTokenValue(token: Token | null): TokenValue {\r\n    return token ? token[0] : null;\r\n}\r\n\r\nexport function getTokenLoc(token: Token): Uint16Array {\r\n    return token[1].subarray(1);\r\n}\r\n\r\nexport function getStartLine(token: Token): number {\r\n    return token[1][1];\r\n}\r\n\r\nexport function getStartColumn(token: Token): number {\r\n    return token[1][2];\r\n}\r\n\r\nexport function getEndLine(token: Token): number {\r\n    return token[1][3];\r\n}\r\n\r\nexport function getEndColumn(token: Token): number {\r\n    return token[1][4];\r\n}\r\n\r\nexport function splitTokens(tokens: Token[], separator: string): Token[][] {\r\n    const result: Token[][] = [];\r\n\r\n    if (!tokens.length) { return []; }\r\n\r\n    const sepIndexes = findTokenValueIndexes(tokens, value => value === separator);\r\n\r\n    let start = 0;\r\n    for (let i = 0; i < sepIndexes.length; i++) {\r\n        const ind = sepIndexes[i];\r\n        result.push(tokens.slice(start, ind));\r\n        start = ind + 1\r\n    }\r\n\r\n    result.push(tokens.slice(start, tokens.length));\r\n    return result;\r\n}\r\n\r\nexport function findTokenValueIndex(tokens: Token[], predicate: (value: TokenValue) => boolean, start = 0): number {\r\n    for (let i = start; i < tokens.length; i++) {\r\n        if (getTokenType(tokens[i]) === TokenTypes.LiteralString) { continue; }\r\n\r\n        if (getTokenValue(tokens[i]) === '(') {\r\n            i = skipInnerBrackets(tokens, i, '(', ')');\r\n        } else if (getTokenValue(tokens[i]) === '[') {\r\n            i = skipInnerBrackets(tokens, i, '[', ']');\r\n        } else if (getTokenValue(tokens[i]) === '{') {\r\n            i = skipInnerBrackets(tokens, i, '{', '}');\r\n        } else if (predicate(getTokenValue(tokens[i]))) {\r\n            return i;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nexport function findTokenValueIndexes(tokens: Token[], predicate: (value: TokenValue) => boolean): number[] {\r\n    const opIndexes: number[] = [];\r\n\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        const tValue = getTokenValue(tokens[i]);\r\n        const tType = getTokenType(tokens[i]);\r\n\r\n        if (tType === TokenTypes.LiteralString) { continue; }\r\n\r\n        if (tValue === '(') {\r\n            i = skipInnerBrackets(tokens, i, '(', ')');\r\n        } else if (tValue === '[') {\r\n            i = skipInnerBrackets(tokens, i, '[', ']');\r\n        } else if (tValue === '{') {\r\n            i = skipInnerBrackets(tokens, i, '{', '}');\r\n        } else if (predicate(tValue)) {\r\n            opIndexes.push(i);\r\n        }\r\n    }\r\n\r\n    return opIndexes;\r\n}\r\n\r\nexport function findOperators(tokens: Token[], operationType: OperationTypes | null = null): number[] {\r\n    return !operationType ? findTokenValueIndexes(tokens, value => OperatorsMap[value as Operators] !== undefined)\r\n        :\r\n        findTokenValueIndexes(tokens, value => OperatorsMap[value as Operators] === operationType);\r\n}\r\n\r\nfunction skipInnerBrackets(tokens: Token[], i: number, openChar: string, closeChar: string): number {\r\n    let innerBrackets = 0;\r\n    while (getTokenValue(tokens[++i]) !== closeChar || innerBrackets !== 0) {\r\n        if (i + 1 >= tokens.length) {\r\n            throw new Error(`Closing '${closeChar}' is missing`);\r\n        }\r\n\r\n        const tokenValue = getTokenValue(tokens[i]);\r\n        if (tokenValue === openChar) { innerBrackets++; }\r\n        if (tokenValue === closeChar) { innerBrackets--; }\r\n    }\r\n    return i;\r\n};\r\n","import { ExpressionOperators, LogicalOperators, OperationTypes, Operators } from \"./operators\";\r\nimport { getTokenLoc, getTokenValue, Token } from \"./token-types\";\r\n\r\nexport type AstNodeType = 'assign' | 'binOp' | 'const'\r\n    | 'logicalOp'\r\n    | 'getSingleVar' | 'setSingleVar' | 'dotObjectAccess' | 'bracketObjectAccess'\r\n    | 'funcCall' | 'funcDef' | 'arrowFuncDef'\r\n    | 'createObject' | 'createArray'\r\n    | 'if' | 'for' | 'while' | 'tryExcept' | 'raise'\r\n    | 'import' | 'comment'\r\n    | 'return' | 'continue' | 'break';\r\n\r\nexport interface NameAlias {\r\n    name: string,\r\n    alias: string | undefined\r\n}\r\n\r\nexport interface ExceptBody {\r\n    error: NameAlias;\r\n    body: AstNode[];\r\n}\r\n    \r\nexport interface FuncDefNode {\r\n    params: string[];\r\n    funcAst: AstBlock;\r\n}\r\n\r\nexport interface IsNullCoelsing {\r\n    nullCoelsing: boolean | undefined\r\n}\r\n\r\nexport interface ObjectPropertyInfo {\r\n    name: AstNode;\r\n    value: AstNode;\r\n}\r\n\r\nexport abstract class AstNode {\r\n    loc: Uint16Array | undefined = undefined;\r\n    constructor(public type: AstNodeType) { }\r\n}\r\n\r\nexport class AssignNode extends AstNode {\r\n    constructor(\r\n        public target: AstNode,\r\n        public source: AstNode,\r\n        public loc: Uint16Array) {\r\n        super('assign');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ConstNode extends AstNode {\r\n    public value: number | string | boolean | null;\r\n\r\n    constructor(token: Token) {\r\n        super('const');\r\n        this.value = getTokenValue(token);\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class CommentNode extends AstNode {\r\n    constructor(public comment: string, public loc: Uint16Array) {\r\n        super('comment');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ReturnNode extends AstNode {\r\n    constructor(public returnValue: AstNode | undefined = undefined, public loc: Uint16Array) {\r\n        super('return');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class RaiseNode extends AstNode {\r\n    constructor(public errorName: string, public errorMessage: string | undefined, public loc: Uint16Array) {\r\n        super('raise');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ContinueNode extends AstNode {\r\n    constructor() {\r\n        super('continue');\r\n    }\r\n}\r\n\r\nexport class BreakNode extends AstNode {\r\n    constructor() {\r\n        super('break');\r\n    }\r\n}\r\n\r\nexport class SetSingleVarNode extends AstNode {\r\n    public name: string;\r\n    constructor(token: Token) {\r\n        super('setSingleVar');\r\n        this.name = token[0] as string\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class FunctionCallNode extends AstNode implements IsNullCoelsing {\r\n    public nullCoelsing: boolean | undefined = undefined;\r\n\r\n    constructor(public name: string, public paramNodes: AstNode[] | null, public loc: Uint16Array) {\r\n        super('funcCall');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class FunctionDefNode extends AstNode implements FuncDefNode {\r\n    constructor(public funcAst: AstBlock, public params: string[], public isAsync: boolean, public loc: Uint16Array) {\r\n        super('funcDef');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ArrowFuncDefNode extends AstNode implements FuncDefNode {\r\n    constructor(public funcAst: AstBlock, public params: string[], public loc: Uint16Array) {\r\n        super('arrowFuncDef');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class IfNode extends AstNode {\r\n    constructor(\r\n        public conditionNode: AstNode,\r\n        public ifBody: AstNode[],\r\n        public elseBody: AstNode[] | undefined = undefined,\r\n        public loc: Uint16Array) {\r\n        super('if');\r\n        this.loc = loc\r\n    }\r\n}\r\n\r\nexport class TryExceptNode extends AstNode {\r\n    constructor(\r\n        public tryBody: AstNode[],\r\n        public exepts: ExceptBody[],\r\n        public elseBody: AstNode[] | undefined,\r\n        public finallyBody: AstNode[] | undefined,\r\n        \r\n        public loc: Uint16Array) {\r\n        super('tryExcept');\r\n        this.loc = loc\r\n    }\r\n}\r\n\r\nexport class ForNode extends AstNode {\r\n    constructor(public sourceArray: AstNode, public itemVarName: string, public body: AstNode[], public loc: Uint16Array) {\r\n        super('for');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class WhileNode extends AstNode {\r\n    constructor(public condition: AstNode, public body: AstNode[], public loc: Uint16Array) {\r\n        super('while');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ImportNode extends AstNode {\r\n    constructor(public module: NameAlias, public body: AstBlock, public parts: NameAlias[] | undefined = undefined, public loc: Uint16Array) {\r\n        super('import');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class GetSingleVarNode extends AstNode implements IsNullCoelsing {\r\n    name: string;\r\n    nullCoelsing: boolean | undefined = undefined;\r\n\r\n    constructor(token: Token, nullCoelsing: boolean | undefined = undefined) {\r\n        super('getSingleVar');\r\n        this.name = token[0] as string;\r\n        this.nullCoelsing = nullCoelsing;\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class DotObjectAccessNode extends AstNode {\r\n    constructor(public nestedProps: AstNode[], public loc: Uint16Array) {\r\n        super('dotObjectAccess');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class CreateObjectNode extends AstNode {\r\n    constructor(public props: ObjectPropertyInfo[], public loc: Uint16Array) {\r\n        super('createObject');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class CreateArrayNode extends AstNode {\r\n    constructor(public items: AstNode[], public loc: Uint16Array) {\r\n        super('createArray');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class BracketObjectAccessNode extends AstNode {\r\n    constructor(\r\n        public propertyName: string,\r\n        public bracketBody: AstNode,\r\n        public nullCoalescing: boolean | undefined = undefined,\r\n        public loc: Uint16Array) {\r\n        super('bracketObjectAccess');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport interface LogicalNodeItem {\r\n    node: AstNode,\r\n    op: LogicalOperators | undefined\r\n}\r\n\r\nexport class LogicalOpNode extends AstNode {\r\n    constructor(public items: LogicalNodeItem[],\r\n        public loc: Uint16Array) {\r\n        super('logicalOp');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class BinOpNode extends AstNode {\r\n    constructor(\r\n        public left: AstNode,\r\n        public op: ExpressionOperators,\r\n        public right: AstNode,\r\n        public loc: Uint16Array) {\r\n        super('binOp');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport interface AstBlock {\r\n    name: string;\r\n    type: 'module' | 'func' | 'if' | 'for' | 'while' | 'trycatch'\r\n    funcs: FunctionDefNode[];\r\n    body: AstNode[];\r\n}\r\n\r\n\r\n","\r\nexport interface BlockContext {\r\n    moduleName: string;\r\n    blockScope: Scope;\r\n    returnCalled?: boolean;\r\n    breakCalled?: boolean;\r\n    continueCalled?: boolean;\r\n    returnObject?: any;\r\n}\r\n\r\nexport function cloneContext(context: BlockContext): BlockContext {\r\n    return {\r\n        moduleName: context.moduleName,\r\n        blockScope: context.blockScope.clone()\r\n    } as BlockContext;\r\n}\r\n\r\nexport class Scope {\r\n    private readonly scope: Record<string, unknown> = {};\r\n\r\n    constructor(initialScope: Record<string, unknown>) {\r\n        this.scope = { ...initialScope };\r\n    }\r\n\r\n    getScope(): Record<string, unknown> {\r\n        return this.scope;\r\n    }\r\n\r\n    clone(): Scope {\r\n        return new Scope(this.scope);\r\n    }\r\n    set(key: string, value: unknown, path: string = '\\\\'): void {\r\n        this.scope[key] = value;\r\n    }\r\n\r\n    get(key: string, path: string = '\\\\'): unknown {\r\n        return this.scope[key];\r\n    }\r\n}\r\n","import {\r\n    ArrowFuncDefNode,\r\n    AssignNode, AstBlock, AstNode, BinOpNode, BracketObjectAccessNode, ConstNode, CreateArrayNode,\r\n    CreateObjectNode, DotObjectAccessNode, ForNode, FuncDefNode, FunctionCallNode, FunctionDefNode, GetSingleVarNode,\r\n    IfNode, IsNullCoelsing, LogicalOpNode, OperationFuncs, Primitive, RaiseNode, ReturnNode, SetSingleVarNode, TryExceptNode, WhileNode\r\n} from '../common';\r\nimport { JspyError, JspyEvalError } from '../common/utils';\r\nimport { BlockContext, cloneContext, Scope } from './scope';\r\n\r\nexport class Evaluator {\r\n\r\n    evalBlock(ast: AstBlock, blockContext: BlockContext): unknown {\r\n        let lastResult = null;\r\n\r\n        for (let node of ast?.funcs || []) {\r\n            const funcDef = node as FunctionDefNode;\r\n\r\n            // a child scope needs to be created here\r\n            const newScope = blockContext.blockScope;\r\n\r\n            newScope.set(funcDef.funcAst.name,\r\n                (...args: unknown[]): unknown => this.jspyFuncInvoker(funcDef, blockContext, ...args)\r\n            );\r\n        }\r\n\r\n        for (const node of ast.body) {\r\n            if (node.type === 'comment') { continue; }\r\n            if (node.type === 'import') {\r\n                // we can't use it here, because loader has to be promise\r\n                throw new Error(`Import is not support with 'eval'. Use method 'evalAsync' instead`);\r\n            }\r\n            try {\r\n                lastResult = this.evalNode(node, blockContext);\r\n\r\n                if (blockContext.returnCalled) {\r\n                    const res = blockContext.returnObject;\r\n\r\n                    // stop processing return\r\n                    if (ast.type == 'func' || ast.type == 'module') {\r\n                        blockContext.returnCalled = false;\r\n                        blockContext.returnObject = null;\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                if (blockContext.continueCalled) {\r\n                    break;\r\n                }\r\n                if (blockContext.breakCalled) {\r\n                    break;\r\n                }\r\n            } catch (err) {\r\n                const loc = node.loc ? node.loc : [0, 0]\r\n                if (err instanceof JspyError) {\r\n                    throw err;\r\n                } else if (err instanceof JspyEvalError) {\r\n                    throw err;\r\n                } else {\r\n                    throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], err.message || err)\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return lastResult;\r\n    }\r\n\r\n    jspyFuncInvoker(funcDef: FuncDefNode, context: BlockContext, ...args: unknown[]): unknown {\r\n        const ast = Object.assign({}, funcDef.funcAst);\r\n        ast.type = 'func';\r\n\r\n        const blockContext = cloneContext(context);\r\n\r\n        // set parameters into new scope, based incomming arguments        \r\n        for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n            const argValue = args?.length > i ? args[i] : null;\r\n            blockContext.blockScope.set(funcDef.params[i], argValue);\r\n        }\r\n\r\n        return this.evalBlock(ast, blockContext);\r\n    }\r\n\r\n    private invokeFunction(func: (...args: unknown[]) => unknown, fps: unknown[],\r\n        loc: { moduleName: string, line: number, column: number }): unknown {\r\n\r\n        if (fps.length === 0) { return func(); }\r\n        if (fps.length === 1) { return func(fps[0]); }\r\n        if (fps.length === 2) { return func(fps[0], fps[1]); }\r\n        if (fps.length === 3) { return func(fps[0], fps[1], fps[2]); }\r\n        if (fps.length === 4) {\r\n            return func(fps[0], fps[1], fps[2], fps[3]);\r\n        }\r\n        if (fps.length === 5) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4]);\r\n        }\r\n\r\n        if (fps.length === 6) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5]);\r\n        }\r\n\r\n        if (fps.length === 7) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6]);\r\n        }\r\n\r\n        if (fps.length === 8) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7]);\r\n        }\r\n\r\n        if (fps.length === 9) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8]);\r\n        }\r\n\r\n        if (fps.length === 10) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9]);\r\n        }\r\n\r\n        if (fps.length === 11) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10]);\r\n        }\r\n\r\n        if (fps.length === 12) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11]);\r\n        }\r\n\r\n        if (fps.length === 13) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12]);\r\n        }\r\n\r\n        if (fps.length === 14) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13]);\r\n        }\r\n\r\n        if (fps.length === 15) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13], fps[14]);\r\n        }\r\n\r\n        throw Error('Function has too many parameters. Current limitation is 15');\r\n\r\n    }\r\n\r\n    private evalNode(node: AstNode, blockContext: BlockContext): unknown {\r\n        if (node.type === 'import') {\r\n            // skip this for now. As modules are implemented externally\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'comment') {\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'if') {\r\n            const ifNode = node as IfNode;\r\n            if (this.evalNode(ifNode.conditionNode, blockContext)) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock, blockContext);\r\n            } else if (ifNode.elseBody) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock, blockContext);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'raise') {\r\n            const raiseNode = node as RaiseNode;\r\n            const err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, raiseNode.errorMessage || \"\");\r\n            throw err;\r\n        }\r\n\r\n        if (node.type === 'tryExcept') {\r\n            const tryNode = node as TryExceptNode;\r\n            try {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock, blockContext);\r\n\r\n                if (tryNode.elseBody?.length || 0 > 0) {\r\n                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n            catch (err) {\r\n                const name = (err instanceof JspyError) ? (err as JspyError).name : typeof (err);\r\n                const message = (err instanceof JspyError) ? (err as JspyError).message : err?.message ?? String(err);\r\n                const moduleName = (err instanceof JspyError) ? (err as JspyError).module : 0;\r\n                const line = (err instanceof JspyError) ? (err as JspyError).line : 0;\r\n                const column = (err instanceof JspyError) ? (err as JspyError).column : 0;\r\n\r\n                const firstExept = tryNode.exepts[0];\r\n                const catchBody = firstExept.body;\r\n                const ctx = blockContext;// cloneContext(blockContext);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", { name, message, line, column, moduleName })\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock, ctx);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", null)\r\n            }\r\n            finally {\r\n                if (tryNode.finallyBody?.length || 0 > 0) {\r\n                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.finallyBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'return') {\r\n            const returnNode = node as ReturnNode;\r\n            blockContext.returnCalled = true;\r\n            blockContext.returnObject = returnNode.returnValue ?\r\n                this.evalNode(returnNode.returnValue, blockContext)\r\n                : null;\r\n\r\n            return blockContext.returnObject;\r\n        }\r\n\r\n        if (node.type === 'continue') {\r\n            blockContext.continueCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'break') {\r\n            blockContext.breakCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'for') {\r\n            const forNode = node as ForNode;\r\n\r\n            const array = this.evalNode(forNode.sourceArray, blockContext) as unknown[] | string;\r\n\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n\r\n                blockContext.blockScope.set(forNode.itemVarName, item);\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock, blockContext);\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'while') {\r\n            const whileNode = node as WhileNode;\r\n\r\n            while (this.evalNode(whileNode.condition, blockContext)) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock, blockContext);\r\n\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === \"const\") {\r\n            return (node as ConstNode).value;\r\n        }\r\n\r\n        if (node.type === \"getSingleVar\") {\r\n            const name = (node as GetSingleVarNode).name;\r\n\r\n            const value = blockContext.blockScope.get((node as GetSingleVarNode).name);\r\n            if (value === undefined) {\r\n                if (name.charAt(name.length - 1) === ';') {\r\n                    throw new Error(`Unexpected ';' in the end.`);\r\n                } else {\r\n                    throw new Error(`Variable '${name}' is not defined.`);\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n\r\n        if (node.type === \"binOp\") {\r\n            const binOpNode = (node as BinOpNode);\r\n            var left = this.evalNode(binOpNode.left, blockContext);\r\n            var right = this.evalNode(binOpNode.right, blockContext);\r\n            return OperationFuncs[binOpNode.op](left as Primitive, right as Primitive);\r\n        }\r\n\r\n        if (node.type === \"logicalOp\") {\r\n            const logicalGroups = (node as LogicalOpNode);\r\n            let ind = 0;\r\n            let gResult: any = true;\r\n\r\n            while (ind < logicalGroups.items.length) {\r\n                const eg = logicalGroups.items[ind++];\r\n\r\n                gResult = this.evalNode(eg.node, blockContext)\r\n\r\n                if (eg.op === 'and' && !gResult) { return false; }\r\n                if (eg.op === 'or' && gResult) { return gResult; }\r\n            }\r\n\r\n            return gResult;\r\n        }\r\n\r\n        if (node.type === \"arrowFuncDef\") {\r\n            const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n            return (...args: unknown[]): unknown => this.jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n        }\r\n\r\n        if (node.type === \"funcCall\") {\r\n            const funcCallNode = node as FunctionCallNode;\r\n            const func = blockContext.blockScope.get(funcCallNode.name) as (...args: unknown[]) => unknown;\r\n            if (typeof func !== 'function') {\r\n                throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n            }\r\n\r\n            const pms = funcCallNode.paramNodes?.map(n => this.evalNode(n, blockContext)) || []\r\n\r\n            return this.invokeFunction(func, pms, {\r\n                moduleName: blockContext.moduleName,\r\n                line: funcCallNode.loc[0],\r\n                column: funcCallNode.loc[1]\r\n            });\r\n        }\r\n\r\n        if (node.type === \"assign\") {\r\n            const assignNode = node as AssignNode;\r\n\r\n            if (assignNode.target.type === 'getSingleVar') {\r\n                const node = assignNode.target as SetSingleVarNode;\r\n                blockContext.blockScope.set(node.name, this.evalNode(assignNode.source, blockContext));\r\n            } else if (assignNode.target.type === 'dotObjectAccess') {\r\n                const targetNode = assignNode.target as DotObjectAccessNode;\r\n\r\n                // create a node for all but last property token\r\n                // potentially it can go to parser\r\n                const targetObjectNode = new DotObjectAccessNode(targetNode.nestedProps.slice(0, targetNode.nestedProps.length - 1), targetNode.loc);\r\n                const targetObject = this.evalNode(targetObjectNode, blockContext) as Record<string, unknown>;\r\n\r\n                // not sure nested properties should be GetSingleVarNode\r\n                // can be factored in the parser\r\n                const lastPropertyName = (targetNode.nestedProps[targetNode.nestedProps.length - 1] as GetSingleVarNode).name\r\n\r\n                targetObject[lastPropertyName] = this.evalNode(assignNode.source, blockContext);\r\n            } else if (assignNode.target.type === 'bracketObjectAccess') {\r\n                const targetNode = assignNode.target as BracketObjectAccessNode;\r\n                const keyValue = this.evalNode(targetNode.bracketBody, blockContext) as string | number;\r\n                const targetObject = blockContext.blockScope.get(targetNode.propertyName as string) as Record<string, unknown>;\r\n\r\n                targetObject[keyValue] = this.evalNode(assignNode.source, blockContext);\r\n            } else {\r\n                throw Error('Not implemented Assign operation');\r\n                // get chaining calls\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'bracketObjectAccess') {\r\n            const sbNode = node as BracketObjectAccessNode;\r\n            const key = this.evalNode(sbNode.bracketBody, blockContext) as string;\r\n            const obj = blockContext.blockScope.get(sbNode.propertyName as string) as Record<string, unknown>;\r\n            return (obj[key] === undefined) ? null : obj[key];\r\n        }\r\n\r\n        if (node.type === \"dotObjectAccess\") {\r\n            const dotObject = node as DotObjectAccessNode;\r\n\r\n            let startObject = this.evalNode(dotObject.nestedProps[0], blockContext) as any;\r\n            for (let i = 1; i < dotObject.nestedProps.length; i++) {\r\n                const nestedProp = dotObject.nestedProps[i];\r\n\r\n                if ((dotObject.nestedProps[i - 1] as any).nullCoelsing && !startObject) {\r\n                    startObject = {};\r\n                }\r\n\r\n                if (nestedProp.type === 'getSingleVar') {\r\n                    startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n                } else if (nestedProp.type === 'bracketObjectAccess') {\r\n                    const node = nestedProp as BracketObjectAccessNode;\r\n                    startObject = startObject[node.propertyName] as unknown;\r\n                    startObject = startObject[this.evalNode(node.bracketBody, blockContext) as string] as unknown;\r\n                } else if (nestedProp.type === 'funcCall') {\r\n                    const funcCallNode = nestedProp as FunctionCallNode;\r\n                    const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n                    if ((func === undefined || func === null)\r\n                        && (dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing) {\r\n                        startObject = null;\r\n                        continue;\r\n                    }\r\n\r\n                    if (typeof func !== 'function') {\r\n                        throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n                    }\r\n                    const pms = funcCallNode.paramNodes?.map(n => this.evalNode(n, blockContext)) || []\r\n                    startObject = this.invokeFunction(func.bind(startObject), pms, {\r\n                        moduleName: blockContext.moduleName,\r\n                        line: funcCallNode.loc[0],\r\n                        column: funcCallNode.loc[1]\r\n                    });\r\n\r\n                } else {\r\n                    throw Error(\"Can't resolve dotObjectAccess node\")\r\n                }\r\n            }\r\n\r\n            // no undefined values, make it rather null\r\n            return (startObject === undefined) ? null : startObject;\r\n        }\r\n\r\n        if (node.type === 'createObject') {\r\n            const createObjectNode = node as CreateObjectNode;\r\n            const obj = {} as Record<string, unknown>;\r\n\r\n            for (const p of createObjectNode.props) {\r\n                obj[this.evalNode(p.name, blockContext) as string] = this.evalNode(p.value, blockContext);\r\n            }\r\n\r\n            return obj;\r\n        }\r\n\r\n        if (node.type === 'createArray') {\r\n            const arrayNode = node as CreateArrayNode;\r\n            const res = [] as unknown[];\r\n\r\n            for (const item of arrayNode.items) {\r\n                res.push(this.evalNode(item, blockContext));\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n    }\r\n}\r\n","import {\r\n    ArrowFuncDefNode,\r\n    AssignNode, AstBlock, AstNode, BinOpNode, BracketObjectAccessNode, ConstNode, CreateArrayNode,\r\n    CreateObjectNode, DotObjectAccessNode, ForNode, FuncDefNode, FunctionCallNode, FunctionDefNode, GetSingleVarNode,\r\n    getStartLine,\r\n    getTokenLoc,\r\n    IfNode, ImportNode, IsNullCoelsing, LogicalOpNode, OperationFuncs, Primitive, RaiseNode, ReturnNode, SetSingleVarNode, TryExceptNode, WhileNode\r\n} from '../common';\r\nimport { JspyEvalError, JspyError, getImportType } from '../common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { BlockContext, cloneContext, Scope } from './scope';\r\n\r\n/**\r\n * This is copy/paste from Evaluator.\r\n * Sadly, we have to copy code around to support both async and non async methods.\r\n * So, any changes to this method, should be replicated in the evaluator.ts\r\n */\r\nexport class EvaluatorAsync {\r\n\r\n    private moduleParser: (modulePath: string) => Promise<AstBlock> = () => Promise.reject('Module parser is not registered!');\r\n    private jsonFileLoader: (jsonFilePath: string) => Promise<string> = () => Promise.reject('{}');\r\n    private blockContextFactory?: (modulePath: string, ast: AstBlock) => BlockContext;\r\n\r\n    registerModuleParser(moduleParser: (modulePath: string) => Promise<AstBlock>): EvaluatorAsync {\r\n        this.moduleParser = moduleParser;\r\n        return this;\r\n    }\r\n\r\n    registerJsonFileLoader(jsonFileLoader: (modulePath: string) => Promise<string>): EvaluatorAsync {\r\n        this.jsonFileLoader = jsonFileLoader;\r\n        return this;\r\n    }\r\n\r\n    registerBlockContextFactory(blockContextFactory: (modulePath: string, ast: AstBlock) => BlockContext): EvaluatorAsync {\r\n        this.blockContextFactory = blockContextFactory;\r\n        return this;\r\n    }\r\n\r\n    async evalBlockAsync(ast: AstBlock, blockContext: BlockContext): Promise<unknown> {\r\n        let lastResult = null;\r\n\r\n        for (let node of ast?.funcs || []) {\r\n            const funcDef = node as FunctionDefNode;\r\n\r\n            // a child scope needs to be created here\r\n            const newScope = blockContext.blockScope;\r\n\r\n            const invoker = (funcDef.isAsync) ?\r\n                async (...args: unknown[]): Promise<unknown> => await this.jspyFuncInvokerAsync(funcDef, blockContext, ...args)\r\n                : (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(funcDef, blockContext, ...args);\r\n\r\n            newScope.set(funcDef.funcAst.name, invoker);\r\n        }\r\n\r\n        for (const node of ast.body) {\r\n            if (node.type === 'comment') { continue; }\r\n            if (node.type === 'import') {\r\n                const importNode = node as ImportNode;\r\n                const iType = getImportType(importNode.module.name);\r\n\r\n                if (iType === 'json') {\r\n                    const jsonValue = JSON.parse(await this.jsonFileLoader(importNode.module.name));\r\n                    blockContext.blockScope\r\n                        .set(importNode.module.alias || this.defaultModuleName(importNode.module.name), jsonValue);\r\n                    continue;\r\n                } else if (iType !== 'jspyModule') {\r\n                    // it is not JSPY import. It is JS and should be handled externally\r\n                    continue;\r\n                }\r\n\r\n                if (typeof this.blockContextFactory !== 'function') {\r\n                    throw new Error('blockContextFactory is not initialized');\r\n                }\r\n\r\n                const moduleAst = await this.moduleParser(importNode.module.name);\r\n                const moduleBlockContext = this.blockContextFactory(importNode.module.name, moduleAst);\r\n                await this.evalBlockAsync(moduleAst, moduleBlockContext);\r\n\r\n                let scope = blockContext.blockScope.getScope();\r\n\r\n                if (!importNode.parts?.length) {\r\n                    // if no parts, then we need to assign to a separate object\r\n                    scope = {};\r\n                    blockContext.blockScope.set(importNode.module.alias || this.defaultModuleName(importNode.module.name), scope);\r\n                }\r\n\r\n                this.assignFunctionsToScope(scope, moduleBlockContext, moduleAst, importNode.parts?.map(p => p.name));\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                lastResult = await this.evalNodeAsync(node, blockContext);\r\n                if (blockContext.returnCalled) {\r\n                    const res = blockContext.returnObject;\r\n                    // stop processing return\r\n                    if (ast.type == 'func' || ast.type == 'module') {\r\n                        blockContext.returnCalled = false;\r\n                        blockContext.returnObject = null;\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                if (blockContext.continueCalled) {\r\n                    break;\r\n                }\r\n                if (blockContext.breakCalled) {\r\n                    break;\r\n                }\r\n            } catch (err) {\r\n                const loc = node.loc ? node.loc : [0, 0]\r\n                if (err instanceof JspyError) {\r\n                    throw err;\r\n                } else if (err instanceof JspyEvalError) {\r\n                    throw err;\r\n                } else {\r\n                    throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], err.message || err)\r\n                }\r\n            }\r\n        }\r\n\r\n        return lastResult;\r\n    }\r\n\r\n    private assignFunctionsToScope(scope: Record<string, unknown>, moduleBlockContext: BlockContext,\r\n        moduleAst: AstBlock, parts?: string[]): void {\r\n\r\n        const funcs = moduleAst.funcs.filter(f => !parts || parts.indexOf(f.funcAst?.name) >= 0);\r\n\r\n        for (let i = 0; i < funcs.length; i++) {\r\n            const funcDef = funcs[i] as FunctionDefNode;\r\n\r\n            const invoker = (funcDef.isAsync) ?\r\n                async (...args: unknown[]): Promise<unknown> => await this.jspyFuncInvokerAsync(funcDef, moduleBlockContext, ...args)\r\n                : (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(funcDef, moduleBlockContext, ...args);\r\n\r\n            scope[funcDef.funcAst.name] = invoker;\r\n        }\r\n    }\r\n\r\n    private defaultModuleName(name: string): string {\r\n        return name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.'))\r\n    }\r\n\r\n    private async jspyFuncInvokerAsync(funcDef: FuncDefNode, context: BlockContext, ...args: unknown[]): Promise<unknown> {\r\n\r\n        const ast = Object.assign({}, funcDef.funcAst);\r\n        ast.type = 'func';\r\n\r\n        const blockContext = cloneContext(context);\r\n\r\n        // set parameters into new scope, based incomming arguments        \r\n        for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n            const argValue = args?.length > i ? args[i] : null;\r\n            blockContext.blockScope.set(funcDef.params[i], argValue);\r\n        }\r\n\r\n        return await this.evalBlockAsync(ast, blockContext);\r\n    }\r\n\r\n    private async invokeFunctionAsync(func: (...args: unknown[]) => unknown, fps: unknown[],\r\n        loc?: { moduleName: string, line: number, column: number }): Promise<unknown> {\r\n\r\n        if (fps.length === 0) { return await func(); }\r\n        if (fps.length === 1) { return await func(fps[0]); }\r\n        if (fps.length === 2) { return await func(fps[0], fps[1]); }\r\n        if (fps.length === 3) { return await func(fps[0], fps[1], fps[2]); }\r\n        if (fps.length === 4) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3]);\r\n        }\r\n        if (fps.length === 5) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4]);\r\n        }\r\n\r\n        if (fps.length === 6) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5]);\r\n        }\r\n\r\n        if (fps.length === 7) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6]);\r\n        }\r\n\r\n        if (fps.length === 8) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7]);\r\n        }\r\n\r\n        if (fps.length === 9) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8]);\r\n        }\r\n\r\n        if (fps.length === 10) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9]);\r\n        }\r\n\r\n        if (fps.length === 11) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10]);\r\n        }\r\n\r\n        if (fps.length === 12) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11]);\r\n        }\r\n\r\n        if (fps.length === 13) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12]);\r\n        }\r\n\r\n        if (fps.length === 14) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13]);\r\n        }\r\n\r\n        if (fps.length === 15) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13], fps[14]);\r\n        }\r\n\r\n        throw Error('Function has too many parameters. Current limitation is 15');\r\n\r\n    }\r\n\r\n    private async evalNodeAsync(node: AstNode, blockContext: BlockContext): Promise<unknown> {\r\n        if (node.type === 'import') {\r\n            throw new Error('Import should be defined at the start');\r\n        }\r\n\r\n        if (node.type === 'comment') {\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'if') {\r\n            const ifNode = node as IfNode;\r\n            if (await this.evalNodeAsync(ifNode.conditionNode, blockContext)) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock, blockContext);\r\n            } else if (ifNode.elseBody) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock, blockContext);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'raise') {\r\n            const raiseNode = node as RaiseNode;\r\n            const err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, raiseNode.errorMessage || \"\");\r\n            throw err;\r\n        }\r\n\r\n        if (node.type === 'tryExcept') {\r\n            const tryNode = node as TryExceptNode;\r\n            try {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock, blockContext);\r\n\r\n                if (tryNode.elseBody?.length || 0 > 0) {\r\n                    await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n            catch (err) {\r\n                // catches here all exceptions. Including JSPY Eval errors\r\n                const name = (err instanceof JspyError) ? (err as JspyError).name : typeof (err);\r\n                const message = (err instanceof JspyError) ? (err as JspyError).message : err?.message ?? String(err);\r\n                const moduleName = (err instanceof JspyError) ? (err as JspyError).module : 0;\r\n                const line = (err instanceof JspyError) ? (err as JspyError).line : 0;\r\n                const column = (err instanceof JspyError) ? (err as JspyError).column : 0;\r\n\r\n                const firstExept = tryNode.exepts[0];\r\n                const catchBody = firstExept.body;\r\n                const ctx = blockContext;\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", { name, message, line, column, moduleName })\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock, ctx);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", null);\r\n            }\r\n            finally {\r\n                if (tryNode.finallyBody?.length || 0 > 0) {\r\n                    await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.finallyBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'return') {\r\n            const returnNode = node as ReturnNode;\r\n            blockContext.returnCalled = true;\r\n            blockContext.returnObject = returnNode.returnValue ?\r\n                await this.evalNodeAsync(returnNode.returnValue, blockContext)\r\n                : null;\r\n\r\n            return blockContext.returnObject;\r\n        }\r\n\r\n        if (node.type === 'continue') {\r\n            blockContext.continueCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'break') {\r\n            blockContext.breakCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'for') {\r\n            const forNode = node as ForNode;\r\n\r\n            const array = await this.evalNodeAsync(forNode.sourceArray, blockContext) as unknown[] | string;\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n                blockContext.blockScope.set(forNode.itemVarName, item);\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock, blockContext);\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'while') {\r\n            const whileNode = node as WhileNode;\r\n\r\n            while (await this.evalNodeAsync(whileNode.condition, blockContext)) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock, blockContext);\r\n\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === \"const\") {\r\n            return (node as ConstNode).value;\r\n        }\r\n\r\n        if (node.type === \"getSingleVar\") {\r\n            const name = (node as GetSingleVarNode).name;\r\n            const value = blockContext.blockScope.get(name);\r\n\r\n            if (value === undefined) {\r\n                if (name.charAt(name.length - 1) === ';') {\r\n                    throw new Error(`Unexpected ';' in the end.`);\r\n                } else {\r\n                    throw new Error(`Variable '${name}' is not defined.`);\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n\r\n        if (node.type === \"binOp\") {\r\n            const binOpNode = (node as BinOpNode);\r\n            var left = await this.evalNodeAsync(binOpNode.left, blockContext);\r\n            var right = await this.evalNodeAsync(binOpNode.right, blockContext);\r\n            return OperationFuncs[binOpNode.op](left as Primitive, right as Primitive);\r\n        }\r\n\r\n        if (node.type === \"logicalOp\") {\r\n            const logicalGroups = (node as LogicalOpNode);\r\n            let ind = 0;\r\n            let gResult: any = true;\r\n\r\n            while (ind < logicalGroups.items.length) {\r\n                const eg = logicalGroups.items[ind++];\r\n\r\n                gResult = await this.evalNodeAsync(eg.node, blockContext)\r\n\r\n                if (eg.op === 'and' && !gResult) { return false; }\r\n                if (eg.op === 'or' && gResult) { return gResult; }\r\n            }\r\n\r\n            return gResult;\r\n        }\r\n\r\n        if (node.type === \"arrowFuncDef\") {\r\n            const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n            return (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n        }\r\n\r\n        if (node.type === \"funcCall\") {\r\n            const funcCallNode = node as FunctionCallNode;\r\n            const func = blockContext.blockScope.get(funcCallNode.name) as (...args: unknown[]) => unknown;\r\n\r\n            if (typeof func !== 'function') {\r\n                throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n            }\r\n\r\n            const pms = [];\r\n            for (let p of funcCallNode.paramNodes || []) {\r\n                pms.push(await this.evalNodeAsync(p, blockContext));\r\n            }\r\n\r\n            return await this.invokeFunctionAsync(func, pms, {\r\n                moduleName: blockContext.moduleName,\r\n                line: funcCallNode.loc[0],\r\n                column: funcCallNode.loc[0]\r\n            });\r\n        }\r\n\r\n        if (node.type === \"assign\") {\r\n            const assignNode = node as AssignNode;\r\n\r\n            if (assignNode.target.type === 'getSingleVar') {\r\n                const node = assignNode.target as SetSingleVarNode;\r\n                blockContext.blockScope.set(node.name, await this.evalNodeAsync(assignNode.source, blockContext));\r\n            } else if (assignNode.target.type === 'dotObjectAccess') {\r\n                const targetNode = assignNode.target as DotObjectAccessNode;\r\n\r\n                // create a node for all but last property token\r\n                // potentially it can go to parser\r\n                const targetObjectNode = new DotObjectAccessNode(targetNode.nestedProps.slice(0, targetNode.nestedProps.length - 1), targetNode.loc);\r\n                const targetObject = await this.evalNodeAsync(targetObjectNode, blockContext) as Record<string, unknown>;\r\n\r\n                // not sure nested properties should be GetSingleVarNode\r\n                // can be factored in the parser\r\n                const lastPropertyName = (targetNode.nestedProps[targetNode.nestedProps.length - 1] as GetSingleVarNode).name\r\n\r\n                targetObject[lastPropertyName] = await this.evalNodeAsync(assignNode.source, blockContext);\r\n            } else if (assignNode.target.type === 'bracketObjectAccess') {\r\n                const targetNode = assignNode.target as BracketObjectAccessNode;\r\n                const keyValue = await this.evalNodeAsync(targetNode.bracketBody, blockContext) as string | number;\r\n                const targetObject = blockContext.blockScope.get(targetNode.propertyName as string) as Record<string, unknown>;\r\n\r\n                targetObject[keyValue] = await this.evalNodeAsync(assignNode.source, blockContext);\r\n            } else {\r\n                throw Error('Not implemented Assign operation');\r\n                // get chaining calls\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'bracketObjectAccess') {\r\n            const sbNode = node as BracketObjectAccessNode;\r\n            const key = await this.evalNodeAsync(sbNode.bracketBody, blockContext) as string;\r\n            const obj = blockContext.blockScope.get(sbNode.propertyName as string) as Record<string, unknown>;\r\n            return (obj[key] === undefined) ? null : obj[key];\r\n        }\r\n\r\n        if (node.type === \"dotObjectAccess\") {\r\n            const dotObject = node as DotObjectAccessNode;\r\n\r\n            let startObject = await this.evalNodeAsync(dotObject.nestedProps[0], blockContext) as any;\r\n            for (let i = 1; i < dotObject.nestedProps.length; i++) {\r\n                const nestedProp = dotObject.nestedProps[i];\r\n\r\n                if ((dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing && !startObject) {\r\n                    startObject = {};\r\n                }\r\n\r\n                if (nestedProp.type === 'getSingleVar') {\r\n                    startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n                } else if (nestedProp.type === 'bracketObjectAccess') {\r\n                    const node = nestedProp as BracketObjectAccessNode;\r\n                    startObject = startObject[node.propertyName] as unknown;\r\n                    startObject = startObject[await this.evalNodeAsync(node.bracketBody, blockContext) as string] as unknown;\r\n                } else if (nestedProp.type === 'funcCall') {\r\n                    const funcCallNode = nestedProp as FunctionCallNode;\r\n                    const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n                    if ((func === undefined || func === null)\r\n                        && (dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing) {\r\n                        startObject = null;\r\n                        continue;\r\n                    }\r\n\r\n                    if (typeof (func) !== 'function') {\r\n                        throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n                    }\r\n                    const pms = []\r\n                    for (let p of funcCallNode.paramNodes || []) {\r\n                        pms.push(await this.evalNodeAsync(p, blockContext));\r\n                    }\r\n\r\n                    startObject = await this.invokeFunctionAsync(func.bind(startObject), pms, {\r\n                        moduleName: blockContext.moduleName,\r\n                        line: funcCallNode.loc[0],\r\n                        column: funcCallNode.loc[0]\r\n                    });\r\n\r\n                } else {\r\n                    throw Error(\"Can't resolve dotObjectAccess node\")\r\n                }\r\n            }\r\n\r\n            // no undefined values, make it rather null\r\n            return (startObject === undefined) ? null : startObject;\r\n        }\r\n\r\n        if (node.type === 'createObject') {\r\n            const createObjectNode = node as CreateObjectNode;\r\n            const obj = {} as Record<string, unknown>;\r\n\r\n            for (const p of createObjectNode.props) {\r\n                obj[await this.evalNodeAsync(p.name, blockContext) as string] = await this.evalNodeAsync(p.value, blockContext);\r\n            }\r\n\r\n            return obj;\r\n        }\r\n\r\n        if (node.type === 'createArray') {\r\n            const arrayNode = node as CreateArrayNode;\r\n            const res = [] as unknown[];\r\n\r\n            for (const item of arrayNode.items) {\r\n                res.push(await this.evalNodeAsync(item, blockContext));\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n    }\r\n}\r\n","import { parseDatetimeOrNull } from \"./common/utils\";\r\n\r\nexport const INITIAL_SCOPE = {\r\n    jsPython(): string {\r\n        return [`JSPython v2.1.7`, \"(c) 2021 FalconSoft Ltd. All rights reserved.\"].join('\\n')\r\n    },\r\n    dateTime: (str: number | string | any = null) => parseDatetimeOrNull(str) || new Date(),\r\n    range: range,\r\n    print: (...args: any[]) => { console.log(...args); return args.length > 0 ? args[0] : null; },\r\n    isNull: (v: any, defValue: any = null): boolean | any => defValue === null ? v === null : v || defValue,\r\n    isDate: (d: any): boolean => d instanceof Date,\r\n    isFunction: (v: any): boolean => typeof v === 'function',\r\n    isString: (v: any): boolean => typeof v === 'string',\r\n    deleteProperty: (obj: any, propName: string): boolean => delete obj[propName],\r\n    Math: Math,\r\n    Object: Object,\r\n    Array: Array,\r\n    JSON: JSON,\r\n    printExecutionContext: () => {}, // will be overriden at runtime\r\n    getExecutionContext: () => {} // will be overriden at runtime\r\n};\r\n\r\n/**\r\n * This interface needs to be replaced\r\n */\r\nexport interface PackageToImport {\r\n    name: string;\r\n    properties?: { name: string, as?: string }[];\r\n    as?: string;\r\n}\r\n\r\nfunction range(start: number, stop: number = NaN, step: number = 1): number[] {\r\n    const arr: number[] = [];\r\n    const isStopNaN = isNaN(stop);\r\n    stop = isStopNaN ? start : stop;\r\n    start = isStopNaN ? 0 : start;\r\n    let i = start;\r\n    while (i < stop) {\r\n        arr.push(i);\r\n        i += step;\r\n    }\r\n    return arr;\r\n}\r\n","import {\r\n    BinOpNode, ConstNode, AstBlock, Token, ParserOptions, AstNode, Operators, AssignNode, TokenTypes,\r\n    GetSingleVarNode, FunctionCallNode, getTokenType, getTokenValue, isTokenTypeLiteral, getStartLine,\r\n    getStartColumn, getEndColumn, getEndLine, findOperators, splitTokens, DotObjectAccessNode, BracketObjectAccessNode,\r\n    findTokenValueIndex, FunctionDefNode, CreateObjectNode, ObjectPropertyInfo, CreateArrayNode, ArrowFuncDefNode,\r\n    ExpressionOperators, IfNode, ForNode, WhileNode, ImportNode, NameAlias, ContinueNode, BreakNode, ReturnNode, CommentNode,\r\n    getTokenLoc, OperationTypes, LogicalNodeItem, LogicalOperators, LogicalOpNode, ComparisonOperators, TryExceptNode, ExceptBody, RaiseNode\r\n} from '../common';\r\nimport { JspyParserError } from '../common/utils';\r\n\r\nclass InstructionLine {\r\n    readonly tokens: Token[] = [];\r\n\r\n    startLine(): number {\r\n        return getStartLine(this.tokens[0]);\r\n    }\r\n\r\n    startColumn(): number {\r\n        return getStartColumn(this.tokens[0]);\r\n    }\r\n\r\n    endLine(): number {\r\n        return getEndLine(this.tokens[this.tokens.length - 1]);\r\n    }\r\n\r\n    endColumn(): number {\r\n        return getEndColumn(this.tokens[this.tokens.length - 1]);\r\n    }\r\n}\r\n\r\nexport class Parser {\r\n    private _currentToken: Token | null = null;\r\n    private _moduleName = '';\r\n\r\n    /**\r\n     * Parses tokens and return Ast - Abstract Syntax Tree for jsPython code\r\n     * @param tokens tokens\r\n     * @param options parsing options. By default it will exclude comments and include LOC (Line of code)\r\n     */\r\n    parse(tokens: Token[], name = 'main.jspy', type = 'module'): AstBlock {\r\n        this._moduleName = name;\r\n        const ast = { name, type, funcs: [], body: [] } as AstBlock;\r\n\r\n        if (!tokens || !tokens.length) { return ast; }\r\n\r\n        try {\r\n\r\n            // group all tokens into an Instruction lines.\r\n            const instructions = this.tokensToInstructionLines(tokens, 1);\r\n\r\n            // process all instructions\r\n            this.instructionsToNodes(instructions, ast);\r\n\r\n        } catch (err) {\r\n            const token = this._currentToken ?? {} as Token\r\n            throw new JspyParserError(ast.name, getStartLine(token), getStartColumn(token), err.message || err)\r\n        }\r\n        return ast;\r\n    }\r\n\r\n    private instructionsToNodes(instructions: InstructionLine[], ast: AstBlock): void {\r\n\r\n        const getBody = (tokens: Token[], startTokenIndex: number): AstNode[] => {\r\n            const instructionLines = this.tokensToInstructionLines(tokens, getStartLine(tokens[startTokenIndex]));\r\n            const bodyAst = { name: ast.name, body: [] as AstNode[], funcs: [] as AstNode[] } as AstBlock;\r\n            this.instructionsToNodes(instructionLines, bodyAst);\r\n            return bodyAst.body;\r\n        }\r\n\r\n        const findIndexes = (tkns: Token[], operation: OperationTypes, result: number[]): boolean => {\r\n            result.splice(0, result.length);\r\n            findOperators(tkns, operation).forEach(r => result.push(r));\r\n            return !!result.length;\r\n        }\r\n\r\n        for (let i = 0; i < instructions.length; i++) {\r\n            const instruction = instructions[i];\r\n\r\n            // remove comments\r\n            let tt = 0;\r\n            while (tt < instruction.tokens.length) {\r\n                if (getTokenType(instruction.tokens[tt]) === TokenTypes.Comment) {\r\n                    instruction.tokens.splice(tt, 1);\r\n                } else {\r\n                    tt++;\r\n                }\r\n            }\r\n            if (!instruction.tokens.length) {\r\n                continue;\r\n            }\r\n\r\n            const firstToken = instruction.tokens[0];\r\n            const secondToken = instruction.tokens.length > 1 ? instruction.tokens[1] : null;\r\n            this._currentToken = firstToken;\r\n\r\n            const logicOpIndexes: number[] = [];\r\n            const comparisonOpIndexs: number[] = [];\r\n            const assignTokenIndexes: number[] = [];\r\n\r\n            if (getTokenType(firstToken) === TokenTypes.Comment) {\r\n                ast.body.push(new CommentNode(getTokenValue(firstToken) as string, getTokenLoc(firstToken)));\r\n            } else if (getTokenValue(firstToken) === 'def'\r\n                || (getTokenValue(firstToken) === \"async\" && getTokenValue(secondToken) === \"def\")) {\r\n\r\n                const isAsync = getTokenValue(firstToken) === \"async\";\r\n                const funcName = getTokenValue(instruction.tokens[isAsync ? 2 : 1]) as string;\r\n                const paramsTokens = instruction.tokens.slice(\r\n                    instruction.tokens.findIndex(tkns => getTokenValue(tkns) === '(') + 1,\r\n                    instruction.tokens.findIndex(tkns => getTokenValue(tkns) === ')')\r\n                );\r\n\r\n                const params = splitTokens(paramsTokens, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for def`)\r\n                }\r\n\r\n                const instructionLines = this.tokensToInstructionLines(instruction.tokens, getStartLine(instruction.tokens[endDefOfDef + 1]));\r\n                const funcAst = {\r\n                    name: funcName,\r\n                    body: [] as AstNode[],\r\n                    funcs: [] as AstNode[]\r\n                } as AstBlock;\r\n                this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n                ast.funcs.push(new FunctionDefNode(funcAst, params, isAsync, getTokenLoc(instruction.tokens[0])))\r\n\r\n            } else if (getTokenValue(firstToken) === 'if') {\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for if`)\r\n                }\r\n\r\n                const ifBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n                const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n\r\n                const conditionNode = (findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)) ?\r\n                    this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n                    :\r\n                    this.createExpressionNode(conditionTokens);\r\n\r\n                let elseBody: AstNode[] | undefined = undefined;\r\n                if (instructions.length > i + 1\r\n                    && getTokenValue(instructions[i + 1].tokens[0]) === 'else'\r\n                    && getTokenValue(instructions[i + 1].tokens[1]) === ':') {\r\n                    elseBody = getBody(instructions[i + 1].tokens, 2);\r\n                    i++;\r\n                }\r\n\r\n                ast.body.push(new IfNode(conditionNode, ifBody, elseBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'try') {\r\n\r\n                if (getTokenValue(instruction.tokens[1]) !== ':') {\r\n                    throw (`'try' statement should be followed by ':'`)\r\n                }\r\n\r\n                const tryBody = getBody(instruction.tokens, 2);\r\n                const excepts: ExceptBody[] = [];\r\n\r\n                let elseBody: AstNode[] | undefined = undefined;\r\n                let finallyBody: AstNode[] | undefined = undefined;\r\n\r\n                while (instructions.length > i + 1\r\n                    && (\r\n                        getTokenValue(instructions[i + 1].tokens[0]) === 'else'\r\n                        || getTokenValue(instructions[i + 1].tokens[0]) === 'except'\r\n                        || getTokenValue(instructions[i + 1].tokens[0]) === 'finally'\r\n                    )\r\n                ) {\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'else') {\r\n                        if (elseBody) {\r\n                            throw new Error(`Only one 'else' is allowed in a 'try'`)\r\n                        }\r\n\r\n                        elseBody = getBody(instructions[i + 1].tokens, 2);\r\n                    }\r\n\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'finally') {\r\n                        if (finallyBody) {\r\n                            throw new Error(`Only one 'else' is allowed in a 'try'`)\r\n                        }\r\n\r\n                        finallyBody = getBody(instructions[i + 1].tokens, 2);\r\n                    }\r\n\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'except') {\r\n\r\n                        const endIndex = findTokenValueIndex(instructions[i + 1].tokens, v => v === ':');\r\n                        const except = {} as ExceptBody;\r\n\r\n                        if (endIndex === 2) {\r\n                            except.error = { name: getTokenValue(instructions[i + 1].tokens[1]) } as NameAlias;\r\n                        } else if (endIndex === 3) {\r\n                            except.error = {\r\n                                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                                alias: getTokenValue(instructions[i + 1].tokens[2]),\r\n                            } as NameAlias;\r\n                        } else if (endIndex === 4) {\r\n                            except.error = {\r\n                                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                                alias: getTokenValue(instructions[i + 1].tokens[3]),\r\n                            } as NameAlias;\r\n                        } else if (endIndex !== 1) {\r\n                            throw new Error(`Incorrect 'except:' statement. Valid stats: (except: or except Error: or except Error as e:)`)\r\n                        }\r\n\r\n                        except.body = getBody(instructions[i + 1].tokens, endIndex + 1);\r\n\r\n                        excepts.push(except);\r\n                    }\r\n\r\n                    i++;\r\n                }\r\n\r\n                if (!excepts.length) {\r\n                    throw new Error('Except: is missing');\r\n                }\r\n\r\n                ast.body.push(new TryExceptNode(tryBody, excepts, elseBody, finallyBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'continue') {\r\n                ast.body.push(new ContinueNode());\r\n            } else if (getTokenValue(firstToken) === 'break') {\r\n                ast.body.push(new BreakNode());\r\n            } else if (getTokenValue(firstToken) === 'return') {\r\n                ast.body.push(new ReturnNode(\r\n                    instruction.tokens.length > 1 ? this.createExpressionNode(instruction.tokens.slice(1)) : undefined,\r\n                    getTokenLoc(firstToken))\r\n                );\r\n            } else if (getTokenValue(firstToken) === 'raise') {\r\n\r\n                if (instruction.tokens.length === 1) {\r\n                    throw new Error(`Incorrect 'raise' usage. Please specify error name and message `);\r\n                }\r\n                const errorName = getTokenValue(instruction.tokens[1]) as string;\r\n\r\n                const errorMessage = (\r\n                    instruction.tokens.length == 5\r\n                    && getTokenValue(instruction.tokens[2]) === \"(\"\r\n                    && getTokenValue(instruction.tokens[4]) === \")\"\r\n                ) ? getTokenValue(instruction.tokens[3]) as string\r\n                    : undefined;\r\n\r\n                ast.body.push(new RaiseNode(errorName, errorMessage, getTokenLoc(firstToken)));\r\n            } else if (getTokenValue(firstToken) === 'for') {\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for if`)\r\n                }\r\n\r\n                const itemVarName = getTokenValue(instruction.tokens[1]) as string;\r\n                const sourceArray = this.createExpressionNode(instruction.tokens.slice(3, endDefOfDef))\r\n                const forBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n                ast.body.push(new ForNode(sourceArray, itemVarName, forBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'while') {\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for [while]`)\r\n                }\r\n\r\n\r\n                const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n                const conditionNode = (findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)) ?\r\n                    this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n                    :\r\n                    this.createExpressionNode(conditionTokens);\r\n\r\n                const body = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n                ast.body.push(new WhileNode(conditionNode, body, getTokenLoc(firstToken)));\r\n\r\n            } else if (getTokenValue(firstToken) === 'import') {\r\n                let asIndex = findTokenValueIndex(instruction.tokens, v => v === 'as');\r\n                if (asIndex < 0) {\r\n                    asIndex = instruction.tokens.length;\r\n                }\r\n\r\n                const module = {\r\n                    name: instruction.tokens.slice(1, asIndex).map(t => getTokenValue(t)).join(''),\r\n                    alias: instruction.tokens.slice(asIndex + 1).map(t => getTokenValue(t)).join('') || undefined\r\n                } as NameAlias;\r\n\r\n                const body = {} as AstBlock; // empty for now\r\n                ast.body.push(new ImportNode(module, body, undefined, getTokenLoc(firstToken)))\r\n            } else if (getTokenValue(firstToken) === 'from') {\r\n                const importIndex = findTokenValueIndex(instruction.tokens, v => v === 'import');\r\n                if (importIndex < 0) {\r\n                    throw Error(`'import' must follow 'from'`);\r\n                }\r\n\r\n                const module = {\r\n                    name: instruction.tokens.slice(1, importIndex).map(t => getTokenValue(t)).join('')\r\n                } as NameAlias;\r\n\r\n                const parts = splitTokens(instruction.tokens.slice(importIndex + 1), ',')\r\n                    .map(t => {\r\n                        return {\r\n                            name: getTokenValue(t[0]),\r\n                            alias: (t.length === 3) ? getTokenValue(t[2]) : undefined\r\n                        } as NameAlias\r\n                    });\r\n\r\n                const body = {} as AstBlock; // empty for now\r\n\r\n                ast.body.push(new ImportNode(module, body, parts, getTokenLoc(firstToken)))\r\n            } else if (findIndexes(instruction.tokens, OperationTypes.Assignment, assignTokenIndexes)) {\r\n                const assignTokens = splitTokens(instruction.tokens, '=');\r\n                const target = this.createExpressionNode(assignTokens[0]);\r\n                const source = this.createExpressionNode(assignTokens[1]);\r\n                ast.body.push(new AssignNode(target, source, getTokenLoc(assignTokens[0][0])));\r\n            } else if (findIndexes(instruction.tokens, OperationTypes.Logical, logicOpIndexes)) {\r\n                ast.body.push(this.groupLogicalOperations(logicOpIndexes, instruction.tokens));\r\n            } else {\r\n                ast.body.push(this.createExpressionNode(instruction.tokens))\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    private sliceWithBrackets(a: Token[], begin: number, end: number): Token[] {\r\n        // if expression is in brackets, then we need clean brackets\r\n        if (getTokenValue(a[begin]) === '(' && getTokenType(a[begin]) !== TokenTypes.LiteralString) {\r\n            begin++;\r\n            end--;\r\n        }\r\n\r\n        return a.slice(begin, end);\r\n    }\r\n\r\n    private groupComparisonOperations(indexes: number[], tokens: Token[]): AstNode {\r\n        const start = 0;\r\n\r\n        let leftNode: AstNode | null = null;\r\n        for (let i = 0; i < indexes.length; i++) {\r\n            const opToken = getTokenValue(tokens[indexes[i]]) as ComparisonOperators;\r\n            leftNode = (leftNode) ? leftNode : this.createExpressionNode(this.sliceWithBrackets(tokens, start, indexes[i]))\r\n\r\n            const endInd = (i + 1 < indexes.length) ? indexes[i + 1] : tokens.length;\r\n            const rightNode = this.createExpressionNode(this.sliceWithBrackets(tokens, indexes[i] + 1, endInd))\r\n\r\n            leftNode = new BinOpNode(leftNode, opToken, rightNode, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        return leftNode as AstNode;\r\n    }\r\n\r\n    private groupLogicalOperations(logicOp: number[], tokens: Token[]): LogicalOpNode {\r\n        let start = 0;\r\n        const logicItems: LogicalNodeItem[] = [];\r\n        for (let i = 0; i < logicOp.length; i++) {\r\n            const opToken = tokens[logicOp[i]];\r\n            const logicalSlice = this.sliceWithBrackets(tokens, start, logicOp[i]);\r\n            logicItems.push({\r\n                node: this.createExpressionNode(logicalSlice),\r\n                op: getTokenValue(opToken) as LogicalOperators\r\n            });\r\n\r\n            start = logicOp[i] + 1;\r\n        }\r\n\r\n        logicItems.push({\r\n            node: this.createExpressionNode(this.sliceWithBrackets(tokens, start, tokens.length))\r\n        } as LogicalNodeItem);\r\n\r\n        const lop = new LogicalOpNode(logicItems, getTokenLoc(tokens[0]));\r\n        return lop;\r\n    }\r\n\r\n    private tokensToInstructionLines(tokens: Token[], startLine: number): InstructionLine[] {\r\n        const lines: InstructionLine[] = [];\r\n\r\n        let column = 0;\r\n        let currentLine = startLine;\r\n        let line = new InstructionLine();\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            const token = tokens[i];\r\n            const sLine = getStartLine(token);\r\n            const sColumn = getStartColumn(token);\r\n            const value = getTokenValue(token);\r\n            this._currentToken = token;\r\n\r\n            if (sLine >= startLine) {\r\n\r\n                if (currentLine !== sLine) {\r\n                    currentLine = sLine;\r\n                }\r\n\r\n                if (column === sColumn && !\")}]\".includes(value as string)) {\r\n                    currentLine = sLine;\r\n                    lines.push(line);\r\n                    line = new InstructionLine();\r\n                }\r\n\r\n                line.tokens.push(token);\r\n\r\n                // first line defines a minimum indent\r\n                if (column === 0) {\r\n                    column = sColumn;\r\n                }\r\n\r\n                // stop looping through if line has less indent\r\n                // it means the corrent block finished\r\n                if (sColumn < column) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (line.tokens.length) {\r\n            lines.push(line)\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    private createExpressionNode(tokens: Token[], prevNode: AstNode | null = null): AstNode {\r\n        if (tokens.length === 0) {\r\n            throw new Error(`Tokens length can't empty.`)\r\n        }\r\n        const lastToken = tokens[tokens.length - 1];\r\n        if (getTokenValue(lastToken) === ';' && getTokenType(lastToken) !== TokenTypes.LiteralString) {\r\n            throw new Error(`Unexpected symbol ';' in the end`)\r\n        }\r\n\r\n        this._currentToken = tokens[0];\r\n\r\n        // const or variable\r\n        if (tokens.length === 1\r\n            || (tokens.length === 2 && getTokenValue(tokens[1]) === '?')\r\n        ) {\r\n            const firstToken = tokens[0];\r\n            const tokenType = getTokenType(firstToken);\r\n\r\n            if (isTokenTypeLiteral(tokenType)) {\r\n                return new ConstNode(firstToken);\r\n            } else if (tokenType === TokenTypes.Identifier) {\r\n                return new GetSingleVarNode(firstToken, tokens.length === 2 && getTokenValue(tokens[1]) === '?' || undefined);\r\n            }\r\n\r\n            throw Error(`Unhandled single token: '${JSON.stringify(firstToken)}'`);\r\n        }\r\n\r\n        // arrow function\r\n        const arrowFuncParts = splitTokens(tokens, '=>');\r\n        if (arrowFuncParts.length > 1) {\r\n            const pArray = getTokenValue(arrowFuncParts[0][0]) === '(' ?\r\n                arrowFuncParts[0].splice(1, arrowFuncParts[0].length - 2)\r\n                : arrowFuncParts[0];\r\n            const params = splitTokens(pArray, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n            const instructionLines = this.tokensToInstructionLines(arrowFuncParts[1], 0);\r\n            const funcAst = {\r\n                name: this._moduleName,\r\n                body: [] as AstNode[],\r\n                funcs: [] as AstNode[]\r\n            } as AstBlock;\r\n            this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n            return new ArrowFuncDefNode(funcAst, params, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // comparison operations\r\n        const comparissonIndexes = findOperators(tokens, OperationTypes.Comparison);\r\n        if (comparissonIndexes.length) {\r\n            return this.groupComparisonOperations(comparissonIndexes, tokens);\r\n        }\r\n\r\n        // create arithmetic expression\r\n        const ops = findOperators(tokens);\r\n        if (ops.length) {\r\n\r\n            let prevNode: AstNode | null = null;\r\n            for (let i = 0; i < ops.length; i++) {\r\n                const opIndex = ops[i];\r\n                const op = getTokenValue(tokens[opIndex]) as Operators;\r\n\r\n                let nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n                let nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n                if (nextOpIndex !== null && (nextOp === '*' || nextOp === '/')) {\r\n                    let rightNode: AstNode | null = null;\r\n                    // iterate through all continuous '*', '/' operations\r\n                    do {\r\n                        const nextOpIndex2 = i + 2 < ops.length ? ops[i + 2] : null;\r\n\r\n                        const leftSlice2 = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex);\r\n                        const rightSlice2 = this.sliceWithBrackets(tokens, nextOpIndex + 1, nextOpIndex2 || tokens.length);\r\n\r\n                        const left2 = this.createExpressionNode(leftSlice2);\r\n                        const right2 = this.createExpressionNode(rightSlice2);\r\n                        rightNode = new BinOpNode(left2, nextOp, right2, getTokenLoc(tokens[opIndex + 1]));\r\n\r\n                        i++;\r\n                        nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n                        nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n                    }\r\n                    while (nextOpIndex !== null && (nextOp === '*' || nextOp === '/'))\r\n\r\n                    // add up result\r\n                    if (prevNode === null) {\r\n                        const leftSlice = this.sliceWithBrackets(tokens, 0, opIndex);\r\n                        prevNode = this.createExpressionNode(leftSlice);\r\n                    }\r\n                    prevNode = new BinOpNode(prevNode, op as ExpressionOperators, rightNode, getTokenLoc(tokens[0]))\r\n\r\n                } else {\r\n                    const leftSlice = prevNode ? [] : this.sliceWithBrackets(tokens, 0, opIndex);\r\n                    const rightSlice = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex || tokens.length);\r\n                    const left: AstNode = prevNode || this.createExpressionNode(leftSlice, prevNode);\r\n                    const right = this.createExpressionNode(rightSlice);\r\n                    prevNode = new BinOpNode(left, op as ExpressionOperators, right, getTokenLoc(tokens[0]));\r\n                }\r\n            }\r\n\r\n            if (prevNode === null) {\r\n                throw Error(`Can't create node ...`)\r\n            }\r\n\r\n            return prevNode;\r\n        }\r\n\r\n        // create DotObjectAccessNode\r\n        const subObjects = splitTokens(tokens, '.');\r\n        if (subObjects.length > 1) {\r\n            return new DotObjectAccessNode(subObjects.map(tkns => this.createExpressionNode(tkns)), getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // create function call node\r\n        if (tokens.length > 2 && getTokenValue(tokens[1]) === '(') {\r\n\r\n            const isNullCoelsing = getTokenValue(tokens[tokens.length - 1]) === '?';\r\n            if (isNullCoelsing) {\r\n                // remove '?'\r\n                tokens.pop();\r\n            }\r\n            const name = getTokenValue(tokens[0]) as string;\r\n            const paramsTokensSlice = tokens.slice(2, tokens.length - 1);\r\n            const paramsTokens = splitTokens(paramsTokensSlice, ',')\r\n            const paramsNodes = paramsTokens.map(tkns => this.createExpressionNode(tkns));\r\n            const node = new FunctionCallNode(name, paramsNodes, getTokenLoc(tokens[0]));\r\n            node.nullCoelsing = isNullCoelsing || undefined;\r\n            return node;\r\n        }\r\n\r\n        // create Object Node\r\n        if (getTokenValue(tokens[0]) === '{' && getTokenValue(tokens[tokens.length - 1]) === '}') {\r\n            const keyValueTokens = splitTokens(tokens.splice(1, tokens.length - 2), ',');\r\n            const props = [] as ObjectPropertyInfo[];\r\n            for (let i = 0; i < keyValueTokens.length; i++) {\r\n                const keyValue = splitTokens(keyValueTokens[i], ':');\r\n                if (keyValue.length === 1) {\r\n                    const pInfo = {\r\n                        name: new ConstNode(keyValue[0][0]),\r\n                        value: this.createExpressionNode(keyValue[0])\r\n                    } as ObjectPropertyInfo;\r\n\r\n                    props.push(pInfo);\r\n                } else if (keyValue.length === 2) {\r\n\r\n                    let name: AstNode | null = null;\r\n                    const namePart = keyValue[0];\r\n\r\n                    if (namePart.length === 1) {\r\n                        name = new ConstNode(namePart[0]);\r\n                    } else if (getTokenValue(namePart[0]) === '['\r\n                        && getTokenValue(namePart[namePart.length - 1]) === ']') {\r\n                        name = this.createExpressionNode(namePart.slice(1, namePart.length - 1))\r\n                    } else {\r\n                        throw new Error(`Incorrect JSON. Can't resolve Key field. That should either constant or expression in []`)\r\n                    }\r\n\r\n                    const pInfo = {\r\n                        name,\r\n                        value: this.createExpressionNode(keyValue[1])\r\n                    } as ObjectPropertyInfo;\r\n\r\n                    props.push(pInfo);\r\n                } else {\r\n                    throw Error('Incorrect JSON')\r\n                }\r\n            }\r\n\r\n            return new CreateObjectNode(props, getTokenLoc(tokens[0]))\r\n        }\r\n\r\n        // create Array Node\r\n        if (getTokenValue(tokens[0]) === '[' && getTokenValue(tokens[tokens.length - 1]) === ']') {\r\n            const items = splitTokens(tokens.splice(1, tokens.length - 2), ',')\r\n                .map(tkns => this.createExpressionNode(tkns));\r\n\r\n            return new CreateArrayNode(items, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // bracket access object node\r\n        if (tokens.length > 2 && getTokenValue(tokens[1]) === '[') {\r\n            const name = getTokenValue(tokens[0]) as string;\r\n            const paramsTokensSlice = tokens.slice(2, tokens.length - 1);\r\n            const paramsNodes = this.createExpressionNode(paramsTokensSlice);\r\n            return new BracketObjectAccessNode(name, paramsNodes, false, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        throw Error(`Undefined node '${getTokenValue(tokens[0])}'.`);\r\n    }\r\n}\r\n","import { getTokenType, getTokenValue, Token, TokenTypes } from '../common';\r\n\r\nconst SeparatorsMap: Record<string, string[]> = {\r\n    '\\n': ['\\n'],\r\n    '=': ['=', '==', '=>'],\r\n\r\n    '+': ['+', '++', '+='],\r\n    '-': ['-', '--', '-='],\r\n    '*': ['*', '**', '*='],\r\n    '/': ['/', '//', '/='],\r\n\r\n    '.': ['.'],\r\n    '?': ['?'],\r\n    '!': ['!='],\r\n    ':': [':'],\r\n    ',': [','],\r\n\r\n    '>': ['>', '>='],\r\n    '<': ['<', '<=', '<>'],\r\n\r\n    '(': ['('],\r\n    ')': [')'],\r\n    '{': ['{'],\r\n    '}': ['}'],\r\n    '[': ['['],\r\n    ']': [']'],\r\n};\r\n\r\nconst Keywords: string[] = [\"async\", \"def\", \"for\", \"while\", \"if\", \"return\", \"in\"];\r\n\r\nexport class Tokenizer {\r\n    private _startLine = 1;\r\n    private _startColumn = 1;\r\n    private _currentLine = 1;\r\n    private _currentColumn = 1;\r\n    private _tokenText = '';\r\n    private _cursor = 0;\r\n    private _script = \"\";\r\n\r\n    private get tokenText(): string {\r\n        return this._tokenText;\r\n    }\r\n    private set tokenText(value: string) {\r\n        if (!this._tokenText && value) {\r\n            this._startLine = this._currentLine;\r\n            this._startColumn = this._currentColumn;\r\n        }\r\n        this._tokenText = value;\r\n    }\r\n\r\n    /**\r\n     * Splits script code into a tokens\r\n     * @param script A jsPython text\r\n     */\r\n    tokenize(script: string): Token[] {\r\n        if (!script || !script.length) { return []; }\r\n\r\n        script = script\r\n            .replace(new RegExp('\\t', 'g'), '  ') // replace all tabs with 2 spaces\r\n            .replace(new RegExp('\\r', 'g'), ''); // remove all \\r symbols\r\n        this._script = script;\r\n\r\n        this._cursor = 0;\r\n        this._startLine = 1;\r\n        this._startColumn = 1;\r\n        this._currentLine = 1;\r\n        this._currentColumn = 1;\r\n\r\n        const tokens: Token[] = [];\r\n\r\n        let first = true;\r\n        // handle initial spaces\r\n        while (script[this._cursor] === '\\n') {\r\n            this.incrementCursor();\r\n            if (first) {\r\n                this._currentLine++;\r\n                first = false;\r\n            }\r\n            this._currentColumn = 1;\r\n        }\r\n\r\n        do {\r\n            const symbol = script[this._cursor];\r\n\r\n            if (symbol == ' ' && this.tokenText.length !== 0) {\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n                continue;\r\n            } else if ((SeparatorsMap[symbol] !== undefined) && !this.isPartOfNumber(symbol, tokens)) {\r\n                // handle numbers with floating point e.g. 3.14\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n                this.tokenText = symbol;\r\n\r\n                const sepsMap = SeparatorsMap[symbol];\r\n\r\n                if (sepsMap.length >= 1) {\r\n                    // process longer operators\r\n                    while (sepsMap.includes(this.tokenText + script[this._cursor + 1])) {\r\n                        this.tokenText += script[this.incrementCursor()];\r\n                    }\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, false, TokenTypes.Operator);\r\n\r\n            } else if (symbol === '#') {\r\n\r\n                let first = true;\r\n                while (script[this.incrementCursor()] !== '\\n') {\r\n                    this.tokenText += script[this._cursor];\r\n\r\n                    // correct start column\r\n                    if (first) {\r\n                        first = false;\r\n                        this._startColumn = this._startColumn - 1\r\n                    }\r\n\r\n                    if (this._cursor + 1 >= script.length) break;\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.Comment);\r\n\r\n            } else if (symbol === '\"' || symbol === \"'\") {\r\n                // remember either it is single or double quote\r\n                const q = symbol;\r\n                // we are not expecting token to be added here.\r\n                // it should pass a failt to parser\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n\r\n                // handle \"\"\" comment \"\"\"\"\r\n                if (script[this._cursor + 1] === q && script[this._cursor + 2] === q) {\r\n                    const cLine = this._currentLine;\r\n                    const cColumn = this._currentColumn;\r\n                    this.incrementCursor(2);\r\n                    const passCond = true;\r\n                    while (passCond) {\r\n                        this.tokenText += script[this.incrementCursor()];\r\n                        if (this._cursor + 3 >= script.length\r\n                            || (script[this._cursor + 1] === q && script[this._cursor + 2] === q && script[this._cursor + 3] === q)) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    // a special case when multiline string\r\n                    this._startLine = cLine;\r\n                    this._startColumn = cColumn;\r\n\r\n                    this.incrementCursor(3);\r\n                } else {\r\n                    while (script[this.incrementCursor()] !== q) {\r\n                        this.tokenText += script[this._cursor];\r\n                        if (this._cursor + 1 >= script.length) break;\r\n                    }\r\n\r\n                    //start column needs to take into account a begining quote, not just a string\r\n                    this._startColumn--;\r\n                }\r\n\r\n                // a special case when empty string\r\n                if (this.tokenText.length === 0) {\r\n                    this._startLine = this._currentLine;\r\n                    this._startColumn = this._currentColumn;\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.LiteralString);\r\n            } else if (symbol != ' ') {\r\n                this.tokenText += symbol;\r\n            }\r\n        }\r\n        while (this.incrementCursor() < script.length)\r\n\r\n        this.processToken(this.tokenText, tokens);\r\n\r\n        return tokens;\r\n    }\r\n\r\n    private incrementCursor(count = 1): number {\r\n        for (let i = 0; i < count; i++) {\r\n            this._cursor = this._cursor + 1;\r\n            if (this._script[this._cursor] === '\\n') {\r\n                this._currentLine++;\r\n                this._currentColumn = 0;\r\n            } else {\r\n                this._currentColumn++;\r\n            }\r\n        }\r\n\r\n        return this._cursor;\r\n    }\r\n\r\n    private recognizeToken(tokenText: string, type: TokenTypes | null = null): { value: string | number | boolean | null, type: TokenTypes } {\r\n\r\n        let value: string | number | boolean | null = tokenText;\r\n\r\n        if (type === null) {\r\n            if (tokenText === 'null') {\r\n                type = TokenTypes.LiteralNull;\r\n                value = null;\r\n            } else if (tokenText === 'true' || tokenText === 'false') {\r\n                type = TokenTypes.LiteralBool;\r\n                value = tokenText === 'true';\r\n            } else if (this.parseNumberOrNull(tokenText) !== null) {\r\n                type = TokenTypes.LiteralNumber;\r\n                value = this.parseNumberOrNull(tokenText);\r\n            } else if (Keywords.indexOf(tokenText) >= 0) {\r\n                type = TokenTypes.Keyword;\r\n            } else {\r\n                type = TokenTypes.Identifier\r\n            }\r\n        }\r\n\r\n        return {\r\n            value: value,\r\n            type: type\r\n        }\r\n\r\n    }\r\n\r\n    private processToken(strToken: string, tokens: Token[], allowEmptyString = false, type: TokenTypes | null = null): string {\r\n        // ignore empty tokens\r\n        if (!strToken.length && !allowEmptyString || strToken === '\\n') return \"\";\r\n\r\n        const token = this.recognizeToken(strToken, type);\r\n        tokens.push([token.value, Uint16Array.of(token.type as number,\r\n            this._startLine, this._startColumn,\r\n            this._currentLine, this._currentColumn)] as Token)\r\n        return \"\";\r\n    }\r\n\r\n    private parseNumberOrNull(value: string | number): number | null {\r\n        if (typeof value === 'number') {\r\n            return value;\r\n        }\r\n\r\n        if (!value || typeof value !== 'string') {\r\n            return null;\r\n        }\r\n\r\n        value = value.trim();\r\n\r\n        // Just to make sure string contains digits only and '.', ','. Otherwise, parseFloat can incorrectly parse into number\r\n        for (let i = value.length - 1; i >= 0; i--) {\r\n            const d = value.charCodeAt(i);\r\n            if (d < 48 || d > 57) {\r\n                // '.' - 46 ',' - 44 '-' - 45(but only first char)\r\n                if (d !== 46 && d !== 44 && (d !== 45 || i !== 0))\r\n                    return null;\r\n            }\r\n        }\r\n\r\n        const res = parseFloat(value);\r\n        return !isNaN(res) ? res : null;\r\n    }\r\n\r\n    private isPartOfNumber(symbol: string, currentTokens: Token[]): boolean {\r\n        if (symbol === '-' && !this.tokenText.length) {\r\n            // '-' needs to be handled e.g. -3; 2 + -2 etc\r\n            const prevToken = (currentTokens.length !== 0) ? currentTokens[currentTokens.length - 1] : null;\r\n            return prevToken === null || (getTokenType(prevToken) === TokenTypes.Operator && getTokenValue(prevToken) !== ')');\r\n        } else if (symbol === '.' && this.parseNumberOrNull(this.tokenText) !== null) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}","import { AstBlock, ImportNode, Token } from './common';\r\nimport { getImportType } from './common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { EvaluatorAsync } from './evaluator/evaluatorAsync';\r\nimport { BlockContext, Scope } from './evaluator/scope';\r\nimport { INITIAL_SCOPE, PackageToImport } from './initialScope';\r\nimport { Parser } from './parser';\r\nimport { Tokenizer } from './tokenizer';\r\n\r\nexport type PackageLoader = (packageName: string) => any;\r\nexport type ModuleLoader = (filePath: string) => Promise<string>;\r\n\r\nexport function jsPython(): Interpreter {\r\n    return Interpreter.create();\r\n}\r\n\r\nexport class Interpreter {\r\n    private readonly initialScope: Record<string, unknown> = { ...INITIAL_SCOPE };\r\n\r\n    private _lastExecutionContext: Record<string, unknown> | null = null;\r\n\r\n    private packageLoader?: PackageLoader;\r\n    private moduleLoader?: ModuleLoader;\r\n\r\n    constructor() { }\r\n\r\n    static create(): Interpreter {\r\n        return new Interpreter();\r\n    }\r\n\r\n    get initialExecutionContext(): Record<string, unknown> {\r\n        return this.initialScope;\r\n    }\r\n\r\n    get lastExecutionContext(): Record<string, unknown> | null {\r\n        return this._lastExecutionContext;\r\n    }\r\n\r\n    cleanUp(): void {\r\n        this._lastExecutionContext = null;\r\n    }\r\n\r\n    jsPythonInfo(): string {\r\n        return INITIAL_SCOPE.jsPython();\r\n    }\r\n\r\n    tokenize(script: string): Token[] {\r\n        const tokenizer = new Tokenizer();\r\n        return tokenizer.tokenize(script);\r\n    }\r\n\r\n    parse(script: string, moduleName: string = 'main.jspy'): AstBlock {\r\n        const tokenizer = new Tokenizer();\r\n        const parser = new Parser();\r\n        const jspyAst = parser.parse(tokenizer.tokenize(script), moduleName);\r\n        return jspyAst;\r\n    }\r\n\r\n    eval(codeOrAst: string | AstBlock, scope: Record<string, unknown> = {}\r\n        , entryFunctionName: string = '', moduleName: string = 'main.jspy'): unknown {\r\n        const ast = (typeof codeOrAst === 'string') ? this.parse(codeOrAst as string, moduleName) : codeOrAst as AstBlock;\r\n\r\n        const blockContext = {\r\n            moduleName: moduleName,\r\n            blockScope: new Scope(scope)\r\n        } as BlockContext;\r\n\r\n        blockContext.blockScope.set('printExecutionContext', () => console.log(blockContext.blockScope.getScope()));\r\n        blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n        this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n        const result = new Evaluator().evalBlock(ast, blockContext);\r\n        if (!entryFunctionName || !entryFunctionName.length) {\r\n            return result;\r\n        } else {\r\n            const func = blockContext.blockScope.get(entryFunctionName);\r\n            if (typeof func !== 'function') {\r\n                throw Error(`Function ${entryFunctionName} does not exists or not a function`)\r\n            }\r\n            return func();\r\n        }\r\n    }\r\n\r\n    async evalAsync(codeOrAst: string | AstBlock, scope: Record<string, unknown> = {}\r\n        , entryFunctionName: string = '', moduleName: string = 'main.jspy'): Promise<unknown> {\r\n        const ast = (typeof codeOrAst === 'string') ? this.parse(codeOrAst as string, moduleName) : codeOrAst as AstBlock;\r\n        const evaluator = new EvaluatorAsync();\r\n        const blockContext = {\r\n            moduleName: moduleName,\r\n            blockScope: new Scope(scope)\r\n        } as BlockContext;\r\n\r\n        blockContext.blockScope.set('printExecutionContext', () => console.log(blockContext.blockScope.getScope()));\r\n        blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n        this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n        const result = await evaluator\r\n            .registerJsonFileLoader(async (modulePath: string) =>\r\n                await (this.moduleLoader ? this.moduleLoader(modulePath)\r\n                    : Promise.reject('ModuleLoader is not registered')\r\n                )\r\n            )\r\n            .registerModuleParser(async (modulePath) => await this.moduleParser(modulePath))\r\n            .registerBlockContextFactory((moduleName, ast: AstBlock) => {\r\n                // enrich context\r\n                const newContext = this.assignImportContext(ast, scope);\r\n                const moduleContext = { moduleName, blockScope: new Scope(newContext) }\r\n                moduleContext.blockScope.set('printExecutionContext', () => console.log(moduleContext.blockScope.getScope()));\r\n                moduleContext.blockScope.set('getExecutionContext', () => moduleContext.blockScope.getScope());\r\n                return moduleContext;\r\n            })\r\n            .evalBlockAsync(ast, blockContext);\r\n\r\n        if (!entryFunctionName || !entryFunctionName.length) {\r\n            return result;\r\n        } else {\r\n            const func = blockContext.blockScope.get(entryFunctionName);\r\n            if (typeof func !== 'function') {\r\n                throw Error(`Function ${entryFunctionName} does not exists or not a function`)\r\n            }\r\n            return await func();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compatibility method (with v1). !\r\n     */\r\n    async evaluate(script: string, context: object = {}, entryFunctionName: string = ''\r\n        , moduleName: string = 'main.jspy'): Promise<any> {\r\n        if (!script || !script.length) { return null; }\r\n        const ast = this.parse(script, moduleName);\r\n\r\n        context = (context && typeof context === 'object') ? context : {};\r\n        context = this.assignImportContext(ast, context);\r\n\r\n        const globalScope = {\r\n            ...this.initialScope,\r\n            ...context\r\n        } as Record<string, unknown>;\r\n\r\n        return await this.evalAsync(ast, globalScope, entryFunctionName, moduleName);\r\n    }\r\n\r\n    registerPackagesLoader(loader: PackageLoader): Interpreter {\r\n        if (typeof loader === 'function') {\r\n            this.packageLoader = loader;\r\n        } else {\r\n            throw Error('PackagesLoader');\r\n        }\r\n        return this;\r\n    }\r\n\r\n    registerModuleLoader(loader: ModuleLoader): Interpreter {\r\n        if (typeof loader === 'function') {\r\n            this.moduleLoader = loader;\r\n        } else {\r\n            throw Error('ModuleLoader should be a function');\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    addFunction(funcName: string, fn: (...args: any[]) => void | any | Promise<any>): Interpreter {\r\n        this.initialScope[funcName] = fn;\r\n        return this;\r\n    }\r\n\r\n    assignGlobalContext(obj: object): Interpreter {\r\n        Object.assign(this.initialScope, obj);\r\n        return this;\r\n    }\r\n\r\n    hasFunction(scripts: string = '', funcName: string): boolean {\r\n        return scripts.indexOf(`def ${funcName}`) > -1;\r\n    }\r\n\r\n    private assignImportContext(ast: AstBlock, context: object): Record<string, unknown> {\r\n\r\n        const nodeToPackage = (im: ImportNode): PackageToImport => {\r\n            return {\r\n                name: im.module.name,\r\n                as: im.module.alias,\r\n                properties: im.parts?.map(p => ({ name: p.name, as: p.alias }))\r\n            } as PackageToImport\r\n        }\r\n\r\n        const importNodes = ast.body.filter(n => n.type === 'import') as ImportNode[];\r\n\r\n        const jsImport = importNodes\r\n            .filter(im => getImportType(im.module.name) === 'jsPackage')\r\n            .map(im => nodeToPackage(im));\r\n\r\n        if (jsImport.length && this.packageLoader) {\r\n            const libraries = this.packageResolver(jsImport);\r\n            context = { ...context, ...libraries };\r\n        }\r\n\r\n        return context as Record<string, unknown>;\r\n    }\r\n\r\n    private async moduleParser(modulePath: string): Promise<AstBlock> {\r\n        if (!this.moduleLoader) {\r\n            throw new Error('Module Loader is not registered')\r\n        }\r\n\r\n        const content = await this.moduleLoader(modulePath);\r\n        return this.parse(content, modulePath);\r\n    }\r\n\r\n    private packageResolver(packages: PackageToImport[]): object {\r\n        if (!this.packageLoader) {\r\n            throw Error('Package loader not provided.');\r\n        }\r\n        const libraries: any = {};\r\n        packages.forEach(({ name, as, properties }: PackageToImport) => {\r\n            const lib = this.packageLoader && this.packageLoader(name);\r\n            if (properties?.length) {\r\n                properties.forEach((prop) => {\r\n                    libraries[prop.as || prop.name] = lib[prop.name];\r\n                })\r\n            } else if (as) {\r\n                libraries[as] = lib;\r\n            } else {\r\n                libraries[name] = lib;\r\n            }\r\n            if (as) {\r\n                libraries[as] = lib;\r\n            }\r\n        });\r\n        return libraries;\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}