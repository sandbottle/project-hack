{"version":3,"file":"jspython-interpreter.js","sources":["../src/common/utils.ts","../src/common/operators.ts","../src/common/token-types.ts","../src/common/ast-types.ts","../src/evaluator/scope.ts","../src/evaluator/evaluator.ts","../src/evaluator/evaluatorAsync.ts","../src/initialScope.ts","../src/parser/parser.ts","../src/tokenizer/tokenizer.ts","../src/interpreter.ts"],"sourcesContent":["import { Token } from \"./token-types\";\r\n\r\nexport function parseDatetimeOrNull(value: string | Date): Date | null {\r\n    if (!value) { return null; }\r\n    if (value instanceof Date && !isNaN(value.valueOf())) { return value; }\r\n    // only string values can be converted to Date\r\n    if (typeof value !== 'string') { return null; }\r\n\r\n    const strValue = String(value);\r\n    if (!strValue.length) { return null; }\r\n\r\n    const parseMonth = (mm: string): number => {\r\n        if (!mm || !mm.length) {\r\n            return NaN;\r\n        }\r\n\r\n        const m = parseInt(mm, 10);\r\n        if (!isNaN(m)) {\r\n            return m - 1;\r\n        }\r\n\r\n        // make sure english months are coming through\r\n        if (mm.startsWith('jan')) { return 0; }\r\n        if (mm.startsWith('feb')) { return 1; }\r\n        if (mm.startsWith('mar')) { return 2; }\r\n        if (mm.startsWith('apr')) { return 3; }\r\n        if (mm.startsWith('may')) { return 4; }\r\n        if (mm.startsWith('jun')) { return 5; }\r\n        if (mm.startsWith('jul')) { return 6; }\r\n        if (mm.startsWith('aug')) { return 7; }\r\n        if (mm.startsWith('sep')) { return 8; }\r\n        if (mm.startsWith('oct')) { return 9; }\r\n        if (mm.startsWith('nov')) { return 10; }\r\n        if (mm.startsWith('dec')) { return 11; }\r\n\r\n        return NaN;\r\n    };\r\n\r\n    const correctYear = (yy: number) => {\r\n        if (yy < 100) {\r\n            return yy < 68 ? yy + 2000 : yy + 1900;\r\n        } else {\r\n            return yy;\r\n        }\r\n    };\r\n\r\n    const validDateOrNull =\r\n        (yyyy: number, month: number, day: number, hours: number, mins: number, ss: number): Date | null => {\r\n            if (month > 11 || day > 31 || hours >= 60 || mins >= 60 || ss >= 60) { return null; }\r\n\r\n            const dd = new Date(yyyy, month, day, hours, mins, ss, 0);\r\n            return !isNaN(dd.valueOf()) ? dd : null;\r\n        };\r\n\r\n    const strTokens = strValue.replace('T', ' ').toLowerCase().split(/[: /-]/);\r\n    const dt = strTokens.map(parseFloat);\r\n\r\n    // try ISO first\r\n    let d = validDateOrNull(dt[0], dt[1] - 1, dt[2], dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    // then UK\r\n    d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[1]), dt[0], dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    // then US\r\n    d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[0]), correctYear(dt[1]), dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    return null;\r\n}\r\n\r\nexport function getImportType(name: string): 'jspyModule' | 'jsPackage' | 'json' {\r\n\r\n    if (name.startsWith('/') || name.startsWith('./')) {\r\n        return (name.endsWith('.json')) ? 'json' : 'jspyModule';\r\n    }\r\n\r\n    return 'jsPackage';\r\n}\r\n\r\nfunction jspyErrorMessage(error: string, module: string, line: number, column: number, message: string): string {\r\n    return `${error}: ${module}(${line},${column}): ${message}`;\r\n}\r\n\r\nexport class JspyTokenizerError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyTokenizerError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyTokenizerError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyParserError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyParserError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyParserError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyEvalError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyEvalError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyEvalError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyError extends Error {\r\n\r\n    constructor(public module: string, public line: number, public column: number, public name: string, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyError\", module || 'name.jspy', line, column, message);\r\n        Object.setPrototypeOf(this, JspyError.prototype);\r\n    }\r\n}\r\n","export enum OperationTypes {\r\n    Arithmetic, Assignment, Comparison, Logical, Membership\r\n};\r\n\r\nexport type AssignmentOperators = \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"++\" | \"--\";\r\nexport type ArithmeticOperators = \"+\" | \"-\" | \"*\" | \"/\" | \"%\" | \"**\" | \"//\";\r\nexport type ComparisonOperators = \">\" | \">=\" | \"==\" | \"!=\" | \"<>\" | \"<\" | \"<=\";\r\nexport type LogicalOperators = \"and\" | \"or\"; // | \"not\" | \"not in\";\r\nexport type MembershipOperators = \"in\";\r\n\r\nexport type Operators = AssignmentOperators | ArithmeticOperators | ComparisonOperators | LogicalOperators | MembershipOperators;\r\n\r\nexport const OperatorsMap: Record<Operators, OperationTypes> = {\r\n    \"+\": OperationTypes.Arithmetic,\r\n    \"-\": OperationTypes.Arithmetic,\r\n    \"*\": OperationTypes.Arithmetic,\r\n    \"/\": OperationTypes.Arithmetic,\r\n    \"%\": OperationTypes.Arithmetic,\r\n    \"**\": OperationTypes.Arithmetic,\r\n    \"//\": OperationTypes.Arithmetic,\r\n\r\n    \">\": OperationTypes.Comparison,\r\n    \">=\": OperationTypes.Comparison,\r\n    \"==\": OperationTypes.Comparison,\r\n    \"!=\": OperationTypes.Comparison,\r\n    \"<>\": OperationTypes.Comparison,\r\n    \"<\": OperationTypes.Comparison,\r\n    \"<=\": OperationTypes.Comparison,\r\n\r\n    \"and\": OperationTypes.Logical,\r\n    \"or\": OperationTypes.Logical,\r\n    // \"not\": OperationTypes.Logical,\r\n    // \"not in\": OperationTypes.Logical,\r\n\r\n    \"in\": OperationTypes.Membership,\r\n\r\n    \"=\": OperationTypes.Assignment,\r\n    \"+=\": OperationTypes.Assignment,\r\n    \"-=\": OperationTypes.Assignment,\r\n    \"*=\": OperationTypes.Assignment,\r\n    \"/=\": OperationTypes.Assignment,\r\n    \"++\": OperationTypes.Assignment,\r\n    \"--\": OperationTypes.Assignment,\r\n};\r\n\r\nexport type Primitive = string | number | boolean | null;\r\n\r\nexport type ExpressionOperators = ArithmeticOperators | ComparisonOperators | LogicalOperators | MembershipOperators;\r\ntype ExpressionOperation = (l: Primitive, r: Primitive) => Primitive;\r\n\r\nexport const OperationFuncs: Record<ExpressionOperators, ExpressionOperation> = {\r\n    \"+\": (l, r) => arithmeticOperation(l, r, \"+\"),\r\n    \"-\": (l, r) => arithmeticOperation(l, r, \"-\"),\r\n    \"/\": (l, r) => arithmeticOperation(l, r, \"/\"),\r\n    \"*\": (l, r) => arithmeticOperation(l, r, \"*\"),\r\n    \"%\": (l, r) => arithmeticOperation(l, r, \"%\"),\r\n    \"**\": (l, r) => arithmeticOperation(l, r, \"**\"),\r\n    \"//\": (l, r) => arithmeticOperation(l, r, \"//\"),\r\n\r\n    \">\": (l, r) => comparissonOperation(l, r, \">\"),\r\n    \">=\": (l, r) => comparissonOperation(l, r, \">=\"),\r\n    \"<\": (l, r) => comparissonOperation(l, r, \"<\"),\r\n    \"<=\": (l, r) => comparissonOperation(l, r, \"<=\"),\r\n    \"==\": (l, r) => comparissonOperation(l, r, \"==\"),\r\n    \"!=\": (l, r) => comparissonOperation(l, r, \"!=\"),\r\n    \"<>\": (l, r) => comparissonOperation(l, r, \"<>\"),\r\n\r\n    \"and\": (l, r) => logicalOperation(l, r, \"and\"),\r\n    \"or\": (l, r) => logicalOperation(l, r, \"or\"),\r\n    // \"not\": (l, r) => logicalOperation(l, r, \"not\"),\r\n    // \"not in\": (l, r) => logicalOperation(l, r, \"not in\"),\r\n\r\n    \"in\": (l, r) => membershipOperation(l, r, \"in\")\r\n}\r\n\r\nfunction membershipOperation(l: Primitive, r: Primitive, op: MembershipOperators): Primitive {\r\n    if(typeof l === 'string'){\r\n        return (l as string).includes(String(r));\r\n    }\r\n\r\n    if(Array.isArray(l)){\r\n        return (l as any[]).includes(r);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction logicalOperation(l: Primitive, r: Primitive, op: LogicalOperators): Primitive {\r\n    switch (op) {\r\n        case 'and':\r\n            return l as any && r as any;\r\n\r\n        case 'or':\r\n            return (l as any) || (r as any);\r\n    }\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction comparissonOperation(l: Primitive, r: Primitive, op: ComparisonOperators): Primitive {\r\n    switch (op) {\r\n        case '==':\r\n            return l as any === r as any;\r\n\r\n        case '!=':\r\n            return (l as any) !== (r as any);\r\n\r\n        case '<>':\r\n            return (l as any) !== (r as any);\r\n\r\n        case '>':\r\n            return (l as number) > (r as number);\r\n\r\n        case '<':\r\n            return (l as number) < (r as number);\r\n\r\n        case '>=':\r\n            return (l as number) >= (r as number);\r\n\r\n        case '<=':\r\n            return (l as number) <= (r as number);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction arithmeticOperation(l: Primitive, r: Primitive, op: ArithmeticOperators): Primitive {\r\n\r\n    switch (op) {\r\n        case '+':\r\n            return l as any + r as any;\r\n\r\n        case '-':\r\n            return (l as any) - (r as any);\r\n\r\n        case '*':\r\n            return (l as number) * (r as number);\r\n\r\n        case '/':\r\n            return (l as number) / (r as number);\r\n\r\n        case '%':\r\n            return (l as number) % (r as number);\r\n\r\n        case '**':\r\n            return Math.pow(l as number, r as number);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}","import { OperationTypes, Operators, OperatorsMap } from \"./operators\";\r\n\r\nexport enum TokenTypes {\r\n    Identifier = 0,\r\n    Keyword = 1,\r\n    Separator = 2,\r\n    Operator = 3,\r\n    LiteralNumber = 4,\r\n    LiteralBool = 5,\r\n    LiteralString = 6,\r\n    LiteralNull = 7,\r\n    Comment = 8\r\n}\r\n/**\r\n * Token represent a single considered token in a script. Is represented as an array, where element at:\r\n *  0 : value\r\n *  1 : token details. For a memory and performance reasons we use Uint16Array with 5 elements in it:\r\n *    [\r\n *      0 - tokenType number equivalent of @TokenTypes\r\n *      1 - beginLine\r\n *      2 - beginColumn\r\n *      3 - endLine\r\n *      4 - endColumn\r\n *    ]\r\n * [(value). Uint16Array[5]([tokenType, beginLine, beginColumn, endLine, endColumn])]\r\n * tokenType\r\n */\r\nexport type Token = [string | number | boolean | null, Uint16Array];\r\nexport type TokenValue = string | number | boolean | null;\r\n\r\nexport function isTokenTypeLiteral(tokenType: TokenTypes): boolean {\r\n    return tokenType === TokenTypes.LiteralString\r\n        || tokenType === TokenTypes.LiteralNumber\r\n        || tokenType === TokenTypes.LiteralBool\r\n        || tokenType === TokenTypes.LiteralNull;\r\n}\r\n\r\nexport function getTokenType(token: Token): TokenTypes {\r\n    return token[1][0] as TokenTypes;\r\n}\r\n\r\nexport function getTokenValue(token: Token | null): TokenValue {\r\n    return token ? token[0] : null;\r\n}\r\n\r\nexport function getTokenLoc(token: Token): Uint16Array {\r\n    return token[1].subarray(1);\r\n}\r\n\r\nexport function getStartLine(token: Token): number {\r\n    return token[1][1];\r\n}\r\n\r\nexport function getStartColumn(token: Token): number {\r\n    return token[1][2];\r\n}\r\n\r\nexport function getEndLine(token: Token): number {\r\n    return token[1][3];\r\n}\r\n\r\nexport function getEndColumn(token: Token): number {\r\n    return token[1][4];\r\n}\r\n\r\nexport function splitTokens(tokens: Token[], separator: string): Token[][] {\r\n    const result: Token[][] = [];\r\n\r\n    if (!tokens.length) { return []; }\r\n\r\n    const sepIndexes = findTokenValueIndexes(tokens, value => value === separator);\r\n\r\n    let start = 0;\r\n    for (let i = 0; i < sepIndexes.length; i++) {\r\n        const ind = sepIndexes[i];\r\n        result.push(tokens.slice(start, ind));\r\n        start = ind + 1\r\n    }\r\n\r\n    result.push(tokens.slice(start, tokens.length));\r\n    return result;\r\n}\r\n\r\nexport function findTokenValueIndex(tokens: Token[], predicate: (value: TokenValue) => boolean, start = 0): number {\r\n    for (let i = start; i < tokens.length; i++) {\r\n        if (getTokenType(tokens[i]) === TokenTypes.LiteralString) { continue; }\r\n\r\n        if (getTokenValue(tokens[i]) === '(') {\r\n            i = skipInnerBrackets(tokens, i, '(', ')');\r\n        } else if (getTokenValue(tokens[i]) === '[') {\r\n            i = skipInnerBrackets(tokens, i, '[', ']');\r\n        } else if (getTokenValue(tokens[i]) === '{') {\r\n            i = skipInnerBrackets(tokens, i, '{', '}');\r\n        } else if (predicate(getTokenValue(tokens[i]))) {\r\n            return i;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nexport function findTokenValueIndexes(tokens: Token[], predicate: (value: TokenValue) => boolean): number[] {\r\n    const opIndexes: number[] = [];\r\n\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        const tValue = getTokenValue(tokens[i]);\r\n        const tType = getTokenType(tokens[i]);\r\n\r\n        if (tType === TokenTypes.LiteralString) { continue; }\r\n\r\n        if (tValue === '(') {\r\n            i = skipInnerBrackets(tokens, i, '(', ')');\r\n        } else if (tValue === '[') {\r\n            i = skipInnerBrackets(tokens, i, '[', ']');\r\n        } else if (tValue === '{') {\r\n            i = skipInnerBrackets(tokens, i, '{', '}');\r\n        } else if (predicate(tValue)) {\r\n            opIndexes.push(i);\r\n        }\r\n    }\r\n\r\n    return opIndexes;\r\n}\r\n\r\nexport function findOperators(tokens: Token[], operationType: OperationTypes | null = null): number[] {\r\n    return !operationType ? findTokenValueIndexes(tokens, value => OperatorsMap[value as Operators] !== undefined)\r\n        :\r\n        findTokenValueIndexes(tokens, value => OperatorsMap[value as Operators] === operationType);\r\n}\r\n\r\nfunction skipInnerBrackets(tokens: Token[], i: number, openChar: string, closeChar: string): number {\r\n    let innerBrackets = 0;\r\n    while (getTokenValue(tokens[++i]) !== closeChar || innerBrackets !== 0) {\r\n        if (i + 1 >= tokens.length) {\r\n            throw new Error(`Closing '${closeChar}' is missing`);\r\n        }\r\n\r\n        const tokenValue = getTokenValue(tokens[i]);\r\n        if (tokenValue === openChar) { innerBrackets++; }\r\n        if (tokenValue === closeChar) { innerBrackets--; }\r\n    }\r\n    return i;\r\n};\r\n","import { ExpressionOperators, LogicalOperators, OperationTypes, Operators } from \"./operators\";\r\nimport { getTokenLoc, getTokenValue, Token } from \"./token-types\";\r\n\r\nexport type AstNodeType = 'assign' | 'binOp' | 'const'\r\n    | 'logicalOp'\r\n    | 'getSingleVar' | 'setSingleVar' | 'dotObjectAccess' | 'bracketObjectAccess'\r\n    | 'funcCall' | 'funcDef' | 'arrowFuncDef'\r\n    | 'createObject' | 'createArray'\r\n    | 'if' | 'for' | 'while' | 'tryExcept' | 'raise'\r\n    | 'import' | 'comment'\r\n    | 'return' | 'continue' | 'break';\r\n\r\nexport interface NameAlias {\r\n    name: string,\r\n    alias: string | undefined\r\n}\r\n\r\nexport interface ExceptBody {\r\n    error: NameAlias;\r\n    body: AstNode[];\r\n}\r\n    \r\nexport interface FuncDefNode {\r\n    params: string[];\r\n    funcAst: AstBlock;\r\n}\r\n\r\nexport interface IsNullCoelsing {\r\n    nullCoelsing: boolean | undefined\r\n}\r\n\r\nexport interface ObjectPropertyInfo {\r\n    name: AstNode;\r\n    value: AstNode;\r\n}\r\n\r\nexport abstract class AstNode {\r\n    loc: Uint16Array | undefined = undefined;\r\n    constructor(public type: AstNodeType) { }\r\n}\r\n\r\nexport class AssignNode extends AstNode {\r\n    constructor(\r\n        public target: AstNode,\r\n        public source: AstNode,\r\n        public loc: Uint16Array) {\r\n        super('assign');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ConstNode extends AstNode {\r\n    public value: number | string | boolean | null;\r\n\r\n    constructor(token: Token) {\r\n        super('const');\r\n        this.value = getTokenValue(token);\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class CommentNode extends AstNode {\r\n    constructor(public comment: string, public loc: Uint16Array) {\r\n        super('comment');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ReturnNode extends AstNode {\r\n    constructor(public returnValue: AstNode | undefined = undefined, public loc: Uint16Array) {\r\n        super('return');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class RaiseNode extends AstNode {\r\n    constructor(public errorName: string, public errorMessage: string | undefined, public loc: Uint16Array) {\r\n        super('raise');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ContinueNode extends AstNode {\r\n    constructor() {\r\n        super('continue');\r\n    }\r\n}\r\n\r\nexport class BreakNode extends AstNode {\r\n    constructor() {\r\n        super('break');\r\n    }\r\n}\r\n\r\nexport class SetSingleVarNode extends AstNode {\r\n    public name: string;\r\n    constructor(token: Token) {\r\n        super('setSingleVar');\r\n        this.name = token[0] as string\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class FunctionCallNode extends AstNode implements IsNullCoelsing {\r\n    public nullCoelsing: boolean | undefined = undefined;\r\n\r\n    constructor(public name: string, public paramNodes: AstNode[] | null, public loc: Uint16Array) {\r\n        super('funcCall');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class FunctionDefNode extends AstNode implements FuncDefNode {\r\n    constructor(public funcAst: AstBlock, public params: string[], public isAsync: boolean, public loc: Uint16Array) {\r\n        super('funcDef');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ArrowFuncDefNode extends AstNode implements FuncDefNode {\r\n    constructor(public funcAst: AstBlock, public params: string[], public loc: Uint16Array) {\r\n        super('arrowFuncDef');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class IfNode extends AstNode {\r\n    constructor(\r\n        public conditionNode: AstNode,\r\n        public ifBody: AstNode[],\r\n        public elseBody: AstNode[] | undefined = undefined,\r\n        public loc: Uint16Array) {\r\n        super('if');\r\n        this.loc = loc\r\n    }\r\n}\r\n\r\nexport class TryExceptNode extends AstNode {\r\n    constructor(\r\n        public tryBody: AstNode[],\r\n        public exepts: ExceptBody[],\r\n        public elseBody: AstNode[] | undefined,\r\n        public finallyBody: AstNode[] | undefined,\r\n        \r\n        public loc: Uint16Array) {\r\n        super('tryExcept');\r\n        this.loc = loc\r\n    }\r\n}\r\n\r\nexport class ForNode extends AstNode {\r\n    constructor(public sourceArray: AstNode, public itemVarName: string, public body: AstNode[], public loc: Uint16Array) {\r\n        super('for');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class WhileNode extends AstNode {\r\n    constructor(public condition: AstNode, public body: AstNode[], public loc: Uint16Array) {\r\n        super('while');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ImportNode extends AstNode {\r\n    constructor(public module: NameAlias, public body: AstBlock, public parts: NameAlias[] | undefined = undefined, public loc: Uint16Array) {\r\n        super('import');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class GetSingleVarNode extends AstNode implements IsNullCoelsing {\r\n    name: string;\r\n    nullCoelsing: boolean | undefined = undefined;\r\n\r\n    constructor(token: Token, nullCoelsing: boolean | undefined = undefined) {\r\n        super('getSingleVar');\r\n        this.name = token[0] as string;\r\n        this.nullCoelsing = nullCoelsing;\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class DotObjectAccessNode extends AstNode {\r\n    constructor(public nestedProps: AstNode[], public loc: Uint16Array) {\r\n        super('dotObjectAccess');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class CreateObjectNode extends AstNode {\r\n    constructor(public props: ObjectPropertyInfo[], public loc: Uint16Array) {\r\n        super('createObject');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class CreateArrayNode extends AstNode {\r\n    constructor(public items: AstNode[], public loc: Uint16Array) {\r\n        super('createArray');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class BracketObjectAccessNode extends AstNode {\r\n    constructor(\r\n        public propertyName: string,\r\n        public bracketBody: AstNode,\r\n        public nullCoalescing: boolean | undefined = undefined,\r\n        public loc: Uint16Array) {\r\n        super('bracketObjectAccess');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport interface LogicalNodeItem {\r\n    node: AstNode,\r\n    op: LogicalOperators | undefined\r\n}\r\n\r\nexport class LogicalOpNode extends AstNode {\r\n    constructor(public items: LogicalNodeItem[],\r\n        public loc: Uint16Array) {\r\n        super('logicalOp');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class BinOpNode extends AstNode {\r\n    constructor(\r\n        public left: AstNode,\r\n        public op: ExpressionOperators,\r\n        public right: AstNode,\r\n        public loc: Uint16Array) {\r\n        super('binOp');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport interface AstBlock {\r\n    name: string;\r\n    type: 'module' | 'func' | 'if' | 'for' | 'while' | 'trycatch'\r\n    funcs: FunctionDefNode[];\r\n    body: AstNode[];\r\n}\r\n\r\n\r\n","\r\nexport interface BlockContext {\r\n    moduleName: string;\r\n    blockScope: Scope;\r\n    returnCalled?: boolean;\r\n    breakCalled?: boolean;\r\n    continueCalled?: boolean;\r\n    returnObject?: any;\r\n}\r\n\r\nexport function cloneContext(context: BlockContext): BlockContext {\r\n    return {\r\n        moduleName: context.moduleName,\r\n        blockScope: context.blockScope.clone()\r\n    } as BlockContext;\r\n}\r\n\r\nexport class Scope {\r\n    private readonly scope: Record<string, unknown> = {};\r\n\r\n    constructor(initialScope: Record<string, unknown>) {\r\n        this.scope = { ...initialScope };\r\n    }\r\n\r\n    getScope(): Record<string, unknown> {\r\n        return this.scope;\r\n    }\r\n\r\n    clone(): Scope {\r\n        return new Scope(this.scope);\r\n    }\r\n    set(key: string, value: unknown, path: string = '\\\\'): void {\r\n        this.scope[key] = value;\r\n    }\r\n\r\n    get(key: string, path: string = '\\\\'): unknown {\r\n        return this.scope[key];\r\n    }\r\n}\r\n","import {\r\n    ArrowFuncDefNode,\r\n    AssignNode, AstBlock, AstNode, BinOpNode, BracketObjectAccessNode, ConstNode, CreateArrayNode,\r\n    CreateObjectNode, DotObjectAccessNode, ForNode, FuncDefNode, FunctionCallNode, FunctionDefNode, GetSingleVarNode,\r\n    IfNode, IsNullCoelsing, LogicalOpNode, OperationFuncs, Primitive, RaiseNode, ReturnNode, SetSingleVarNode, TryExceptNode, WhileNode\r\n} from '../common';\r\nimport { JspyError, JspyEvalError } from '../common/utils';\r\nimport { BlockContext, cloneContext, Scope } from './scope';\r\n\r\nexport class Evaluator {\r\n\r\n    evalBlock(ast: AstBlock, blockContext: BlockContext): unknown {\r\n        let lastResult = null;\r\n\r\n        for (let node of ast?.funcs || []) {\r\n            const funcDef = node as FunctionDefNode;\r\n\r\n            // a child scope needs to be created here\r\n            const newScope = blockContext.blockScope;\r\n\r\n            newScope.set(funcDef.funcAst.name,\r\n                (...args: unknown[]): unknown => this.jspyFuncInvoker(funcDef, blockContext, ...args)\r\n            );\r\n        }\r\n\r\n        for (const node of ast.body) {\r\n            if (node.type === 'comment') { continue; }\r\n            if (node.type === 'import') {\r\n                // we can't use it here, because loader has to be promise\r\n                throw new Error(`Import is not support with 'eval'. Use method 'evalAsync' instead`);\r\n            }\r\n            try {\r\n                lastResult = this.evalNode(node, blockContext);\r\n\r\n                if (blockContext.returnCalled) {\r\n                    const res = blockContext.returnObject;\r\n\r\n                    // stop processing return\r\n                    if (ast.type == 'func' || ast.type == 'module') {\r\n                        blockContext.returnCalled = false;\r\n                        blockContext.returnObject = null;\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                if (blockContext.continueCalled) {\r\n                    break;\r\n                }\r\n                if (blockContext.breakCalled) {\r\n                    break;\r\n                }\r\n            } catch (err) {\r\n                const loc = node.loc ? node.loc : [0, 0]\r\n                if (err instanceof JspyError) {\r\n                    throw err;\r\n                } else if (err instanceof JspyEvalError) {\r\n                    throw err;\r\n                } else {\r\n                    throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], err.message || err)\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return lastResult;\r\n    }\r\n\r\n    jspyFuncInvoker(funcDef: FuncDefNode, context: BlockContext, ...args: unknown[]): unknown {\r\n        const ast = Object.assign({}, funcDef.funcAst);\r\n        ast.type = 'func';\r\n\r\n        const blockContext = cloneContext(context);\r\n\r\n        // set parameters into new scope, based incomming arguments        \r\n        for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n            const argValue = args?.length > i ? args[i] : null;\r\n            blockContext.blockScope.set(funcDef.params[i], argValue);\r\n        }\r\n\r\n        return this.evalBlock(ast, blockContext);\r\n    }\r\n\r\n    private invokeFunction(func: (...args: unknown[]) => unknown, fps: unknown[],\r\n        loc: { moduleName: string, line: number, column: number }): unknown {\r\n\r\n        if (fps.length === 0) { return func(); }\r\n        if (fps.length === 1) { return func(fps[0]); }\r\n        if (fps.length === 2) { return func(fps[0], fps[1]); }\r\n        if (fps.length === 3) { return func(fps[0], fps[1], fps[2]); }\r\n        if (fps.length === 4) {\r\n            return func(fps[0], fps[1], fps[2], fps[3]);\r\n        }\r\n        if (fps.length === 5) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4]);\r\n        }\r\n\r\n        if (fps.length === 6) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5]);\r\n        }\r\n\r\n        if (fps.length === 7) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6]);\r\n        }\r\n\r\n        if (fps.length === 8) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7]);\r\n        }\r\n\r\n        if (fps.length === 9) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8]);\r\n        }\r\n\r\n        if (fps.length === 10) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9]);\r\n        }\r\n\r\n        if (fps.length === 11) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10]);\r\n        }\r\n\r\n        if (fps.length === 12) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11]);\r\n        }\r\n\r\n        if (fps.length === 13) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12]);\r\n        }\r\n\r\n        if (fps.length === 14) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13]);\r\n        }\r\n\r\n        if (fps.length === 15) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13], fps[14]);\r\n        }\r\n\r\n        throw Error('Function has too many parameters. Current limitation is 15');\r\n\r\n    }\r\n\r\n    private evalNode(node: AstNode, blockContext: BlockContext): unknown {\r\n        if (node.type === 'import') {\r\n            // skip this for now. As modules are implemented externally\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'comment') {\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'if') {\r\n            const ifNode = node as IfNode;\r\n            if (this.evalNode(ifNode.conditionNode, blockContext)) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock, blockContext);\r\n            } else if (ifNode.elseBody) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock, blockContext);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'raise') {\r\n            const raiseNode = node as RaiseNode;\r\n            const err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, raiseNode.errorMessage || \"\");\r\n            throw err;\r\n        }\r\n\r\n        if (node.type === 'tryExcept') {\r\n            const tryNode = node as TryExceptNode;\r\n            try {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock, blockContext);\r\n\r\n                if (tryNode.elseBody?.length || 0 > 0) {\r\n                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n            catch (err) {\r\n                const name = (err instanceof JspyError) ? (err as JspyError).name : typeof (err);\r\n                const message = (err instanceof JspyError) ? (err as JspyError).message : err?.message ?? String(err);\r\n                const moduleName = (err instanceof JspyError) ? (err as JspyError).module : 0;\r\n                const line = (err instanceof JspyError) ? (err as JspyError).line : 0;\r\n                const column = (err instanceof JspyError) ? (err as JspyError).column : 0;\r\n\r\n                const firstExept = tryNode.exepts[0];\r\n                const catchBody = firstExept.body;\r\n                const ctx = blockContext;// cloneContext(blockContext);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", { name, message, line, column, moduleName })\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock, ctx);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", null)\r\n            }\r\n            finally {\r\n                if (tryNode.finallyBody?.length || 0 > 0) {\r\n                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.finallyBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'return') {\r\n            const returnNode = node as ReturnNode;\r\n            blockContext.returnCalled = true;\r\n            blockContext.returnObject = returnNode.returnValue ?\r\n                this.evalNode(returnNode.returnValue, blockContext)\r\n                : null;\r\n\r\n            return blockContext.returnObject;\r\n        }\r\n\r\n        if (node.type === 'continue') {\r\n            blockContext.continueCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'break') {\r\n            blockContext.breakCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'for') {\r\n            const forNode = node as ForNode;\r\n\r\n            const array = this.evalNode(forNode.sourceArray, blockContext) as unknown[] | string;\r\n\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n\r\n                blockContext.blockScope.set(forNode.itemVarName, item);\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock, blockContext);\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'while') {\r\n            const whileNode = node as WhileNode;\r\n\r\n            while (this.evalNode(whileNode.condition, blockContext)) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock, blockContext);\r\n\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === \"const\") {\r\n            return (node as ConstNode).value;\r\n        }\r\n\r\n        if (node.type === \"getSingleVar\") {\r\n            const name = (node as GetSingleVarNode).name;\r\n\r\n            const value = blockContext.blockScope.get((node as GetSingleVarNode).name);\r\n            if (value === undefined) {\r\n                if (name.charAt(name.length - 1) === ';') {\r\n                    throw new Error(`Unexpected ';' in the end.`);\r\n                } else {\r\n                    throw new Error(`Variable '${name}' is not defined.`);\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n\r\n        if (node.type === \"binOp\") {\r\n            const binOpNode = (node as BinOpNode);\r\n            var left = this.evalNode(binOpNode.left, blockContext);\r\n            var right = this.evalNode(binOpNode.right, blockContext);\r\n            return OperationFuncs[binOpNode.op](left as Primitive, right as Primitive);\r\n        }\r\n\r\n        if (node.type === \"logicalOp\") {\r\n            const logicalGroups = (node as LogicalOpNode);\r\n            let ind = 0;\r\n            let gResult: any = true;\r\n\r\n            while (ind < logicalGroups.items.length) {\r\n                const eg = logicalGroups.items[ind++];\r\n\r\n                gResult = this.evalNode(eg.node, blockContext)\r\n\r\n                if (eg.op === 'and' && !gResult) { return false; }\r\n                if (eg.op === 'or' && gResult) { return gResult; }\r\n            }\r\n\r\n            return gResult;\r\n        }\r\n\r\n        if (node.type === \"arrowFuncDef\") {\r\n            const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n            return (...args: unknown[]): unknown => this.jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n        }\r\n\r\n        if (node.type === \"funcCall\") {\r\n            const funcCallNode = node as FunctionCallNode;\r\n            const func = blockContext.blockScope.get(funcCallNode.name) as (...args: unknown[]) => unknown;\r\n            if (typeof func !== 'function') {\r\n                throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n            }\r\n\r\n            const pms = funcCallNode.paramNodes?.map(n => this.evalNode(n, blockContext)) || []\r\n\r\n            return this.invokeFunction(func, pms, {\r\n                moduleName: blockContext.moduleName,\r\n                line: funcCallNode.loc[0],\r\n                column: funcCallNode.loc[1]\r\n            });\r\n        }\r\n\r\n        if (node.type === \"assign\") {\r\n            const assignNode = node as AssignNode;\r\n\r\n            if (assignNode.target.type === 'getSingleVar') {\r\n                const node = assignNode.target as SetSingleVarNode;\r\n                blockContext.blockScope.set(node.name, this.evalNode(assignNode.source, blockContext));\r\n            } else if (assignNode.target.type === 'dotObjectAccess') {\r\n                const targetNode = assignNode.target as DotObjectAccessNode;\r\n\r\n                // create a node for all but last property token\r\n                // potentially it can go to parser\r\n                const targetObjectNode = new DotObjectAccessNode(targetNode.nestedProps.slice(0, targetNode.nestedProps.length - 1), targetNode.loc);\r\n                const targetObject = this.evalNode(targetObjectNode, blockContext) as Record<string, unknown>;\r\n\r\n                // not sure nested properties should be GetSingleVarNode\r\n                // can be factored in the parser\r\n                const lastPropertyName = (targetNode.nestedProps[targetNode.nestedProps.length - 1] as GetSingleVarNode).name\r\n\r\n                targetObject[lastPropertyName] = this.evalNode(assignNode.source, blockContext);\r\n            } else if (assignNode.target.type === 'bracketObjectAccess') {\r\n                const targetNode = assignNode.target as BracketObjectAccessNode;\r\n                const keyValue = this.evalNode(targetNode.bracketBody, blockContext) as string | number;\r\n                const targetObject = blockContext.blockScope.get(targetNode.propertyName as string) as Record<string, unknown>;\r\n\r\n                targetObject[keyValue] = this.evalNode(assignNode.source, blockContext);\r\n            } else {\r\n                throw Error('Not implemented Assign operation');\r\n                // get chaining calls\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'bracketObjectAccess') {\r\n            const sbNode = node as BracketObjectAccessNode;\r\n            const key = this.evalNode(sbNode.bracketBody, blockContext) as string;\r\n            const obj = blockContext.blockScope.get(sbNode.propertyName as string) as Record<string, unknown>;\r\n            return (obj[key] === undefined) ? null : obj[key];\r\n        }\r\n\r\n        if (node.type === \"dotObjectAccess\") {\r\n            const dotObject = node as DotObjectAccessNode;\r\n\r\n            let startObject = this.evalNode(dotObject.nestedProps[0], blockContext) as any;\r\n            for (let i = 1; i < dotObject.nestedProps.length; i++) {\r\n                const nestedProp = dotObject.nestedProps[i];\r\n\r\n                if ((dotObject.nestedProps[i - 1] as any).nullCoelsing && !startObject) {\r\n                    startObject = {};\r\n                }\r\n\r\n                if (nestedProp.type === 'getSingleVar') {\r\n                    startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n                } else if (nestedProp.type === 'bracketObjectAccess') {\r\n                    const node = nestedProp as BracketObjectAccessNode;\r\n                    startObject = startObject[node.propertyName] as unknown;\r\n                    startObject = startObject[this.evalNode(node.bracketBody, blockContext) as string] as unknown;\r\n                } else if (nestedProp.type === 'funcCall') {\r\n                    const funcCallNode = nestedProp as FunctionCallNode;\r\n                    const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n                    if ((func === undefined || func === null)\r\n                        && (dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing) {\r\n                        startObject = null;\r\n                        continue;\r\n                    }\r\n\r\n                    if (typeof func !== 'function') {\r\n                        throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n                    }\r\n                    const pms = funcCallNode.paramNodes?.map(n => this.evalNode(n, blockContext)) || []\r\n                    startObject = this.invokeFunction(func.bind(startObject), pms, {\r\n                        moduleName: blockContext.moduleName,\r\n                        line: funcCallNode.loc[0],\r\n                        column: funcCallNode.loc[1]\r\n                    });\r\n\r\n                } else {\r\n                    throw Error(\"Can't resolve dotObjectAccess node\")\r\n                }\r\n            }\r\n\r\n            // no undefined values, make it rather null\r\n            return (startObject === undefined) ? null : startObject;\r\n        }\r\n\r\n        if (node.type === 'createObject') {\r\n            const createObjectNode = node as CreateObjectNode;\r\n            const obj = {} as Record<string, unknown>;\r\n\r\n            for (const p of createObjectNode.props) {\r\n                obj[this.evalNode(p.name, blockContext) as string] = this.evalNode(p.value, blockContext);\r\n            }\r\n\r\n            return obj;\r\n        }\r\n\r\n        if (node.type === 'createArray') {\r\n            const arrayNode = node as CreateArrayNode;\r\n            const res = [] as unknown[];\r\n\r\n            for (const item of arrayNode.items) {\r\n                res.push(this.evalNode(item, blockContext));\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n    }\r\n}\r\n","import {\r\n    ArrowFuncDefNode,\r\n    AssignNode, AstBlock, AstNode, BinOpNode, BracketObjectAccessNode, ConstNode, CreateArrayNode,\r\n    CreateObjectNode, DotObjectAccessNode, ForNode, FuncDefNode, FunctionCallNode, FunctionDefNode, GetSingleVarNode,\r\n    getStartLine,\r\n    getTokenLoc,\r\n    IfNode, ImportNode, IsNullCoelsing, LogicalOpNode, OperationFuncs, Primitive, RaiseNode, ReturnNode, SetSingleVarNode, TryExceptNode, WhileNode\r\n} from '../common';\r\nimport { JspyEvalError, JspyError, getImportType } from '../common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { BlockContext, cloneContext, Scope } from './scope';\r\n\r\n/**\r\n * This is copy/paste from Evaluator.\r\n * Sadly, we have to copy code around to support both async and non async methods.\r\n * So, any changes to this method, should be replicated in the evaluator.ts\r\n */\r\nexport class EvaluatorAsync {\r\n\r\n    private moduleParser: (modulePath: string) => Promise<AstBlock> = () => Promise.reject('Module parser is not registered!');\r\n    private jsonFileLoader: (jsonFilePath: string) => Promise<string> = () => Promise.reject('{}');\r\n    private blockContextFactory?: (modulePath: string, ast: AstBlock) => BlockContext;\r\n\r\n    registerModuleParser(moduleParser: (modulePath: string) => Promise<AstBlock>): EvaluatorAsync {\r\n        this.moduleParser = moduleParser;\r\n        return this;\r\n    }\r\n\r\n    registerJsonFileLoader(jsonFileLoader: (modulePath: string) => Promise<string>): EvaluatorAsync {\r\n        this.jsonFileLoader = jsonFileLoader;\r\n        return this;\r\n    }\r\n\r\n    registerBlockContextFactory(blockContextFactory: (modulePath: string, ast: AstBlock) => BlockContext): EvaluatorAsync {\r\n        this.blockContextFactory = blockContextFactory;\r\n        return this;\r\n    }\r\n\r\n    async evalBlockAsync(ast: AstBlock, blockContext: BlockContext): Promise<unknown> {\r\n        let lastResult = null;\r\n\r\n        for (let node of ast?.funcs || []) {\r\n            const funcDef = node as FunctionDefNode;\r\n\r\n            // a child scope needs to be created here\r\n            const newScope = blockContext.blockScope;\r\n\r\n            const invoker = (funcDef.isAsync) ?\r\n                async (...args: unknown[]): Promise<unknown> => await this.jspyFuncInvokerAsync(funcDef, blockContext, ...args)\r\n                : (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(funcDef, blockContext, ...args);\r\n\r\n            newScope.set(funcDef.funcAst.name, invoker);\r\n        }\r\n\r\n        for (const node of ast.body) {\r\n            if (node.type === 'comment') { continue; }\r\n            if (node.type === 'import') {\r\n                const importNode = node as ImportNode;\r\n                const iType = getImportType(importNode.module.name);\r\n\r\n                if (iType === 'json') {\r\n                    const jsonValue = JSON.parse(await this.jsonFileLoader(importNode.module.name));\r\n                    blockContext.blockScope\r\n                        .set(importNode.module.alias || this.defaultModuleName(importNode.module.name), jsonValue);\r\n                    continue;\r\n                } else if (iType !== 'jspyModule') {\r\n                    // it is not JSPY import. It is JS and should be handled externally\r\n                    continue;\r\n                }\r\n\r\n                if (typeof this.blockContextFactory !== 'function') {\r\n                    throw new Error('blockContextFactory is not initialized');\r\n                }\r\n\r\n                const moduleAst = await this.moduleParser(importNode.module.name);\r\n                const moduleBlockContext = this.blockContextFactory(importNode.module.name, moduleAst);\r\n                await this.evalBlockAsync(moduleAst, moduleBlockContext);\r\n\r\n                let scope = blockContext.blockScope.getScope();\r\n\r\n                if (!importNode.parts?.length) {\r\n                    // if no parts, then we need to assign to a separate object\r\n                    scope = {};\r\n                    blockContext.blockScope.set(importNode.module.alias || this.defaultModuleName(importNode.module.name), scope);\r\n                }\r\n\r\n                this.assignFunctionsToScope(scope, moduleBlockContext, moduleAst, importNode.parts?.map(p => p.name));\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                lastResult = await this.evalNodeAsync(node, blockContext);\r\n                if (blockContext.returnCalled) {\r\n                    const res = blockContext.returnObject;\r\n                    // stop processing return\r\n                    if (ast.type == 'func' || ast.type == 'module') {\r\n                        blockContext.returnCalled = false;\r\n                        blockContext.returnObject = null;\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                if (blockContext.continueCalled) {\r\n                    break;\r\n                }\r\n                if (blockContext.breakCalled) {\r\n                    break;\r\n                }\r\n            } catch (err) {\r\n                const loc = node.loc ? node.loc : [0, 0]\r\n                if (err instanceof JspyError) {\r\n                    throw err;\r\n                } else if (err instanceof JspyEvalError) {\r\n                    throw err;\r\n                } else {\r\n                    throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], err.message || err)\r\n                }\r\n            }\r\n        }\r\n\r\n        return lastResult;\r\n    }\r\n\r\n    private assignFunctionsToScope(scope: Record<string, unknown>, moduleBlockContext: BlockContext,\r\n        moduleAst: AstBlock, parts?: string[]): void {\r\n\r\n        const funcs = moduleAst.funcs.filter(f => !parts || parts.indexOf(f.funcAst?.name) >= 0);\r\n\r\n        for (let i = 0; i < funcs.length; i++) {\r\n            const funcDef = funcs[i] as FunctionDefNode;\r\n\r\n            const invoker = (funcDef.isAsync) ?\r\n                async (...args: unknown[]): Promise<unknown> => await this.jspyFuncInvokerAsync(funcDef, moduleBlockContext, ...args)\r\n                : (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(funcDef, moduleBlockContext, ...args);\r\n\r\n            scope[funcDef.funcAst.name] = invoker;\r\n        }\r\n    }\r\n\r\n    private defaultModuleName(name: string): string {\r\n        return name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.'))\r\n    }\r\n\r\n    private async jspyFuncInvokerAsync(funcDef: FuncDefNode, context: BlockContext, ...args: unknown[]): Promise<unknown> {\r\n\r\n        const ast = Object.assign({}, funcDef.funcAst);\r\n        ast.type = 'func';\r\n\r\n        const blockContext = cloneContext(context);\r\n\r\n        // set parameters into new scope, based incomming arguments        \r\n        for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n            const argValue = args?.length > i ? args[i] : null;\r\n            blockContext.blockScope.set(funcDef.params[i], argValue);\r\n        }\r\n\r\n        return await this.evalBlockAsync(ast, blockContext);\r\n    }\r\n\r\n    private async invokeFunctionAsync(func: (...args: unknown[]) => unknown, fps: unknown[],\r\n        loc?: { moduleName: string, line: number, column: number }): Promise<unknown> {\r\n\r\n        if (fps.length === 0) { return await func(); }\r\n        if (fps.length === 1) { return await func(fps[0]); }\r\n        if (fps.length === 2) { return await func(fps[0], fps[1]); }\r\n        if (fps.length === 3) { return await func(fps[0], fps[1], fps[2]); }\r\n        if (fps.length === 4) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3]);\r\n        }\r\n        if (fps.length === 5) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4]);\r\n        }\r\n\r\n        if (fps.length === 6) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5]);\r\n        }\r\n\r\n        if (fps.length === 7) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6]);\r\n        }\r\n\r\n        if (fps.length === 8) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7]);\r\n        }\r\n\r\n        if (fps.length === 9) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8]);\r\n        }\r\n\r\n        if (fps.length === 10) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9]);\r\n        }\r\n\r\n        if (fps.length === 11) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10]);\r\n        }\r\n\r\n        if (fps.length === 12) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11]);\r\n        }\r\n\r\n        if (fps.length === 13) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12]);\r\n        }\r\n\r\n        if (fps.length === 14) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13]);\r\n        }\r\n\r\n        if (fps.length === 15) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13], fps[14]);\r\n        }\r\n\r\n        throw Error('Function has too many parameters. Current limitation is 15');\r\n\r\n    }\r\n\r\n    private async evalNodeAsync(node: AstNode, blockContext: BlockContext): Promise<unknown> {\r\n        if (node.type === 'import') {\r\n            throw new Error('Import should be defined at the start');\r\n        }\r\n\r\n        if (node.type === 'comment') {\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'if') {\r\n            const ifNode = node as IfNode;\r\n            if (await this.evalNodeAsync(ifNode.conditionNode, blockContext)) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock, blockContext);\r\n            } else if (ifNode.elseBody) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock, blockContext);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'raise') {\r\n            const raiseNode = node as RaiseNode;\r\n            const err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, raiseNode.errorMessage || \"\");\r\n            throw err;\r\n        }\r\n\r\n        if (node.type === 'tryExcept') {\r\n            const tryNode = node as TryExceptNode;\r\n            try {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock, blockContext);\r\n\r\n                if (tryNode.elseBody?.length || 0 > 0) {\r\n                    await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n            catch (err) {\r\n                // catches here all exceptions. Including JSPY Eval errors\r\n                const name = (err instanceof JspyError) ? (err as JspyError).name : typeof (err);\r\n                const message = (err instanceof JspyError) ? (err as JspyError).message : err?.message ?? String(err);\r\n                const moduleName = (err instanceof JspyError) ? (err as JspyError).module : 0;\r\n                const line = (err instanceof JspyError) ? (err as JspyError).line : 0;\r\n                const column = (err instanceof JspyError) ? (err as JspyError).column : 0;\r\n\r\n                const firstExept = tryNode.exepts[0];\r\n                const catchBody = firstExept.body;\r\n                const ctx = blockContext;\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", { name, message, line, column, moduleName })\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock, ctx);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", null);\r\n            }\r\n            finally {\r\n                if (tryNode.finallyBody?.length || 0 > 0) {\r\n                    await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.finallyBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'return') {\r\n            const returnNode = node as ReturnNode;\r\n            blockContext.returnCalled = true;\r\n            blockContext.returnObject = returnNode.returnValue ?\r\n                await this.evalNodeAsync(returnNode.returnValue, blockContext)\r\n                : null;\r\n\r\n            return blockContext.returnObject;\r\n        }\r\n\r\n        if (node.type === 'continue') {\r\n            blockContext.continueCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'break') {\r\n            blockContext.breakCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'for') {\r\n            const forNode = node as ForNode;\r\n\r\n            const array = await this.evalNodeAsync(forNode.sourceArray, blockContext) as unknown[] | string;\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n                blockContext.blockScope.set(forNode.itemVarName, item);\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock, blockContext);\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'while') {\r\n            const whileNode = node as WhileNode;\r\n\r\n            while (await this.evalNodeAsync(whileNode.condition, blockContext)) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock, blockContext);\r\n\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === \"const\") {\r\n            return (node as ConstNode).value;\r\n        }\r\n\r\n        if (node.type === \"getSingleVar\") {\r\n            const name = (node as GetSingleVarNode).name;\r\n            const value = blockContext.blockScope.get(name);\r\n\r\n            if (value === undefined) {\r\n                if (name.charAt(name.length - 1) === ';') {\r\n                    throw new Error(`Unexpected ';' in the end.`);\r\n                } else {\r\n                    throw new Error(`Variable '${name}' is not defined.`);\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n\r\n        if (node.type === \"binOp\") {\r\n            const binOpNode = (node as BinOpNode);\r\n            var left = await this.evalNodeAsync(binOpNode.left, blockContext);\r\n            var right = await this.evalNodeAsync(binOpNode.right, blockContext);\r\n            return OperationFuncs[binOpNode.op](left as Primitive, right as Primitive);\r\n        }\r\n\r\n        if (node.type === \"logicalOp\") {\r\n            const logicalGroups = (node as LogicalOpNode);\r\n            let ind = 0;\r\n            let gResult: any = true;\r\n\r\n            while (ind < logicalGroups.items.length) {\r\n                const eg = logicalGroups.items[ind++];\r\n\r\n                gResult = await this.evalNodeAsync(eg.node, blockContext)\r\n\r\n                if (eg.op === 'and' && !gResult) { return false; }\r\n                if (eg.op === 'or' && gResult) { return gResult; }\r\n            }\r\n\r\n            return gResult;\r\n        }\r\n\r\n        if (node.type === \"arrowFuncDef\") {\r\n            const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n            return (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n        }\r\n\r\n        if (node.type === \"funcCall\") {\r\n            const funcCallNode = node as FunctionCallNode;\r\n            const func = blockContext.blockScope.get(funcCallNode.name) as (...args: unknown[]) => unknown;\r\n\r\n            if (typeof func !== 'function') {\r\n                throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n            }\r\n\r\n            const pms = [];\r\n            for (let p of funcCallNode.paramNodes || []) {\r\n                pms.push(await this.evalNodeAsync(p, blockContext));\r\n            }\r\n\r\n            return await this.invokeFunctionAsync(func, pms, {\r\n                moduleName: blockContext.moduleName,\r\n                line: funcCallNode.loc[0],\r\n                column: funcCallNode.loc[0]\r\n            });\r\n        }\r\n\r\n        if (node.type === \"assign\") {\r\n            const assignNode = node as AssignNode;\r\n\r\n            if (assignNode.target.type === 'getSingleVar') {\r\n                const node = assignNode.target as SetSingleVarNode;\r\n                blockContext.blockScope.set(node.name, await this.evalNodeAsync(assignNode.source, blockContext));\r\n            } else if (assignNode.target.type === 'dotObjectAccess') {\r\n                const targetNode = assignNode.target as DotObjectAccessNode;\r\n\r\n                // create a node for all but last property token\r\n                // potentially it can go to parser\r\n                const targetObjectNode = new DotObjectAccessNode(targetNode.nestedProps.slice(0, targetNode.nestedProps.length - 1), targetNode.loc);\r\n                const targetObject = await this.evalNodeAsync(targetObjectNode, blockContext) as Record<string, unknown>;\r\n\r\n                // not sure nested properties should be GetSingleVarNode\r\n                // can be factored in the parser\r\n                const lastPropertyName = (targetNode.nestedProps[targetNode.nestedProps.length - 1] as GetSingleVarNode).name\r\n\r\n                targetObject[lastPropertyName] = await this.evalNodeAsync(assignNode.source, blockContext);\r\n            } else if (assignNode.target.type === 'bracketObjectAccess') {\r\n                const targetNode = assignNode.target as BracketObjectAccessNode;\r\n                const keyValue = await this.evalNodeAsync(targetNode.bracketBody, blockContext) as string | number;\r\n                const targetObject = blockContext.blockScope.get(targetNode.propertyName as string) as Record<string, unknown>;\r\n\r\n                targetObject[keyValue] = await this.evalNodeAsync(assignNode.source, blockContext);\r\n            } else {\r\n                throw Error('Not implemented Assign operation');\r\n                // get chaining calls\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'bracketObjectAccess') {\r\n            const sbNode = node as BracketObjectAccessNode;\r\n            const key = await this.evalNodeAsync(sbNode.bracketBody, blockContext) as string;\r\n            const obj = blockContext.blockScope.get(sbNode.propertyName as string) as Record<string, unknown>;\r\n            return (obj[key] === undefined) ? null : obj[key];\r\n        }\r\n\r\n        if (node.type === \"dotObjectAccess\") {\r\n            const dotObject = node as DotObjectAccessNode;\r\n\r\n            let startObject = await this.evalNodeAsync(dotObject.nestedProps[0], blockContext) as any;\r\n            for (let i = 1; i < dotObject.nestedProps.length; i++) {\r\n                const nestedProp = dotObject.nestedProps[i];\r\n\r\n                if ((dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing && !startObject) {\r\n                    startObject = {};\r\n                }\r\n\r\n                if (nestedProp.type === 'getSingleVar') {\r\n                    startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n                } else if (nestedProp.type === 'bracketObjectAccess') {\r\n                    const node = nestedProp as BracketObjectAccessNode;\r\n                    startObject = startObject[node.propertyName] as unknown;\r\n                    startObject = startObject[await this.evalNodeAsync(node.bracketBody, blockContext) as string] as unknown;\r\n                } else if (nestedProp.type === 'funcCall') {\r\n                    const funcCallNode = nestedProp as FunctionCallNode;\r\n                    const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n                    if ((func === undefined || func === null)\r\n                        && (dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing) {\r\n                        startObject = null;\r\n                        continue;\r\n                    }\r\n\r\n                    if (typeof (func) !== 'function') {\r\n                        throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n                    }\r\n                    const pms = []\r\n                    for (let p of funcCallNode.paramNodes || []) {\r\n                        pms.push(await this.evalNodeAsync(p, blockContext));\r\n                    }\r\n\r\n                    startObject = await this.invokeFunctionAsync(func.bind(startObject), pms, {\r\n                        moduleName: blockContext.moduleName,\r\n                        line: funcCallNode.loc[0],\r\n                        column: funcCallNode.loc[0]\r\n                    });\r\n\r\n                } else {\r\n                    throw Error(\"Can't resolve dotObjectAccess node\")\r\n                }\r\n            }\r\n\r\n            // no undefined values, make it rather null\r\n            return (startObject === undefined) ? null : startObject;\r\n        }\r\n\r\n        if (node.type === 'createObject') {\r\n            const createObjectNode = node as CreateObjectNode;\r\n            const obj = {} as Record<string, unknown>;\r\n\r\n            for (const p of createObjectNode.props) {\r\n                obj[await this.evalNodeAsync(p.name, blockContext) as string] = await this.evalNodeAsync(p.value, blockContext);\r\n            }\r\n\r\n            return obj;\r\n        }\r\n\r\n        if (node.type === 'createArray') {\r\n            const arrayNode = node as CreateArrayNode;\r\n            const res = [] as unknown[];\r\n\r\n            for (const item of arrayNode.items) {\r\n                res.push(await this.evalNodeAsync(item, blockContext));\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n    }\r\n}\r\n","import { parseDatetimeOrNull } from \"./common/utils\";\r\n\r\nexport const INITIAL_SCOPE = {\r\n    jsPython(): string {\r\n        return [`JSPython v2.1.5`, \"(c) 2021 FalconSoft Ltd. All rights reserved.\"].join('\\n')\r\n    },\r\n    dateTime: (str: number | string | any = null) => parseDatetimeOrNull(str) || new Date(),\r\n    range: range,\r\n    print: (...args: any[]) => { console.log(...args); return args.length > 0 ? args[0] : null; },\r\n    isNull: (v: any, defValue: any = null): boolean | any => defValue === null ? v === null : v || defValue,\r\n    isDate: (d: any): boolean => d instanceof Date,\r\n    isFunction: (v: any): boolean => typeof v === 'function',\r\n    isString: (v: any): boolean => typeof v === 'string',\r\n    deleteProperty: (obj: any, propName: string): boolean => delete obj[propName],\r\n    Math: Math,\r\n    Object: Object,\r\n    Array: Array,\r\n    JSON: JSON,\r\n    printExecutionContext: () => {}, // will be overriden at runtime\r\n    getExecutionContext: () => {} // will be overriden at runtime\r\n};\r\n\r\n/**\r\n * This interface needs to be replaced\r\n */\r\nexport interface PackageToImport {\r\n    name: string;\r\n    properties?: { name: string, as?: string }[];\r\n    as?: string;\r\n}\r\n\r\nfunction range(start: number, stop: number = NaN, step: number = 1): number[] {\r\n    const arr: number[] = [];\r\n    const isStopNaN = isNaN(stop);\r\n    stop = isStopNaN ? start : stop;\r\n    start = isStopNaN ? 0 : start;\r\n    let i = start;\r\n    while (i < stop) {\r\n        arr.push(i);\r\n        i += step;\r\n    }\r\n    return arr;\r\n}\r\n","import {\r\n    BinOpNode, ConstNode, AstBlock, Token, ParserOptions, AstNode, Operators, AssignNode, TokenTypes,\r\n    GetSingleVarNode, FunctionCallNode, getTokenType, getTokenValue, isTokenTypeLiteral, getStartLine,\r\n    getStartColumn, getEndColumn, getEndLine, findOperators, splitTokens, DotObjectAccessNode, BracketObjectAccessNode,\r\n    findTokenValueIndex, FunctionDefNode, CreateObjectNode, ObjectPropertyInfo, CreateArrayNode, ArrowFuncDefNode,\r\n    ExpressionOperators, IfNode, ForNode, WhileNode, ImportNode, NameAlias, ContinueNode, BreakNode, ReturnNode, CommentNode,\r\n    getTokenLoc, OperationTypes, LogicalNodeItem, LogicalOperators, LogicalOpNode, ComparisonOperators, TryExceptNode, ExceptBody, RaiseNode\r\n} from '../common';\r\nimport { JspyParserError } from '../common/utils';\r\n\r\nclass InstructionLine {\r\n    readonly tokens: Token[] = [];\r\n\r\n    startLine(): number {\r\n        return getStartLine(this.tokens[0]);\r\n    }\r\n\r\n    startColumn(): number {\r\n        return getStartColumn(this.tokens[0]);\r\n    }\r\n\r\n    endLine(): number {\r\n        return getEndLine(this.tokens[this.tokens.length - 1]);\r\n    }\r\n\r\n    endColumn(): number {\r\n        return getEndColumn(this.tokens[this.tokens.length - 1]);\r\n    }\r\n}\r\n\r\nexport class Parser {\r\n    private _currentToken: Token | null = null;\r\n    private _moduleName = '';\r\n\r\n    /**\r\n     * Parses tokens and return Ast - Abstract Syntax Tree for jsPython code\r\n     * @param tokens tokens\r\n     * @param options parsing options. By default it will exclude comments and include LOC (Line of code)\r\n     */\r\n    parse(tokens: Token[], name = 'main.jspy', type = 'module'): AstBlock {\r\n        this._moduleName = name;\r\n        const ast = { name, type, funcs: [], body: [] } as AstBlock;\r\n\r\n        if (!tokens || !tokens.length) { return ast; }\r\n\r\n        try {\r\n\r\n            // group all tokens into an Instruction lines.\r\n            const instructions = this.tokensToInstructionLines(tokens, 1);\r\n\r\n            // process all instructions\r\n            this.instructionsToNodes(instructions, ast);\r\n\r\n        } catch (err) {\r\n            const token = this._currentToken ?? {} as Token\r\n            throw new JspyParserError(ast.name, getStartLine(token), getStartColumn(token), err.message || err)\r\n        }\r\n        return ast;\r\n    }\r\n\r\n    private instructionsToNodes(instructions: InstructionLine[], ast: AstBlock): void {\r\n\r\n        const getBody = (tokens: Token[], startTokenIndex: number): AstNode[] => {\r\n            const instructionLines = this.tokensToInstructionLines(tokens, getStartLine(tokens[startTokenIndex]));\r\n            const bodyAst = { name: ast.name, body: [] as AstNode[], funcs: [] as AstNode[] } as AstBlock;\r\n            this.instructionsToNodes(instructionLines, bodyAst);\r\n            return bodyAst.body;\r\n        }\r\n\r\n        const findIndexes = (tkns: Token[], operation: OperationTypes, result: number[]): boolean => {\r\n            result.splice(0, result.length);\r\n            findOperators(tkns, operation).forEach(r => result.push(r));\r\n            return !!result.length;\r\n        }\r\n\r\n        for (let i = 0; i < instructions.length; i++) {\r\n            const instruction = instructions[i];\r\n\r\n            // remove comments\r\n            let tt = 0;\r\n            while (tt < instruction.tokens.length) {\r\n                if (getTokenType(instruction.tokens[tt]) === TokenTypes.Comment) {\r\n                    instruction.tokens.splice(tt, 1);\r\n                } else {\r\n                    tt++;\r\n                }\r\n            }\r\n            if (!instruction.tokens.length) {\r\n                continue;\r\n            }\r\n\r\n            const firstToken = instruction.tokens[0];\r\n            const secondToken = instruction.tokens.length > 1 ? instruction.tokens[1] : null;\r\n            this._currentToken = firstToken;\r\n\r\n            const logicOpIndexes: number[] = [];\r\n            const comparisonOpIndexs: number[] = [];\r\n            const assignTokenIndexes: number[] = [];\r\n\r\n            if (getTokenType(firstToken) === TokenTypes.Comment) {\r\n                ast.body.push(new CommentNode(getTokenValue(firstToken) as string, getTokenLoc(firstToken)));\r\n            } else if (getTokenValue(firstToken) === 'def'\r\n                || (getTokenValue(firstToken) === \"async\" && getTokenValue(secondToken) === \"def\")) {\r\n\r\n                const isAsync = getTokenValue(firstToken) === \"async\";\r\n                const funcName = getTokenValue(instruction.tokens[isAsync ? 2 : 1]) as string;\r\n                const paramsTokens = instruction.tokens.slice(\r\n                    instruction.tokens.findIndex(tkns => getTokenValue(tkns) === '(') + 1,\r\n                    instruction.tokens.findIndex(tkns => getTokenValue(tkns) === ')')\r\n                );\r\n\r\n                const params = splitTokens(paramsTokens, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for def`)\r\n                }\r\n\r\n                const instructionLines = this.tokensToInstructionLines(instruction.tokens, getStartLine(instruction.tokens[endDefOfDef + 1]));\r\n                const funcAst = {\r\n                    name: funcName,\r\n                    body: [] as AstNode[],\r\n                    funcs: [] as AstNode[]\r\n                } as AstBlock;\r\n                this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n                ast.funcs.push(new FunctionDefNode(funcAst, params, isAsync, getTokenLoc(instruction.tokens[0])))\r\n\r\n            } else if (getTokenValue(firstToken) === 'if') {\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for if`)\r\n                }\r\n\r\n                const ifBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n                const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n\r\n                const conditionNode = (findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)) ?\r\n                    this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n                    :\r\n                    this.createExpressionNode(conditionTokens);\r\n\r\n                let elseBody: AstNode[] | undefined = undefined;\r\n                if (instructions.length > i + 1\r\n                    && getTokenValue(instructions[i + 1].tokens[0]) === 'else'\r\n                    && getTokenValue(instructions[i + 1].tokens[1]) === ':') {\r\n                    elseBody = getBody(instructions[i + 1].tokens, 2);\r\n                    i++;\r\n                }\r\n\r\n                ast.body.push(new IfNode(conditionNode, ifBody, elseBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'try') {\r\n\r\n                if (getTokenValue(instruction.tokens[1]) !== ':') {\r\n                    throw (`'try' statement should be followed by ':'`)\r\n                }\r\n\r\n                const tryBody = getBody(instruction.tokens, 2);\r\n                const excepts: ExceptBody[] = [];\r\n\r\n                let elseBody: AstNode[] | undefined = undefined;\r\n                let finallyBody: AstNode[] | undefined = undefined;\r\n\r\n                while (instructions.length > i + 1\r\n                    && (\r\n                        getTokenValue(instructions[i + 1].tokens[0]) === 'else'\r\n                        || getTokenValue(instructions[i + 1].tokens[0]) === 'except'\r\n                        || getTokenValue(instructions[i + 1].tokens[0]) === 'finally'\r\n                    )\r\n                ) {\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'else') {\r\n                        if (elseBody) {\r\n                            throw new Error(`Only one 'else' is allowed in a 'try'`)\r\n                        }\r\n\r\n                        elseBody = getBody(instructions[i + 1].tokens, 2);\r\n                    }\r\n\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'finally') {\r\n                        if (finallyBody) {\r\n                            throw new Error(`Only one 'else' is allowed in a 'try'`)\r\n                        }\r\n\r\n                        finallyBody = getBody(instructions[i + 1].tokens, 2);\r\n                    }\r\n\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'except') {\r\n\r\n                        const endIndex = findTokenValueIndex(instructions[i + 1].tokens, v => v === ':');\r\n                        const except = {} as ExceptBody;\r\n\r\n                        if (endIndex === 2) {\r\n                            except.error = { name: getTokenValue(instructions[i + 1].tokens[1]) } as NameAlias;\r\n                        } else if (endIndex === 3) {\r\n                            except.error = {\r\n                                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                                alias: getTokenValue(instructions[i + 1].tokens[2]),\r\n                            } as NameAlias;\r\n                        } else if (endIndex === 4) {\r\n                            except.error = {\r\n                                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                                alias: getTokenValue(instructions[i + 1].tokens[3]),\r\n                            } as NameAlias;\r\n                        } else if (endIndex !== 1) {\r\n                            throw new Error(`Incorrect 'except:' statement. Valid stats: (except: or except Error: or except Error as e:)`)\r\n                        }\r\n\r\n                        except.body = getBody(instructions[i + 1].tokens, endIndex + 1);\r\n\r\n                        excepts.push(except);\r\n                    }\r\n\r\n                    i++;\r\n                }\r\n\r\n                if (!excepts.length) {\r\n                    throw new Error('Except: is missing');\r\n                }\r\n\r\n                ast.body.push(new TryExceptNode(tryBody, excepts, elseBody, finallyBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'continue') {\r\n                ast.body.push(new ContinueNode());\r\n            } else if (getTokenValue(firstToken) === 'break') {\r\n                ast.body.push(new BreakNode());\r\n            } else if (getTokenValue(firstToken) === 'return') {\r\n                ast.body.push(new ReturnNode(\r\n                    instruction.tokens.length > 1 ? this.createExpressionNode(instruction.tokens.slice(1)) : undefined,\r\n                    getTokenLoc(firstToken))\r\n                );\r\n            } else if (getTokenValue(firstToken) === 'raise') {\r\n\r\n                if (instruction.tokens.length === 1) {\r\n                    throw new Error(`Incorrect 'raise' usage. Please specify error name and message `);\r\n                }\r\n                const errorName = getTokenValue(instruction.tokens[1]) as string;\r\n\r\n                const errorMessage = (\r\n                    instruction.tokens.length == 5\r\n                    && getTokenValue(instruction.tokens[2]) === \"(\"\r\n                    && getTokenValue(instruction.tokens[4]) === \")\"\r\n                ) ? getTokenValue(instruction.tokens[3]) as string\r\n                    : undefined;\r\n\r\n                ast.body.push(new RaiseNode(errorName, errorMessage, getTokenLoc(firstToken)));\r\n            } else if (getTokenValue(firstToken) === 'for') {\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for if`)\r\n                }\r\n\r\n                const itemVarName = getTokenValue(instruction.tokens[1]) as string;\r\n                const sourceArray = this.createExpressionNode(instruction.tokens.slice(3, endDefOfDef))\r\n                const forBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n                ast.body.push(new ForNode(sourceArray, itemVarName, forBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'while') {\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for [while]`)\r\n                }\r\n\r\n\r\n                const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n                const conditionNode = (findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)) ?\r\n                    this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n                    :\r\n                    this.createExpressionNode(conditionTokens);\r\n\r\n                const body = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n                ast.body.push(new WhileNode(conditionNode, body, getTokenLoc(firstToken)));\r\n\r\n            } else if (getTokenValue(firstToken) === 'import') {\r\n                let asIndex = findTokenValueIndex(instruction.tokens, v => v === 'as');\r\n                if (asIndex < 0) {\r\n                    asIndex = instruction.tokens.length;\r\n                }\r\n\r\n                const module = {\r\n                    name: instruction.tokens.slice(1, asIndex).map(t => getTokenValue(t)).join(''),\r\n                    alias: instruction.tokens.slice(asIndex + 1).map(t => getTokenValue(t)).join('') || undefined\r\n                } as NameAlias;\r\n\r\n                const body = {} as AstBlock; // empty for now\r\n                ast.body.push(new ImportNode(module, body, undefined, getTokenLoc(firstToken)))\r\n            } else if (getTokenValue(firstToken) === 'from') {\r\n                const importIndex = findTokenValueIndex(instruction.tokens, v => v === 'import');\r\n                if (importIndex < 0) {\r\n                    throw Error(`'import' must follow 'from'`);\r\n                }\r\n\r\n                const module = {\r\n                    name: instruction.tokens.slice(1, importIndex).map(t => getTokenValue(t)).join('')\r\n                } as NameAlias;\r\n\r\n                const parts = splitTokens(instruction.tokens.slice(importIndex + 1), ',')\r\n                    .map(t => {\r\n                        return {\r\n                            name: getTokenValue(t[0]),\r\n                            alias: (t.length === 3) ? getTokenValue(t[2]) : undefined\r\n                        } as NameAlias\r\n                    });\r\n\r\n                const body = {} as AstBlock; // empty for now\r\n\r\n                ast.body.push(new ImportNode(module, body, parts, getTokenLoc(firstToken)))\r\n            } else if (findIndexes(instruction.tokens, OperationTypes.Assignment, assignTokenIndexes)) {\r\n                const assignTokens = splitTokens(instruction.tokens, '=');\r\n                const target = this.createExpressionNode(assignTokens[0]);\r\n                const source = this.createExpressionNode(assignTokens[1]);\r\n                ast.body.push(new AssignNode(target, source, getTokenLoc(assignTokens[0][0])));\r\n            } else if (findIndexes(instruction.tokens, OperationTypes.Logical, logicOpIndexes)) {\r\n                ast.body.push(this.groupLogicalOperations(logicOpIndexes, instruction.tokens));\r\n            } else {\r\n                ast.body.push(this.createExpressionNode(instruction.tokens))\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    private sliceWithBrackets(a: Token[], begin: number, end: number): Token[] {\r\n        // if expression is in brackets, then we need clean brackets\r\n        if (getTokenValue(a[begin]) === '(' && getTokenType(a[begin]) !== TokenTypes.LiteralString) {\r\n            begin++;\r\n            end--;\r\n        }\r\n\r\n        return a.slice(begin, end);\r\n    }\r\n\r\n    private groupComparisonOperations(indexes: number[], tokens: Token[]): AstNode {\r\n        const start = 0;\r\n\r\n        let leftNode: AstNode | null = null;\r\n        for (let i = 0; i < indexes.length; i++) {\r\n            const opToken = getTokenValue(tokens[indexes[i]]) as ComparisonOperators;\r\n            leftNode = (leftNode) ? leftNode : this.createExpressionNode(this.sliceWithBrackets(tokens, start, indexes[i]))\r\n\r\n            const endInd = (i + 1 < indexes.length) ? indexes[i + 1] : tokens.length;\r\n            const rightNode = this.createExpressionNode(this.sliceWithBrackets(tokens, indexes[i] + 1, endInd))\r\n\r\n            leftNode = new BinOpNode(leftNode, opToken, rightNode, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        return leftNode as AstNode;\r\n    }\r\n\r\n    private groupLogicalOperations(logicOp: number[], tokens: Token[]): LogicalOpNode {\r\n        let start = 0;\r\n        const logicItems: LogicalNodeItem[] = [];\r\n        for (let i = 0; i < logicOp.length; i++) {\r\n            const opToken = tokens[logicOp[i]];\r\n            const logicalSlice = this.sliceWithBrackets(tokens, start, logicOp[i]);\r\n            logicItems.push({\r\n                node: this.createExpressionNode(logicalSlice),\r\n                op: getTokenValue(opToken) as LogicalOperators\r\n            });\r\n\r\n            start = logicOp[i] + 1;\r\n        }\r\n\r\n        logicItems.push({\r\n            node: this.createExpressionNode(this.sliceWithBrackets(tokens, start, tokens.length))\r\n        } as LogicalNodeItem);\r\n\r\n        const lop = new LogicalOpNode(logicItems, getTokenLoc(tokens[0]));\r\n        return lop;\r\n    }\r\n\r\n    private tokensToInstructionLines(tokens: Token[], startLine: number): InstructionLine[] {\r\n        const lines: InstructionLine[] = [];\r\n\r\n        let column = 0;\r\n        let currentLine = startLine;\r\n        let line = new InstructionLine();\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            const token = tokens[i];\r\n            const sLine = getStartLine(token);\r\n            const sColumn = getStartColumn(token);\r\n            const value = getTokenValue(token);\r\n            this._currentToken = token;\r\n\r\n            if (sLine >= startLine) {\r\n\r\n                if (currentLine !== sLine) {\r\n                    currentLine = sLine;\r\n                }\r\n\r\n                if (column === sColumn && !\")}]\".includes(value as string)) {\r\n                    currentLine = sLine;\r\n                    lines.push(line);\r\n                    line = new InstructionLine();\r\n                }\r\n\r\n                line.tokens.push(token);\r\n\r\n                // first line defines a minimum indent\r\n                if (column === 0) {\r\n                    column = sColumn;\r\n                }\r\n\r\n                // stop looping through if line has less indent\r\n                // it means the corrent block finished\r\n                if (sColumn < column) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (line.tokens.length) {\r\n            lines.push(line)\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    private createExpressionNode(tokens: Token[], prevNode: AstNode | null = null): AstNode {\r\n        if (tokens.length === 0) {\r\n            throw new Error(`Tokens length can't empty.`)\r\n        }\r\n        const lastToken = tokens[tokens.length - 1];\r\n        if (getTokenValue(lastToken) === ';' && getTokenType(lastToken) !== TokenTypes.LiteralString) {\r\n            throw new Error(`Unexpected symbol ';' in the end`)\r\n        }\r\n\r\n        this._currentToken = tokens[0];\r\n\r\n        // const or variable\r\n        if (tokens.length === 1\r\n            || (tokens.length === 2 && getTokenValue(tokens[1]) === '?')\r\n        ) {\r\n            const firstToken = tokens[0];\r\n            const tokenType = getTokenType(firstToken);\r\n\r\n            if (isTokenTypeLiteral(tokenType)) {\r\n                return new ConstNode(firstToken);\r\n            } else if (tokenType === TokenTypes.Identifier) {\r\n                return new GetSingleVarNode(firstToken, tokens.length === 2 && getTokenValue(tokens[1]) === '?' || undefined);\r\n            }\r\n\r\n            throw Error(`Unhandled single token: '${JSON.stringify(firstToken)}'`);\r\n        }\r\n\r\n        // arrow function\r\n        const arrowFuncParts = splitTokens(tokens, '=>');\r\n        if (arrowFuncParts.length > 1) {\r\n            const pArray = getTokenValue(arrowFuncParts[0][0]) === '(' ?\r\n                arrowFuncParts[0].splice(1, arrowFuncParts[0].length - 2)\r\n                : arrowFuncParts[0];\r\n            const params = splitTokens(pArray, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n            const instructionLines = this.tokensToInstructionLines(arrowFuncParts[1], 0);\r\n            const funcAst = {\r\n                name: this._moduleName,\r\n                body: [] as AstNode[],\r\n                funcs: [] as AstNode[]\r\n            } as AstBlock;\r\n            this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n            return new ArrowFuncDefNode(funcAst, params, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // comparison operations\r\n        const comparissonIndexes = findOperators(tokens, OperationTypes.Comparison);\r\n        if (comparissonIndexes.length) {\r\n            return this.groupComparisonOperations(comparissonIndexes, tokens);\r\n        }\r\n\r\n        // create arithmetic expression\r\n        const ops = findOperators(tokens);\r\n        if (ops.length) {\r\n\r\n            let prevNode: AstNode | null = null;\r\n            for (let i = 0; i < ops.length; i++) {\r\n                const opIndex = ops[i];\r\n                const op = getTokenValue(tokens[opIndex]) as Operators;\r\n\r\n                let nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n                let nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n                if (nextOpIndex !== null && (nextOp === '*' || nextOp === '/')) {\r\n                    let rightNode: AstNode | null = null;\r\n                    // iterate through all continuous '*', '/' operations\r\n                    do {\r\n                        const nextOpIndex2 = i + 2 < ops.length ? ops[i + 2] : null;\r\n\r\n                        const leftSlice2 = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex);\r\n                        const rightSlice2 = this.sliceWithBrackets(tokens, nextOpIndex + 1, nextOpIndex2 || tokens.length);\r\n\r\n                        const left2 = this.createExpressionNode(leftSlice2);\r\n                        const right2 = this.createExpressionNode(rightSlice2);\r\n                        rightNode = new BinOpNode(left2, nextOp, right2, getTokenLoc(tokens[opIndex + 1]));\r\n\r\n                        i++;\r\n                        nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n                        nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n                    }\r\n                    while (nextOpIndex !== null && (nextOp === '*' || nextOp === '/'))\r\n\r\n                    // add up result\r\n                    if (prevNode === null) {\r\n                        const leftSlice = this.sliceWithBrackets(tokens, 0, opIndex);\r\n                        prevNode = this.createExpressionNode(leftSlice);\r\n                    }\r\n                    prevNode = new BinOpNode(prevNode, op as ExpressionOperators, rightNode, getTokenLoc(tokens[0]))\r\n\r\n                } else {\r\n                    const leftSlice = prevNode ? [] : this.sliceWithBrackets(tokens, 0, opIndex);\r\n                    const rightSlice = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex || tokens.length);\r\n                    const left: AstNode = prevNode || this.createExpressionNode(leftSlice, prevNode);\r\n                    const right = this.createExpressionNode(rightSlice);\r\n                    prevNode = new BinOpNode(left, op as ExpressionOperators, right, getTokenLoc(tokens[0]));\r\n                }\r\n            }\r\n\r\n            if (prevNode === null) {\r\n                throw Error(`Can't create node ...`)\r\n            }\r\n\r\n            return prevNode;\r\n        }\r\n\r\n        // create DotObjectAccessNode\r\n        const subObjects = splitTokens(tokens, '.');\r\n        if (subObjects.length > 1) {\r\n            return new DotObjectAccessNode(subObjects.map(tkns => this.createExpressionNode(tkns)), getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // create function call node\r\n        if (tokens.length > 2 && getTokenValue(tokens[1]) === '(') {\r\n\r\n            const isNullCoelsing = getTokenValue(tokens[tokens.length - 1]) === '?';\r\n            if (isNullCoelsing) {\r\n                // remove '?'\r\n                tokens.pop();\r\n            }\r\n            const name = getTokenValue(tokens[0]) as string;\r\n            const paramsTokensSlice = tokens.slice(2, tokens.length - 1);\r\n            const paramsTokens = splitTokens(paramsTokensSlice, ',')\r\n            const paramsNodes = paramsTokens.map(tkns => this.createExpressionNode(tkns));\r\n            const node = new FunctionCallNode(name, paramsNodes, getTokenLoc(tokens[0]));\r\n            node.nullCoelsing = isNullCoelsing || undefined;\r\n            return node;\r\n        }\r\n\r\n        // create Object Node\r\n        if (getTokenValue(tokens[0]) === '{' && getTokenValue(tokens[tokens.length - 1]) === '}') {\r\n            const keyValueTokens = splitTokens(tokens.splice(1, tokens.length - 2), ',');\r\n            const props = [] as ObjectPropertyInfo[];\r\n            for (let i = 0; i < keyValueTokens.length; i++) {\r\n                const keyValue = splitTokens(keyValueTokens[i], ':');\r\n                if (keyValue.length === 1) {\r\n                    const pInfo = {\r\n                        name: new ConstNode(keyValue[0][0]),\r\n                        value: this.createExpressionNode(keyValue[0])\r\n                    } as ObjectPropertyInfo;\r\n\r\n                    props.push(pInfo);\r\n                } else if (keyValue.length === 2) {\r\n\r\n                    let name: AstNode | null = null;\r\n                    const namePart = keyValue[0];\r\n\r\n                    if (namePart.length === 1) {\r\n                        name = new ConstNode(namePart[0]);\r\n                    } else if (getTokenValue(namePart[0]) === '['\r\n                        && getTokenValue(namePart[namePart.length - 1]) === ']') {\r\n                        name = this.createExpressionNode(namePart.slice(1, namePart.length - 1))\r\n                    } else {\r\n                        throw new Error(`Incorrect JSON. Can't resolve Key field. That should either constant or expression in []`)\r\n                    }\r\n\r\n                    const pInfo = {\r\n                        name,\r\n                        value: this.createExpressionNode(keyValue[1])\r\n                    } as ObjectPropertyInfo;\r\n\r\n                    props.push(pInfo);\r\n                } else {\r\n                    throw Error('Incorrect JSON')\r\n                }\r\n            }\r\n\r\n            return new CreateObjectNode(props, getTokenLoc(tokens[0]))\r\n        }\r\n\r\n        // create Array Node\r\n        if (getTokenValue(tokens[0]) === '[' && getTokenValue(tokens[tokens.length - 1]) === ']') {\r\n            const items = splitTokens(tokens.splice(1, tokens.length - 2), ',')\r\n                .map(tkns => this.createExpressionNode(tkns));\r\n\r\n            return new CreateArrayNode(items, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // bracket access object node\r\n        if (tokens.length > 2 && getTokenValue(tokens[1]) === '[') {\r\n            const name = getTokenValue(tokens[0]) as string;\r\n            const paramsTokensSlice = tokens.slice(2, tokens.length - 1);\r\n            const paramsNodes = this.createExpressionNode(paramsTokensSlice);\r\n            return new BracketObjectAccessNode(name, paramsNodes, false, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        throw Error(`Undefined node '${getTokenValue(tokens[0])}'.`);\r\n    }\r\n}\r\n","import { getTokenType, getTokenValue, Token, TokenTypes } from '../common';\r\n\r\nconst SeparatorsMap: Record<string, string[]> = {\r\n    '\\n': ['\\n'],\r\n    '=': ['=', '==', '=>'],\r\n\r\n    '+': ['+', '++', '+='],\r\n    '-': ['-', '--', '-='],\r\n    '*': ['*', '**', '*='],\r\n    '/': ['/', '//', '/='],\r\n\r\n    '.': ['.'],\r\n    '?': ['?'],\r\n    '!': ['!='],\r\n    ':': [':'],\r\n    ',': [','],\r\n\r\n    '>': ['>', '>='],\r\n    '<': ['<', '<=', '<>'],\r\n\r\n    '(': ['('],\r\n    ')': [')'],\r\n    '{': ['{'],\r\n    '}': ['}'],\r\n    '[': ['['],\r\n    ']': [']'],\r\n};\r\n\r\nconst Keywords: string[] = [\"async\", \"def\", \"for\", \"while\", \"if\", \"return\", \"in\"];\r\n\r\nexport class Tokenizer {\r\n    private _startLine = 1;\r\n    private _startColumn = 1;\r\n    private _currentLine = 1;\r\n    private _currentColumn = 1;\r\n    private _tokenText = '';\r\n    private _cursor = 0;\r\n    private _script = \"\";\r\n\r\n    private get tokenText(): string {\r\n        return this._tokenText;\r\n    }\r\n    private set tokenText(value: string) {\r\n        if (!this._tokenText && value) {\r\n            this._startLine = this._currentLine;\r\n            this._startColumn = this._currentColumn;\r\n        }\r\n        this._tokenText = value;\r\n    }\r\n\r\n    /**\r\n     * Splits script code into a tokens\r\n     * @param script A jsPython text\r\n     */\r\n    tokenize(script: string): Token[] {\r\n        if (!script || !script.length) { return []; }\r\n\r\n        script = script\r\n            .replace(new RegExp('\\t', 'g'), '  ') // replace all tabs with 2 spaces\r\n            .replace(new RegExp('\\r', 'g'), ''); // remove all \\r symbols\r\n        this._script = script;\r\n\r\n        this._cursor = 0;\r\n        this._startLine = 1;\r\n        this._startColumn = 1;\r\n        this._currentLine = 1;\r\n        this._currentColumn = 1;\r\n\r\n        const tokens: Token[] = [];\r\n\r\n        let first = true;\r\n        // handle initial spaces\r\n        while (script[this._cursor] === '\\n') {\r\n            this.incrementCursor();\r\n            if (first) {\r\n                this._currentLine++;\r\n                first = false;\r\n            }\r\n            this._currentColumn = 1;\r\n        }\r\n\r\n        do {\r\n            const symbol = script[this._cursor];\r\n\r\n            if (symbol == ' ' && this.tokenText.length !== 0) {\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n                continue;\r\n            } else if ((SeparatorsMap[symbol] !== undefined) && !this.isPartOfNumber(symbol, tokens)) {\r\n                // handle numbers with floating point e.g. 3.14\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n                this.tokenText = symbol;\r\n\r\n                const sepsMap = SeparatorsMap[symbol];\r\n\r\n                if (sepsMap.length >= 1) {\r\n                    // process longer operators\r\n                    while (sepsMap.includes(this.tokenText + script[this._cursor + 1])) {\r\n                        this.tokenText += script[this.incrementCursor()];\r\n                    }\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, false, TokenTypes.Operator);\r\n\r\n            } else if (symbol === '#') {\r\n\r\n                let first = true;\r\n                while (script[this.incrementCursor()] !== '\\n') {\r\n                    this.tokenText += script[this._cursor];\r\n\r\n                    // correct start column\r\n                    if (first) {\r\n                        first = false;\r\n                        this._startColumn = this._startColumn - 1\r\n                    }\r\n\r\n                    if (this._cursor + 1 >= script.length) break;\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.Comment);\r\n\r\n            } else if (symbol === '\"' || symbol === \"'\") {\r\n                // remember either it is single or double quote\r\n                const q = symbol;\r\n                // we are not expecting token to be added here.\r\n                // it should pass a failt to parser\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n\r\n                // handle \"\"\" comment \"\"\"\"\r\n                if (script[this._cursor + 1] === q && script[this._cursor + 2] === q) {\r\n                    const cLine = this._currentLine;\r\n                    const cColumn = this._currentColumn;\r\n                    this.incrementCursor(2);\r\n                    const passCond = true;\r\n                    while (passCond) {\r\n                        this.tokenText += script[this.incrementCursor()];\r\n                        if (this._cursor + 3 >= script.length\r\n                            || (script[this._cursor + 1] === q && script[this._cursor + 2] === q && script[this._cursor + 3] === q)) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    // a special case when multiline string\r\n                    this._startLine = cLine;\r\n                    this._startColumn = cColumn;\r\n\r\n                    this.incrementCursor(3);\r\n                } else {\r\n                    while (script[this.incrementCursor()] !== q) {\r\n                        this.tokenText += script[this._cursor];\r\n                        if (this._cursor + 1 >= script.length) break;\r\n                    }\r\n\r\n                    //start column needs to take into account a begining quote, not just a string\r\n                    this._startColumn--;\r\n                }\r\n\r\n                // a special case when empty string\r\n                if (this.tokenText.length === 0) {\r\n                    this._startLine = this._currentLine;\r\n                    this._startColumn = this._currentColumn;\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.LiteralString);\r\n            } else if (symbol != ' ') {\r\n                this.tokenText += symbol;\r\n            }\r\n        }\r\n        while (this.incrementCursor() < script.length)\r\n\r\n        this.processToken(this.tokenText, tokens);\r\n\r\n        return tokens;\r\n    }\r\n\r\n    private incrementCursor(count = 1): number {\r\n        for (let i = 0; i < count; i++) {\r\n            this._cursor = this._cursor + 1;\r\n            if (this._script[this._cursor] === '\\n') {\r\n                this._currentLine++;\r\n                this._currentColumn = 0;\r\n            } else {\r\n                this._currentColumn++;\r\n            }\r\n        }\r\n\r\n        return this._cursor;\r\n    }\r\n\r\n    private recognizeToken(tokenText: string, type: TokenTypes | null = null): { value: string | number | boolean | null, type: TokenTypes } {\r\n\r\n        let value: string | number | boolean | null = tokenText;\r\n\r\n        if (type === null) {\r\n            if (tokenText === 'null') {\r\n                type = TokenTypes.LiteralNull;\r\n                value = null;\r\n            } else if (tokenText === 'true' || tokenText === 'false') {\r\n                type = TokenTypes.LiteralBool;\r\n                value = tokenText === 'true';\r\n            } else if (this.parseNumberOrNull(tokenText) !== null) {\r\n                type = TokenTypes.LiteralNumber;\r\n                value = this.parseNumberOrNull(tokenText);\r\n            } else if (Keywords.indexOf(tokenText) >= 0) {\r\n                type = TokenTypes.Keyword;\r\n            } else {\r\n                type = TokenTypes.Identifier\r\n            }\r\n        }\r\n\r\n        return {\r\n            value: value,\r\n            type: type\r\n        }\r\n\r\n    }\r\n\r\n    private processToken(strToken: string, tokens: Token[], allowEmptyString = false, type: TokenTypes | null = null): string {\r\n        // ignore empty tokens\r\n        if (!strToken.length && !allowEmptyString || strToken === '\\n') return \"\";\r\n\r\n        const token = this.recognizeToken(strToken, type);\r\n        tokens.push([token.value, Uint16Array.of(token.type as number,\r\n            this._startLine, this._startColumn,\r\n            this._currentLine, this._currentColumn)] as Token)\r\n        return \"\";\r\n    }\r\n\r\n    private parseNumberOrNull(value: string | number): number | null {\r\n        if (typeof value === 'number') {\r\n            return value;\r\n        }\r\n\r\n        if (!value || typeof value !== 'string') {\r\n            return null;\r\n        }\r\n\r\n        value = value.trim();\r\n\r\n        // Just to make sure string contains digits only and '.', ','. Otherwise, parseFloat can incorrectly parse into number\r\n        for (let i = value.length - 1; i >= 0; i--) {\r\n            const d = value.charCodeAt(i);\r\n            if (d < 48 || d > 57) {\r\n                // '.' - 46 ',' - 44 '-' - 45(but only first char)\r\n                if (d !== 46 && d !== 44 && (d !== 45 || i !== 0))\r\n                    return null;\r\n            }\r\n        }\r\n\r\n        const res = parseFloat(value);\r\n        return !isNaN(res) ? res : null;\r\n    }\r\n\r\n    private isPartOfNumber(symbol: string, currentTokens: Token[]): boolean {\r\n        if (symbol === '-' && !this.tokenText.length) {\r\n            // '-' needs to be handled e.g. -3; 2 + -2 etc\r\n            const prevToken = (currentTokens.length !== 0) ? currentTokens[currentTokens.length - 1] : null;\r\n            return prevToken === null || (getTokenType(prevToken) === TokenTypes.Operator && getTokenValue(prevToken) !== ')');\r\n        } else if (symbol === '.' && this.parseNumberOrNull(this.tokenText) !== null) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}","import { AstBlock, ImportNode, Token } from './common';\r\nimport { getImportType } from './common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { EvaluatorAsync } from './evaluator/evaluatorAsync';\r\nimport { BlockContext, Scope } from './evaluator/scope';\r\nimport { INITIAL_SCOPE, PackageToImport } from './initialScope';\r\nimport { Parser } from './parser';\r\nimport { Tokenizer } from './tokenizer';\r\n\r\nexport type PackageLoader = (packageName: string) => any;\r\nexport type ModuleLoader = (filePath: string) => Promise<string>;\r\n\r\nexport function jsPython(): Interpreter {\r\n    return Interpreter.create();\r\n}\r\n\r\nexport class Interpreter {\r\n    private readonly initialScope: Record<string, unknown> = { ...INITIAL_SCOPE };\r\n\r\n    private _lastExecutionContext: Record<string, unknown> | null = null;\r\n\r\n    private packageLoader?: PackageLoader;\r\n    private moduleLoader?: ModuleLoader;\r\n\r\n    constructor() { }\r\n\r\n    static create(): Interpreter {\r\n        return new Interpreter();\r\n    }\r\n\r\n    get initialExecutionContext(): Record<string, unknown> {\r\n        return this.initialScope;\r\n    }\r\n\r\n    get lastExecutionContext(): Record<string, unknown> | null {\r\n        return this._lastExecutionContext;\r\n    }\r\n\r\n    cleanUp(): void {\r\n        this._lastExecutionContext = null;\r\n    }\r\n\r\n    jsPythonInfo(): string {\r\n        return INITIAL_SCOPE.jsPython();\r\n    }\r\n\r\n    tokenize(script: string): Token[] {\r\n        const tokenizer = new Tokenizer();\r\n        return tokenizer.tokenize(script);\r\n    }\r\n\r\n    parse(script: string, moduleName: string = 'main.jspy'): AstBlock {\r\n        const tokenizer = new Tokenizer();\r\n        const parser = new Parser();\r\n        const jspyAst = parser.parse(tokenizer.tokenize(script), moduleName);\r\n        return jspyAst;\r\n    }\r\n\r\n    eval(codeOrAst: string | AstBlock, scope: Record<string, unknown> = {}\r\n        , entryFunctionName: string = '', moduleName: string = 'main.jspy'): unknown {\r\n        const ast = (typeof codeOrAst === 'string') ? this.parse(codeOrAst as string, moduleName) : codeOrAst as AstBlock;\r\n\r\n        const blockContext = {\r\n            moduleName: moduleName,\r\n            blockScope: new Scope(scope)\r\n        } as BlockContext;\r\n\r\n        blockContext.blockScope.set('printExecutionContext', () => console.log(blockContext.blockScope.getScope()));\r\n        blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n        this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n        const result = new Evaluator().evalBlock(ast, blockContext);\r\n        if (!entryFunctionName || !entryFunctionName.length) {\r\n            return result;\r\n        } else {\r\n            const func = blockContext.blockScope.get(entryFunctionName);\r\n            if (typeof func !== 'function') {\r\n                throw Error(`Function ${entryFunctionName} does not exists or not a function`)\r\n            }\r\n            return func();\r\n        }\r\n    }\r\n\r\n    async evalAsync(codeOrAst: string | AstBlock, scope: Record<string, unknown> = {}\r\n        , entryFunctionName: string = '', moduleName: string = 'main.jspy'): Promise<unknown> {\r\n        const ast = (typeof codeOrAst === 'string') ? this.parse(codeOrAst as string, moduleName) : codeOrAst as AstBlock;\r\n        const evaluator = new EvaluatorAsync();\r\n        const blockContext = {\r\n            moduleName: moduleName,\r\n            blockScope: new Scope(scope)\r\n        } as BlockContext;\r\n\r\n        blockContext.blockScope.set('printExecutionContext', () => console.log(blockContext.blockScope.getScope()));\r\n        blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n        this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n        const result = await evaluator\r\n            .registerJsonFileLoader(async (modulePath: string) =>\r\n                await (this.moduleLoader ? this.moduleLoader(modulePath)\r\n                    : Promise.reject('ModuleLoader is not registered')\r\n                )\r\n            )\r\n            .registerModuleParser(async (modulePath) => await this.moduleParser(modulePath))\r\n            .registerBlockContextFactory((moduleName, ast: AstBlock) => {\r\n                // this line will not be required when we have move package loaders to the evaluator\r\n                const newContext = this.assignLegacyImportContext(ast, scope);\r\n\r\n                const moduleContext = { moduleName, blockScope: new Scope(newContext) }\r\n                moduleContext.blockScope.set('printExecutionContext', () => console.log(moduleContext.blockScope.getScope()));\r\n                moduleContext.blockScope.set('getExecutionContext', () => moduleContext.blockScope.getScope());\r\n                return moduleContext;\r\n            })\r\n            .evalBlockAsync(ast, blockContext);\r\n\r\n        if (!entryFunctionName || !entryFunctionName.length) {\r\n            return result;\r\n        } else {\r\n            const func = blockContext.blockScope.get(entryFunctionName);\r\n            if (typeof func !== 'function') {\r\n                throw Error(`Function ${entryFunctionName} does not exists or not a function`)\r\n            }\r\n            return await func();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compatibility method! Will be deprecated soon\r\n     */\r\n    async evaluate(script: string, context: object = {}, entryFunctionName: string = ''\r\n        , moduleName: string = 'main.jspy'): Promise<any> {\r\n        if (!script || !script.length) { return null; }\r\n        const ast = this.parse(script, moduleName);\r\n\r\n        context = (context && typeof context === 'object') ? context : {};\r\n        context = this.assignLegacyImportContext(ast, context);\r\n\r\n        const globalScope = {\r\n            ...this.initialScope,\r\n            ...context\r\n        } as Record<string, unknown>;\r\n\r\n        return await this.evalAsync(ast, globalScope, entryFunctionName, moduleName);\r\n    }\r\n\r\n    registerPackagesLoader(loader: PackageLoader): Interpreter {\r\n        if (typeof loader === 'function') {\r\n            this.packageLoader = loader;\r\n        } else {\r\n            throw Error('PackagesLoader');\r\n        }\r\n        return this;\r\n    }\r\n\r\n    registerModuleLoader(loader: ModuleLoader): Interpreter {\r\n        if (typeof loader === 'function') {\r\n            this.moduleLoader = loader;\r\n        } else {\r\n            throw Error('ModuleLoader should be a function');\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    addFunction(funcName: string, fn: (...args: any[]) => void | any | Promise<any>): Interpreter {\r\n        this.initialScope[funcName] = fn;\r\n        return this;\r\n    }\r\n\r\n    assignGlobalContext(obj: object): Interpreter {\r\n        Object.assign(this.initialScope, obj);\r\n        return this;\r\n    }\r\n\r\n    hasFunction(scripts: string = '', funcName: string): boolean {\r\n        return scripts.indexOf(`def ${funcName}`) > -1;\r\n    }\r\n\r\n    private assignLegacyImportContext(ast: AstBlock, context: object): Record<string, unknown> {\r\n\r\n        const nodeToPackage = (im: ImportNode): PackageToImport => {\r\n            return {\r\n                name: im.module.name,\r\n                as: im.module.alias,\r\n                properties: im.parts?.map(p => ({ name: p.name, as: p.alias }))\r\n            } as PackageToImport\r\n        }\r\n\r\n        const importNodes = ast.body.filter(n => n.type === 'import') as ImportNode[];\r\n\r\n        const jsImport = importNodes\r\n            .filter(im => getImportType(im.module.name) === 'jsPackage')\r\n            .map(im => nodeToPackage(im));\r\n\r\n        if (jsImport.length && this.packageLoader) {\r\n            const libraries = this.packageResolver(jsImport);\r\n            context = { ...context, ...libraries };\r\n        }\r\n\r\n        return context as Record<string, unknown>;\r\n    }\r\n\r\n    private async moduleParser(modulePath: string): Promise<AstBlock> {\r\n        if (!this.moduleLoader) {\r\n            throw new Error('Module Loader is not registered')\r\n        }\r\n\r\n        const content = await this.moduleLoader(modulePath);\r\n        return this.parse(content, modulePath);\r\n    }\r\n\r\n    private packageResolver(packages: PackageToImport[]): object {\r\n        if (!this.packageLoader) {\r\n            throw Error('Package loader not provided.');\r\n        }\r\n        const libraries: any = {};\r\n        packages.forEach(({ name, as, properties }: PackageToImport) => {\r\n            const lib = this.packageLoader && this.packageLoader(name);\r\n            if (properties?.length) {\r\n                properties.forEach((prop) => {\r\n                    libraries[prop.as || prop.name] = lib[prop.name];\r\n                })\r\n            } else if (as) {\r\n                libraries[as] = lib;\r\n            } else {\r\n                libraries[name] = lib;\r\n            }\r\n            if (as) {\r\n                libraries[as] = lib;\r\n            }\r\n        });\r\n        return libraries;\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}