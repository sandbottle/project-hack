/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}function parseDatetimeOrNull(value) {
    if (!value) {
        return null;
    }
    if (value instanceof Date && !isNaN(value.valueOf())) {
        return value;
    }
    // only string values can be converted to Date
    if (typeof value !== 'string') {
        return null;
    }
    var strValue = String(value);
    if (!strValue.length) {
        return null;
    }
    var parseMonth = function (mm) {
        if (!mm || !mm.length) {
            return NaN;
        }
        var m = parseInt(mm, 10);
        if (!isNaN(m)) {
            return m - 1;
        }
        // make sure english months are coming through
        if (mm.startsWith('jan')) {
            return 0;
        }
        if (mm.startsWith('feb')) {
            return 1;
        }
        if (mm.startsWith('mar')) {
            return 2;
        }
        if (mm.startsWith('apr')) {
            return 3;
        }
        if (mm.startsWith('may')) {
            return 4;
        }
        if (mm.startsWith('jun')) {
            return 5;
        }
        if (mm.startsWith('jul')) {
            return 6;
        }
        if (mm.startsWith('aug')) {
            return 7;
        }
        if (mm.startsWith('sep')) {
            return 8;
        }
        if (mm.startsWith('oct')) {
            return 9;
        }
        if (mm.startsWith('nov')) {
            return 10;
        }
        if (mm.startsWith('dec')) {
            return 11;
        }
        return NaN;
    };
    var correctYear = function (yy) {
        if (yy < 100) {
            return yy < 68 ? yy + 2000 : yy + 1900;
        }
        else {
            return yy;
        }
    };
    var validDateOrNull = function (yyyy, month, day, hours, mins, ss) {
        if (month > 11 || day > 31 || hours >= 60 || mins >= 60 || ss >= 60) {
            return null;
        }
        var dd = new Date(yyyy, month, day, hours, mins, ss, 0);
        return !isNaN(dd.valueOf()) ? dd : null;
    };
    var strTokens = strValue.replace('T', ' ').toLowerCase().split(/[: /-]/);
    var dt = strTokens.map(parseFloat);
    // try ISO first
    var d = validDateOrNull(dt[0], dt[1] - 1, dt[2], dt[3] || 0, dt[4] || 0, dt[5] || 0);
    if (d) {
        return d;
    }
    // then UK
    d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[1]), dt[0], dt[3] || 0, dt[4] || 0, dt[5] || 0);
    if (d) {
        return d;
    }
    // then US
    d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[0]), correctYear(dt[1]), dt[3] || 0, dt[4] || 0, dt[5] || 0);
    if (d) {
        return d;
    }
    return null;
}
function getImportType(name) {
    if (name.startsWith('/') || name.startsWith('./')) {
        return (name.endsWith('.json')) ? 'json' : 'jspyModule';
    }
    return 'jsPackage';
}
function jspyErrorMessage(error, module, line, column, message) {
    return error + ": " + module + "(" + line + "," + column + "): " + message;
}
/** @class */ ((function (_super) {
    __extends(JspyTokenizerError, _super);
    function JspyTokenizerError(module, line, column, message) {
        var _this = _super.call(this) || this;
        _this.module = module;
        _this.line = line;
        _this.column = column;
        _this.message = message;
        _this.message = jspyErrorMessage("JspyTokenizerError", module, line, column, message);
        Object.setPrototypeOf(_this, JspyTokenizerError.prototype);
        return _this;
    }
    return JspyTokenizerError;
})(Error));
var JspyParserError = /** @class */ (function (_super) {
    __extends(JspyParserError, _super);
    function JspyParserError(module, line, column, message) {
        var _this = _super.call(this) || this;
        _this.module = module;
        _this.line = line;
        _this.column = column;
        _this.message = message;
        _this.message = jspyErrorMessage("JspyParserError", module, line, column, message);
        Object.setPrototypeOf(_this, JspyParserError.prototype);
        return _this;
    }
    return JspyParserError;
}(Error));
var JspyEvalError = /** @class */ (function (_super) {
    __extends(JspyEvalError, _super);
    function JspyEvalError(module, line, column, message) {
        var _this = _super.call(this) || this;
        _this.module = module;
        _this.line = line;
        _this.column = column;
        _this.message = message;
        _this.message = jspyErrorMessage("JspyEvalError", module, line, column, message);
        Object.setPrototypeOf(_this, JspyEvalError.prototype);
        return _this;
    }
    return JspyEvalError;
}(Error));
var JspyError = /** @class */ (function (_super) {
    __extends(JspyError, _super);
    function JspyError(module, line, column, name, message) {
        var _this = _super.call(this) || this;
        _this.module = module;
        _this.line = line;
        _this.column = column;
        _this.name = name;
        _this.message = message;
        _this.message = jspyErrorMessage("JspyError", module || 'name.jspy', line, column, message);
        Object.setPrototypeOf(_this, JspyError.prototype);
        return _this;
    }
    return JspyError;
}(Error));var OperationTypes;
(function (OperationTypes) {
    OperationTypes[OperationTypes["Arithmetic"] = 0] = "Arithmetic";
    OperationTypes[OperationTypes["Assignment"] = 1] = "Assignment";
    OperationTypes[OperationTypes["Comparison"] = 2] = "Comparison";
    OperationTypes[OperationTypes["Logical"] = 3] = "Logical";
    OperationTypes[OperationTypes["Membership"] = 4] = "Membership";
})(OperationTypes || (OperationTypes = {}));
var OperatorsMap = {
    "+": OperationTypes.Arithmetic,
    "-": OperationTypes.Arithmetic,
    "*": OperationTypes.Arithmetic,
    "/": OperationTypes.Arithmetic,
    "%": OperationTypes.Arithmetic,
    "**": OperationTypes.Arithmetic,
    "//": OperationTypes.Arithmetic,
    ">": OperationTypes.Comparison,
    ">=": OperationTypes.Comparison,
    "==": OperationTypes.Comparison,
    "!=": OperationTypes.Comparison,
    "<>": OperationTypes.Comparison,
    "<": OperationTypes.Comparison,
    "<=": OperationTypes.Comparison,
    "and": OperationTypes.Logical,
    "or": OperationTypes.Logical,
    // "not": OperationTypes.Logical,
    // "not in": OperationTypes.Logical,
    "in": OperationTypes.Membership,
    "=": OperationTypes.Assignment,
    "+=": OperationTypes.Assignment,
    "-=": OperationTypes.Assignment,
    "*=": OperationTypes.Assignment,
    "/=": OperationTypes.Assignment,
    "++": OperationTypes.Assignment,
    "--": OperationTypes.Assignment,
};
var OperationFuncs = {
    "+": function (l, r) { return arithmeticOperation(l, r, "+"); },
    "-": function (l, r) { return arithmeticOperation(l, r, "-"); },
    "/": function (l, r) { return arithmeticOperation(l, r, "/"); },
    "*": function (l, r) { return arithmeticOperation(l, r, "*"); },
    "%": function (l, r) { return arithmeticOperation(l, r, "%"); },
    "**": function (l, r) { return arithmeticOperation(l, r, "**"); },
    "//": function (l, r) { return arithmeticOperation(l, r, "//"); },
    ">": function (l, r) { return comparissonOperation(l, r, ">"); },
    ">=": function (l, r) { return comparissonOperation(l, r, ">="); },
    "<": function (l, r) { return comparissonOperation(l, r, "<"); },
    "<=": function (l, r) { return comparissonOperation(l, r, "<="); },
    "==": function (l, r) { return comparissonOperation(l, r, "=="); },
    "!=": function (l, r) { return comparissonOperation(l, r, "!="); },
    "<>": function (l, r) { return comparissonOperation(l, r, "<>"); },
    "and": function (l, r) { return logicalOperation(l, r, "and"); },
    "or": function (l, r) { return logicalOperation(l, r, "or"); },
    // "not": (l, r) => logicalOperation(l, r, "not"),
    // "not in": (l, r) => logicalOperation(l, r, "not in"),
    "in": function (l, r) { return membershipOperation(l, r, "in"); }
};
function membershipOperation(l, r, op) {
    if (typeof l === 'string') {
        return l.includes(String(r));
    }
    if (Array.isArray(l)) {
        return l.includes(r);
    }
    throw new Error("Unknown operation '" + op + "'");
}
function logicalOperation(l, r, op) {
    switch (op) {
        case 'and':
            return l && r;
        case 'or':
            return l || r;
    }
    throw new Error("Unknown operation '" + op + "'");
}
function comparissonOperation(l, r, op) {
    switch (op) {
        case '==':
            return l === r;
        case '!=':
            return l !== r;
        case '<>':
            return l !== r;
        case '>':
            return l > r;
        case '<':
            return l < r;
        case '>=':
            return l >= r;
        case '<=':
            return l <= r;
    }
    throw new Error("Unknown operation '" + op + "'");
}
function arithmeticOperation(l, r, op) {
    switch (op) {
        case '+':
            return l + r;
        case '-':
            return l - r;
        case '*':
            return l * r;
        case '/':
            return l / r;
        case '%':
            return l % r;
        case '**':
            return Math.pow(l, r);
    }
    throw new Error("Unknown operation '" + op + "'");
}var TokenTypes;
(function (TokenTypes) {
    TokenTypes[TokenTypes["Identifier"] = 0] = "Identifier";
    TokenTypes[TokenTypes["Keyword"] = 1] = "Keyword";
    TokenTypes[TokenTypes["Separator"] = 2] = "Separator";
    TokenTypes[TokenTypes["Operator"] = 3] = "Operator";
    TokenTypes[TokenTypes["LiteralNumber"] = 4] = "LiteralNumber";
    TokenTypes[TokenTypes["LiteralBool"] = 5] = "LiteralBool";
    TokenTypes[TokenTypes["LiteralString"] = 6] = "LiteralString";
    TokenTypes[TokenTypes["LiteralNull"] = 7] = "LiteralNull";
    TokenTypes[TokenTypes["Comment"] = 8] = "Comment";
})(TokenTypes || (TokenTypes = {}));
function isTokenTypeLiteral(tokenType) {
    return tokenType === TokenTypes.LiteralString
        || tokenType === TokenTypes.LiteralNumber
        || tokenType === TokenTypes.LiteralBool
        || tokenType === TokenTypes.LiteralNull;
}
function getTokenType(token) {
    return token[1][0];
}
function getTokenValue(token) {
    return token ? token[0] : null;
}
function getTokenLoc(token) {
    return token[1].subarray(1);
}
function getStartLine(token) {
    return token[1][1];
}
function getStartColumn(token) {
    return token[1][2];
}
function getEndLine(token) {
    return token[1][3];
}
function getEndColumn(token) {
    return token[1][4];
}
function splitTokens(tokens, separator) {
    var result = [];
    if (!tokens.length) {
        return [];
    }
    var sepIndexes = findTokenValueIndexes(tokens, function (value) { return value === separator; });
    var start = 0;
    for (var i = 0; i < sepIndexes.length; i++) {
        var ind = sepIndexes[i];
        result.push(tokens.slice(start, ind));
        start = ind + 1;
    }
    result.push(tokens.slice(start, tokens.length));
    return result;
}
function findTokenValueIndex(tokens, predicate, start) {
    if (start === void 0) { start = 0; }
    for (var i = start; i < tokens.length; i++) {
        if (getTokenType(tokens[i]) === TokenTypes.LiteralString) {
            continue;
        }
        if (getTokenValue(tokens[i]) === '(') {
            i = skipInnerBrackets(tokens, i, '(', ')');
        }
        else if (getTokenValue(tokens[i]) === '[') {
            i = skipInnerBrackets(tokens, i, '[', ']');
        }
        else if (getTokenValue(tokens[i]) === '{') {
            i = skipInnerBrackets(tokens, i, '{', '}');
        }
        else if (predicate(getTokenValue(tokens[i]))) {
            return i;
        }
    }
    return -1;
}
function findTokenValueIndexes(tokens, predicate) {
    var opIndexes = [];
    for (var i = 0; i < tokens.length; i++) {
        var tValue = getTokenValue(tokens[i]);
        var tType = getTokenType(tokens[i]);
        if (tType === TokenTypes.LiteralString) {
            continue;
        }
        if (tValue === '(') {
            i = skipInnerBrackets(tokens, i, '(', ')');
        }
        else if (tValue === '[') {
            i = skipInnerBrackets(tokens, i, '[', ']');
        }
        else if (tValue === '{') {
            i = skipInnerBrackets(tokens, i, '{', '}');
        }
        else if (predicate(tValue)) {
            opIndexes.push(i);
        }
    }
    return opIndexes;
}
function findOperators(tokens, operationType) {
    if (operationType === void 0) { operationType = null; }
    return !operationType ? findTokenValueIndexes(tokens, function (value) { return OperatorsMap[value] !== undefined; })
        :
            findTokenValueIndexes(tokens, function (value) { return OperatorsMap[value] === operationType; });
}
function skipInnerBrackets(tokens, i, openChar, closeChar) {
    var innerBrackets = 0;
    while (getTokenValue(tokens[++i]) !== closeChar || innerBrackets !== 0) {
        if (i + 1 >= tokens.length) {
            throw new Error("Closing '" + closeChar + "' is missing");
        }
        var tokenValue = getTokenValue(tokens[i]);
        if (tokenValue === openChar) {
            innerBrackets++;
        }
        if (tokenValue === closeChar) {
            innerBrackets--;
        }
    }
    return i;
}var AstNode = /** @class */ (function () {
    function AstNode(type) {
        this.type = type;
        this.loc = undefined;
    }
    return AstNode;
}());
var AssignNode = /** @class */ (function (_super) {
    __extends(AssignNode, _super);
    function AssignNode(target, source, loc) {
        var _this = _super.call(this, 'assign') || this;
        _this.target = target;
        _this.source = source;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return AssignNode;
}(AstNode));
var ConstNode = /** @class */ (function (_super) {
    __extends(ConstNode, _super);
    function ConstNode(token) {
        var _this = _super.call(this, 'const') || this;
        _this.value = getTokenValue(token);
        _this.loc = getTokenLoc(token);
        return _this;
    }
    return ConstNode;
}(AstNode));
var CommentNode = /** @class */ (function (_super) {
    __extends(CommentNode, _super);
    function CommentNode(comment, loc) {
        var _this = _super.call(this, 'comment') || this;
        _this.comment = comment;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return CommentNode;
}(AstNode));
var ReturnNode = /** @class */ (function (_super) {
    __extends(ReturnNode, _super);
    function ReturnNode(returnValue, loc) {
        if (returnValue === void 0) { returnValue = undefined; }
        var _this = _super.call(this, 'return') || this;
        _this.returnValue = returnValue;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return ReturnNode;
}(AstNode));
var RaiseNode = /** @class */ (function (_super) {
    __extends(RaiseNode, _super);
    function RaiseNode(errorName, errorMessage, loc) {
        var _this = _super.call(this, 'raise') || this;
        _this.errorName = errorName;
        _this.errorMessage = errorMessage;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return RaiseNode;
}(AstNode));
var ContinueNode = /** @class */ (function (_super) {
    __extends(ContinueNode, _super);
    function ContinueNode() {
        return _super.call(this, 'continue') || this;
    }
    return ContinueNode;
}(AstNode));
var BreakNode = /** @class */ (function (_super) {
    __extends(BreakNode, _super);
    function BreakNode() {
        return _super.call(this, 'break') || this;
    }
    return BreakNode;
}(AstNode));
/** @class */ ((function (_super) {
    __extends(SetSingleVarNode, _super);
    function SetSingleVarNode(token) {
        var _this = _super.call(this, 'setSingleVar') || this;
        _this.name = token[0];
        _this.loc = getTokenLoc(token);
        return _this;
    }
    return SetSingleVarNode;
})(AstNode));
var FunctionCallNode = /** @class */ (function (_super) {
    __extends(FunctionCallNode, _super);
    function FunctionCallNode(name, paramNodes, loc) {
        var _this = _super.call(this, 'funcCall') || this;
        _this.name = name;
        _this.paramNodes = paramNodes;
        _this.loc = loc;
        _this.nullCoelsing = undefined;
        _this.loc = loc;
        return _this;
    }
    return FunctionCallNode;
}(AstNode));
var FunctionDefNode = /** @class */ (function (_super) {
    __extends(FunctionDefNode, _super);
    function FunctionDefNode(funcAst, params, isAsync, loc) {
        var _this = _super.call(this, 'funcDef') || this;
        _this.funcAst = funcAst;
        _this.params = params;
        _this.isAsync = isAsync;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return FunctionDefNode;
}(AstNode));
var ArrowFuncDefNode = /** @class */ (function (_super) {
    __extends(ArrowFuncDefNode, _super);
    function ArrowFuncDefNode(funcAst, params, loc) {
        var _this = _super.call(this, 'arrowFuncDef') || this;
        _this.funcAst = funcAst;
        _this.params = params;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return ArrowFuncDefNode;
}(AstNode));
var IfNode = /** @class */ (function (_super) {
    __extends(IfNode, _super);
    function IfNode(conditionNode, ifBody, elseBody, loc) {
        if (elseBody === void 0) { elseBody = undefined; }
        var _this = _super.call(this, 'if') || this;
        _this.conditionNode = conditionNode;
        _this.ifBody = ifBody;
        _this.elseBody = elseBody;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return IfNode;
}(AstNode));
var TryExceptNode = /** @class */ (function (_super) {
    __extends(TryExceptNode, _super);
    function TryExceptNode(tryBody, exepts, elseBody, finallyBody, loc) {
        var _this = _super.call(this, 'tryExcept') || this;
        _this.tryBody = tryBody;
        _this.exepts = exepts;
        _this.elseBody = elseBody;
        _this.finallyBody = finallyBody;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return TryExceptNode;
}(AstNode));
var ForNode = /** @class */ (function (_super) {
    __extends(ForNode, _super);
    function ForNode(sourceArray, itemVarName, body, loc) {
        var _this = _super.call(this, 'for') || this;
        _this.sourceArray = sourceArray;
        _this.itemVarName = itemVarName;
        _this.body = body;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return ForNode;
}(AstNode));
var WhileNode = /** @class */ (function (_super) {
    __extends(WhileNode, _super);
    function WhileNode(condition, body, loc) {
        var _this = _super.call(this, 'while') || this;
        _this.condition = condition;
        _this.body = body;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return WhileNode;
}(AstNode));
var ImportNode = /** @class */ (function (_super) {
    __extends(ImportNode, _super);
    function ImportNode(module, body, parts, loc) {
        if (parts === void 0) { parts = undefined; }
        var _this = _super.call(this, 'import') || this;
        _this.module = module;
        _this.body = body;
        _this.parts = parts;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return ImportNode;
}(AstNode));
var GetSingleVarNode = /** @class */ (function (_super) {
    __extends(GetSingleVarNode, _super);
    function GetSingleVarNode(token, nullCoelsing) {
        if (nullCoelsing === void 0) { nullCoelsing = undefined; }
        var _this = _super.call(this, 'getSingleVar') || this;
        _this.nullCoelsing = undefined;
        _this.name = token[0];
        _this.nullCoelsing = nullCoelsing;
        _this.loc = getTokenLoc(token);
        return _this;
    }
    return GetSingleVarNode;
}(AstNode));
var DotObjectAccessNode = /** @class */ (function (_super) {
    __extends(DotObjectAccessNode, _super);
    function DotObjectAccessNode(nestedProps, loc) {
        var _this = _super.call(this, 'dotObjectAccess') || this;
        _this.nestedProps = nestedProps;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return DotObjectAccessNode;
}(AstNode));
var CreateObjectNode = /** @class */ (function (_super) {
    __extends(CreateObjectNode, _super);
    function CreateObjectNode(props, loc) {
        var _this = _super.call(this, 'createObject') || this;
        _this.props = props;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return CreateObjectNode;
}(AstNode));
var CreateArrayNode = /** @class */ (function (_super) {
    __extends(CreateArrayNode, _super);
    function CreateArrayNode(items, loc) {
        var _this = _super.call(this, 'createArray') || this;
        _this.items = items;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return CreateArrayNode;
}(AstNode));
var BracketObjectAccessNode = /** @class */ (function (_super) {
    __extends(BracketObjectAccessNode, _super);
    function BracketObjectAccessNode(propertyName, bracketBody, nullCoalescing, loc) {
        if (nullCoalescing === void 0) { nullCoalescing = undefined; }
        var _this = _super.call(this, 'bracketObjectAccess') || this;
        _this.propertyName = propertyName;
        _this.bracketBody = bracketBody;
        _this.nullCoalescing = nullCoalescing;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return BracketObjectAccessNode;
}(AstNode));
var LogicalOpNode = /** @class */ (function (_super) {
    __extends(LogicalOpNode, _super);
    function LogicalOpNode(items, loc) {
        var _this = _super.call(this, 'logicalOp') || this;
        _this.items = items;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return LogicalOpNode;
}(AstNode));
var BinOpNode = /** @class */ (function (_super) {
    __extends(BinOpNode, _super);
    function BinOpNode(left, op, right, loc) {
        var _this = _super.call(this, 'binOp') || this;
        _this.left = left;
        _this.op = op;
        _this.right = right;
        _this.loc = loc;
        _this.loc = loc;
        return _this;
    }
    return BinOpNode;
}(AstNode));function cloneContext(context) {
    return {
        moduleName: context.moduleName,
        blockScope: context.blockScope.clone()
    };
}
var Scope = /** @class */ (function () {
    function Scope(initialScope) {
        this.scope = {};
        this.scope = __assign({}, initialScope);
    }
    Scope.prototype.getScope = function () {
        return this.scope;
    };
    Scope.prototype.clone = function () {
        return new Scope(this.scope);
    };
    Scope.prototype.set = function (key, value, path) {
        this.scope[key] = value;
    };
    Scope.prototype.get = function (key, path) {
        return this.scope[key];
    };
    return Scope;
}());var Evaluator = /** @class */ (function () {
    function Evaluator() {
    }
    Evaluator.prototype.evalBlock = function (ast, blockContext) {
        var _this = this;
        var lastResult = null;
        var _loop_1 = function (node) {
            var funcDef = node;
            // a child scope needs to be created here
            var newScope = blockContext.blockScope;
            newScope.set(funcDef.funcAst.name, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.jspyFuncInvoker.apply(_this, __spreadArray([funcDef, blockContext], args));
            });
        };
        for (var _i = 0, _a = (ast === null || ast === void 0 ? void 0 : ast.funcs) || []; _i < _a.length; _i++) {
            var node = _a[_i];
            _loop_1(node);
        }
        for (var _b = 0, _c = ast.body; _b < _c.length; _b++) {
            var node = _c[_b];
            if (node.type === 'comment') {
                continue;
            }
            if (node.type === 'import') {
                // we can't use it here, because loader has to be promise
                throw new Error("Import is not support with 'eval'. Use method 'evalAsync' instead");
            }
            try {
                lastResult = this.evalNode(node, blockContext);
                if (blockContext.returnCalled) {
                    var res = blockContext.returnObject;
                    // stop processing return
                    if (ast.type == 'func' || ast.type == 'module') {
                        blockContext.returnCalled = false;
                        blockContext.returnObject = null;
                    }
                    return res;
                }
                if (blockContext.continueCalled) {
                    break;
                }
                if (blockContext.breakCalled) {
                    break;
                }
            }
            catch (err) {
                var loc = node.loc ? node.loc : [0, 0];
                if (err instanceof JspyError) {
                    throw err;
                }
                else if (err instanceof JspyEvalError) {
                    throw err;
                }
                else {
                    throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], err.message || err);
                }
            }
        }
        return lastResult;
    };
    Evaluator.prototype.jspyFuncInvoker = function (funcDef, context) {
        var _a;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var ast = Object.assign({}, funcDef.funcAst);
        ast.type = 'func';
        var blockContext = cloneContext(context);
        // set parameters into new scope, based incomming arguments        
        for (var i = 0; i < ((_a = funcDef.params) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {
            var argValue = (args === null || args === void 0 ? void 0 : args.length) > i ? args[i] : null;
            blockContext.blockScope.set(funcDef.params[i], argValue);
        }
        return this.evalBlock(ast, blockContext);
    };
    Evaluator.prototype.invokeFunction = function (func, fps, loc) {
        if (fps.length === 0) {
            return func();
        }
        if (fps.length === 1) {
            return func(fps[0]);
        }
        if (fps.length === 2) {
            return func(fps[0], fps[1]);
        }
        if (fps.length === 3) {
            return func(fps[0], fps[1], fps[2]);
        }
        if (fps.length === 4) {
            return func(fps[0], fps[1], fps[2], fps[3]);
        }
        if (fps.length === 5) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4]);
        }
        if (fps.length === 6) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5]);
        }
        if (fps.length === 7) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6]);
        }
        if (fps.length === 8) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7]);
        }
        if (fps.length === 9) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8]);
        }
        if (fps.length === 10) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9]);
        }
        if (fps.length === 11) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10]);
        }
        if (fps.length === 12) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11]);
        }
        if (fps.length === 13) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12]);
        }
        if (fps.length === 14) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13]);
        }
        if (fps.length === 15) {
            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13], fps[14]);
        }
        throw Error('Function has too many parameters. Current limitation is 15');
    };
    Evaluator.prototype.evalNode = function (node, blockContext) {
        var _this = this;
        var _a, _b, _c, _d, _e, _f, _g;
        if (node.type === 'import') {
            // skip this for now. As modules are implemented externally
            return null;
        }
        if (node.type === 'comment') {
            return null;
        }
        if (node.type === 'if') {
            var ifNode = node;
            if (this.evalNode(ifNode.conditionNode, blockContext)) {
                this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody }, blockContext);
            }
            else if (ifNode.elseBody) {
                this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody }, blockContext);
            }
            return;
        }
        if (node.type === 'raise') {
            var raiseNode = node;
            var err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, raiseNode.errorMessage || "");
            throw err;
        }
        if (node.type === 'tryExcept') {
            var tryNode = node;
            try {
                this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody }, blockContext);
                if (((_a = tryNode.elseBody) === null || _a === void 0 ? void 0 : _a.length) || 0 > 0) {
                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody }, blockContext);
                }
            }
            catch (err) {
                var name_1 = (err instanceof JspyError) ? err.name : typeof (err);
                var message = (err instanceof JspyError) ? err.message : (_b = err === null || err === void 0 ? void 0 : err.message) !== null && _b !== void 0 ? _b : String(err);
                var moduleName = (err instanceof JspyError) ? err.module : 0;
                var line = (err instanceof JspyError) ? err.line : 0;
                var column = (err instanceof JspyError) ? err.column : 0;
                var firstExept = tryNode.exepts[0];
                var catchBody = firstExept.body;
                var ctx = blockContext; // cloneContext(blockContext);
                ctx.blockScope.set(((_c = firstExept.error) === null || _c === void 0 ? void 0 : _c.alias) || "error", { name: name_1, message: message, line: line, column: column, moduleName: moduleName });
                this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: catchBody }, ctx);
                ctx.blockScope.set(((_d = firstExept.error) === null || _d === void 0 ? void 0 : _d.alias) || "error", null);
            }
            finally {
                if (((_e = tryNode.finallyBody) === null || _e === void 0 ? void 0 : _e.length) || 0 > 0) {
                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.finallyBody }, blockContext);
                }
            }
            return;
        }
        if (node.type === 'return') {
            var returnNode = node;
            blockContext.returnCalled = true;
            blockContext.returnObject = returnNode.returnValue ?
                this.evalNode(returnNode.returnValue, blockContext)
                : null;
            return blockContext.returnObject;
        }
        if (node.type === 'continue') {
            blockContext.continueCalled = true;
            return;
        }
        if (node.type === 'break') {
            blockContext.breakCalled = true;
            return;
        }
        if (node.type === 'for') {
            var forNode = node;
            var array = this.evalNode(forNode.sourceArray, blockContext);
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                blockContext.blockScope.set(forNode.itemVarName, item);
                this.evalBlock({ name: blockContext.moduleName, type: 'for', body: forNode.body }, blockContext);
                if (blockContext.continueCalled) {
                    blockContext.continueCalled = false;
                }
                if (blockContext.breakCalled) {
                    break;
                }
            }
            if (blockContext.breakCalled) {
                blockContext.breakCalled = false;
            }
            return;
        }
        if (node.type === 'while') {
            var whileNode = node;
            while (this.evalNode(whileNode.condition, blockContext)) {
                this.evalBlock({ name: blockContext.moduleName, type: 'while', body: whileNode.body }, blockContext);
                if (blockContext.continueCalled) {
                    blockContext.continueCalled = false;
                }
                if (blockContext.breakCalled) {
                    break;
                }
            }
            if (blockContext.breakCalled) {
                blockContext.breakCalled = false;
            }
            return;
        }
        if (node.type === "const") {
            return node.value;
        }
        if (node.type === "getSingleVar") {
            var name_2 = node.name;
            var value = blockContext.blockScope.get(node.name);
            if (value === undefined) {
                if (name_2.charAt(name_2.length - 1) === ';') {
                    throw new Error("Unexpected ';' in the end.");
                }
                else {
                    throw new Error("Variable '" + name_2 + "' is not defined.");
                }
            }
            return value;
        }
        if (node.type === "binOp") {
            var binOpNode = node;
            var left = this.evalNode(binOpNode.left, blockContext);
            var right = this.evalNode(binOpNode.right, blockContext);
            return OperationFuncs[binOpNode.op](left, right);
        }
        if (node.type === "logicalOp") {
            var logicalGroups = node;
            var ind = 0;
            var gResult = true;
            while (ind < logicalGroups.items.length) {
                var eg = logicalGroups.items[ind++];
                gResult = this.evalNode(eg.node, blockContext);
                if (eg.op === 'and' && !gResult) {
                    return false;
                }
                if (eg.op === 'or' && gResult) {
                    return gResult;
                }
            }
            return gResult;
        }
        if (node.type === "arrowFuncDef") {
            var arrowFuncDef_1 = node;
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.jspyFuncInvoker.apply(_this, __spreadArray([arrowFuncDef_1, blockContext], args));
            };
        }
        if (node.type === "funcCall") {
            var funcCallNode = node;
            var func = blockContext.blockScope.get(funcCallNode.name);
            if (typeof func !== 'function') {
                throw Error("'" + funcCallNode.name + "' is not a function or not defined.");
            }
            var pms = ((_f = funcCallNode.paramNodes) === null || _f === void 0 ? void 0 : _f.map(function (n) { return _this.evalNode(n, blockContext); })) || [];
            return this.invokeFunction(func, pms, {
                moduleName: blockContext.moduleName,
                line: funcCallNode.loc[0],
                column: funcCallNode.loc[1]
            });
        }
        if (node.type === "assign") {
            var assignNode = node;
            if (assignNode.target.type === 'getSingleVar') {
                var node_1 = assignNode.target;
                blockContext.blockScope.set(node_1.name, this.evalNode(assignNode.source, blockContext));
            }
            else if (assignNode.target.type === 'dotObjectAccess') {
                var targetNode = assignNode.target;
                // create a node for all but last property token
                // potentially it can go to parser
                var targetObjectNode = new DotObjectAccessNode(targetNode.nestedProps.slice(0, targetNode.nestedProps.length - 1), targetNode.loc);
                var targetObject = this.evalNode(targetObjectNode, blockContext);
                // not sure nested properties should be GetSingleVarNode
                // can be factored in the parser
                var lastPropertyName = targetNode.nestedProps[targetNode.nestedProps.length - 1].name;
                targetObject[lastPropertyName] = this.evalNode(assignNode.source, blockContext);
            }
            else if (assignNode.target.type === 'bracketObjectAccess') {
                var targetNode = assignNode.target;
                var keyValue = this.evalNode(targetNode.bracketBody, blockContext);
                var targetObject = blockContext.blockScope.get(targetNode.propertyName);
                targetObject[keyValue] = this.evalNode(assignNode.source, blockContext);
            }
            else {
                throw Error('Not implemented Assign operation');
                // get chaining calls
            }
            return null;
        }
        if (node.type === 'bracketObjectAccess') {
            var sbNode = node;
            var key = this.evalNode(sbNode.bracketBody, blockContext);
            var obj = blockContext.blockScope.get(sbNode.propertyName);
            return (obj[key] === undefined) ? null : obj[key];
        }
        if (node.type === "dotObjectAccess") {
            var dotObject = node;
            var startObject = this.evalNode(dotObject.nestedProps[0], blockContext);
            for (var i = 1; i < dotObject.nestedProps.length; i++) {
                var nestedProp = dotObject.nestedProps[i];
                if (dotObject.nestedProps[i - 1].nullCoelsing && !startObject) {
                    startObject = {};
                }
                if (nestedProp.type === 'getSingleVar') {
                    startObject = startObject[nestedProp.name];
                }
                else if (nestedProp.type === 'bracketObjectAccess') {
                    var node_2 = nestedProp;
                    startObject = startObject[node_2.propertyName];
                    startObject = startObject[this.evalNode(node_2.bracketBody, blockContext)];
                }
                else if (nestedProp.type === 'funcCall') {
                    var funcCallNode = nestedProp;
                    var func = startObject[funcCallNode.name];
                    if ((func === undefined || func === null)
                        && dotObject.nestedProps[i - 1].nullCoelsing) {
                        startObject = null;
                        continue;
                    }
                    if (typeof func !== 'function') {
                        throw Error("'" + funcCallNode.name + "' is not a function or not defined.");
                    }
                    var pms = ((_g = funcCallNode.paramNodes) === null || _g === void 0 ? void 0 : _g.map(function (n) { return _this.evalNode(n, blockContext); })) || [];
                    startObject = this.invokeFunction(func.bind(startObject), pms, {
                        moduleName: blockContext.moduleName,
                        line: funcCallNode.loc[0],
                        column: funcCallNode.loc[1]
                    });
                }
                else {
                    throw Error("Can't resolve dotObjectAccess node");
                }
            }
            // no undefined values, make it rather null
            return (startObject === undefined) ? null : startObject;
        }
        if (node.type === 'createObject') {
            var createObjectNode = node;
            var obj = {};
            for (var _i = 0, _h = createObjectNode.props; _i < _h.length; _i++) {
                var p = _h[_i];
                obj[this.evalNode(p.name, blockContext)] = this.evalNode(p.value, blockContext);
            }
            return obj;
        }
        if (node.type === 'createArray') {
            var arrayNode = node;
            var res = [];
            for (var _j = 0, _k = arrayNode.items; _j < _k.length; _j++) {
                var item = _k[_j];
                res.push(this.evalNode(item, blockContext));
            }
            return res;
        }
    };
    return Evaluator;
}());/**
 * This is copy/paste from Evaluator.
 * Sadly, we have to copy code around to support both async and non async methods.
 * So, any changes to this method, should be replicated in the evaluator.ts
 */
var EvaluatorAsync = /** @class */ (function () {
    function EvaluatorAsync() {
        this.moduleParser = function () { return Promise.reject('Module parser is not registered!'); };
        this.jsonFileLoader = function () { return Promise.reject('{}'); };
    }
    EvaluatorAsync.prototype.registerModuleParser = function (moduleParser) {
        this.moduleParser = moduleParser;
        return this;
    };
    EvaluatorAsync.prototype.registerJsonFileLoader = function (jsonFileLoader) {
        this.jsonFileLoader = jsonFileLoader;
        return this;
    };
    EvaluatorAsync.prototype.registerBlockContextFactory = function (blockContextFactory) {
        this.blockContextFactory = blockContextFactory;
        return this;
    };
    EvaluatorAsync.prototype.evalBlockAsync = function (ast, blockContext) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var lastResult, _loop_1, _i, _c, node, _d, _e, node, importNode, iType, jsonValue, _f, _g, moduleAst, moduleBlockContext, scope, res, err_1, loc;
            var _this = this;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        lastResult = null;
                        _loop_1 = function (node) {
                            var funcDef = node;
                            // a child scope needs to be created here
                            var newScope = blockContext.blockScope;
                            var invoker = (funcDef.isAsync) ?
                                function () {
                                    var args = [];
                                    for (var _i = 0; _i < arguments.length; _i++) {
                                        args[_i] = arguments[_i];
                                    }
                                    return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, this.jspyFuncInvokerAsync.apply(this, __spreadArray([funcDef, blockContext], args))];
                                            case 1: return [2 /*return*/, _a.sent()];
                                        }
                                    }); });
                                }
                                : function () {
                                    var _a;
                                    var args = [];
                                    for (var _i = 0; _i < arguments.length; _i++) {
                                        args[_i] = arguments[_i];
                                    }
                                    return (_a = new Evaluator()).jspyFuncInvoker.apply(_a, __spreadArray([funcDef, blockContext], args));
                                };
                            newScope.set(funcDef.funcAst.name, invoker);
                        };
                        for (_i = 0, _c = (ast === null || ast === void 0 ? void 0 : ast.funcs) || []; _i < _c.length; _i++) {
                            node = _c[_i];
                            _loop_1(node);
                        }
                        _d = 0, _e = ast.body;
                        _h.label = 1;
                    case 1:
                        if (!(_d < _e.length)) return [3 /*break*/, 11];
                        node = _e[_d];
                        if (node.type === 'comment') {
                            return [3 /*break*/, 10];
                        }
                        if (!(node.type === 'import')) return [3 /*break*/, 7];
                        importNode = node;
                        iType = getImportType(importNode.module.name);
                        if (!(iType === 'json')) return [3 /*break*/, 3];
                        _g = (_f = JSON).parse;
                        return [4 /*yield*/, this.jsonFileLoader(importNode.module.name)];
                    case 2:
                        jsonValue = _g.apply(_f, [_h.sent()]);
                        blockContext.blockScope
                            .set(importNode.module.alias || this.defaultModuleName(importNode.module.name), jsonValue);
                        return [3 /*break*/, 10];
                    case 3:
                        if (iType !== 'jspyModule') {
                            // it is not JSPY import. It is JS and should be handled externally
                            return [3 /*break*/, 10];
                        }
                        _h.label = 4;
                    case 4:
                        if (typeof this.blockContextFactory !== 'function') {
                            throw new Error('blockContextFactory is not initialized');
                        }
                        return [4 /*yield*/, this.moduleParser(importNode.module.name)];
                    case 5:
                        moduleAst = _h.sent();
                        moduleBlockContext = this.blockContextFactory(importNode.module.name, moduleAst);
                        return [4 /*yield*/, this.evalBlockAsync(moduleAst, moduleBlockContext)];
                    case 6:
                        _h.sent();
                        scope = blockContext.blockScope.getScope();
                        if (!((_a = importNode.parts) === null || _a === void 0 ? void 0 : _a.length)) {
                            // if no parts, then we need to assign to a separate object
                            scope = {};
                            blockContext.blockScope.set(importNode.module.alias || this.defaultModuleName(importNode.module.name), scope);
                        }
                        this.assignFunctionsToScope(scope, moduleBlockContext, moduleAst, (_b = importNode.parts) === null || _b === void 0 ? void 0 : _b.map(function (p) { return p.name; }));
                        return [3 /*break*/, 10];
                    case 7:
                        _h.trys.push([7, 9, , 10]);
                        return [4 /*yield*/, this.evalNodeAsync(node, blockContext)];
                    case 8:
                        lastResult = _h.sent();
                        if (blockContext.returnCalled) {
                            res = blockContext.returnObject;
                            // stop processing return
                            if (ast.type == 'func' || ast.type == 'module') {
                                blockContext.returnCalled = false;
                                blockContext.returnObject = null;
                            }
                            return [2 /*return*/, res];
                        }
                        if (blockContext.continueCalled) {
                            return [3 /*break*/, 11];
                        }
                        if (blockContext.breakCalled) {
                            return [3 /*break*/, 11];
                        }
                        return [3 /*break*/, 10];
                    case 9:
                        err_1 = _h.sent();
                        loc = node.loc ? node.loc : [0, 0];
                        if (err_1 instanceof JspyError) {
                            throw err_1;
                        }
                        else if (err_1 instanceof JspyEvalError) {
                            throw err_1;
                        }
                        else {
                            throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], err_1.message || err_1);
                        }
                    case 10:
                        _d++;
                        return [3 /*break*/, 1];
                    case 11: return [2 /*return*/, lastResult];
                }
            });
        });
    };
    EvaluatorAsync.prototype.assignFunctionsToScope = function (scope, moduleBlockContext, moduleAst, parts) {
        var _this = this;
        var funcs = moduleAst.funcs.filter(function (f) { var _a; return !parts || parts.indexOf((_a = f.funcAst) === null || _a === void 0 ? void 0 : _a.name) >= 0; });
        var _loop_2 = function (i) {
            var funcDef = funcs[i];
            var invoker = (funcDef.isAsync) ?
                function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.jspyFuncInvokerAsync.apply(this, __spreadArray([funcDef, moduleBlockContext], args))];
                            case 1: return [2 /*return*/, _a.sent()];
                        }
                    }); });
                }
                : function () {
                    var _a;
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return (_a = new Evaluator()).jspyFuncInvoker.apply(_a, __spreadArray([funcDef, moduleBlockContext], args));
                };
            scope[funcDef.funcAst.name] = invoker;
        };
        for (var i = 0; i < funcs.length; i++) {
            _loop_2(i);
        }
    };
    EvaluatorAsync.prototype.defaultModuleName = function (name) {
        return name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.'));
    };
    EvaluatorAsync.prototype.jspyFuncInvokerAsync = function (funcDef, context) {
        var _a;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var ast, blockContext, i, argValue;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        ast = Object.assign({}, funcDef.funcAst);
                        ast.type = 'func';
                        blockContext = cloneContext(context);
                        // set parameters into new scope, based incomming arguments        
                        for (i = 0; i < ((_a = funcDef.params) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {
                            argValue = (args === null || args === void 0 ? void 0 : args.length) > i ? args[i] : null;
                            blockContext.blockScope.set(funcDef.params[i], argValue);
                        }
                        return [4 /*yield*/, this.evalBlockAsync(ast, blockContext)];
                    case 1: return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    EvaluatorAsync.prototype.invokeFunctionAsync = function (func, fps, loc) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(fps.length === 0)) return [3 /*break*/, 2];
                        return [4 /*yield*/, func()];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        if (!(fps.length === 1)) return [3 /*break*/, 4];
                        return [4 /*yield*/, func(fps[0])];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4:
                        if (!(fps.length === 2)) return [3 /*break*/, 6];
                        return [4 /*yield*/, func(fps[0], fps[1])];
                    case 5: return [2 /*return*/, _a.sent()];
                    case 6:
                        if (!(fps.length === 3)) return [3 /*break*/, 8];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2])];
                    case 7: return [2 /*return*/, _a.sent()];
                    case 8:
                        if (!(fps.length === 4)) return [3 /*break*/, 10];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3])];
                    case 9: return [2 /*return*/, _a.sent()];
                    case 10:
                        if (!(fps.length === 5)) return [3 /*break*/, 12];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4])];
                    case 11: return [2 /*return*/, _a.sent()];
                    case 12:
                        if (!(fps.length === 6)) return [3 /*break*/, 14];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5])];
                    case 13: return [2 /*return*/, _a.sent()];
                    case 14:
                        if (!(fps.length === 7)) return [3 /*break*/, 16];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6])];
                    case 15: return [2 /*return*/, _a.sent()];
                    case 16:
                        if (!(fps.length === 8)) return [3 /*break*/, 18];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7])];
                    case 17: return [2 /*return*/, _a.sent()];
                    case 18:
                        if (!(fps.length === 9)) return [3 /*break*/, 20];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8])];
                    case 19: return [2 /*return*/, _a.sent()];
                    case 20:
                        if (!(fps.length === 10)) return [3 /*break*/, 22];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9])];
                    case 21: return [2 /*return*/, _a.sent()];
                    case 22:
                        if (!(fps.length === 11)) return [3 /*break*/, 24];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10])];
                    case 23: return [2 /*return*/, _a.sent()];
                    case 24:
                        if (!(fps.length === 12)) return [3 /*break*/, 26];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11])];
                    case 25: return [2 /*return*/, _a.sent()];
                    case 26:
                        if (!(fps.length === 13)) return [3 /*break*/, 28];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12])];
                    case 27: return [2 /*return*/, _a.sent()];
                    case 28:
                        if (!(fps.length === 14)) return [3 /*break*/, 30];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13])];
                    case 29: return [2 /*return*/, _a.sent()];
                    case 30:
                        if (!(fps.length === 15)) return [3 /*break*/, 32];
                        return [4 /*yield*/, func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13], fps[14])];
                    case 31: return [2 /*return*/, _a.sent()];
                    case 32: throw Error('Function has too many parameters. Current limitation is 15');
                }
            });
        });
    };
    EvaluatorAsync.prototype.evalNodeAsync = function (node, blockContext) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function () {
            var ifNode, raiseNode, err, tryNode, err_2, name_1, message, moduleName, line, column, firstExept, catchBody, ctx, returnNode, _f, _g, forNode, array, i, item, whileNode, name_2, value, binOpNode, left, right, logicalGroups, ind, gResult, eg, arrowFuncDef_1, funcCallNode, func, pms, _i, _h, p, _j, _k, assignNode, node_1, _l, _m, _o, targetNode, targetObjectNode, targetObject, lastPropertyName, _p, _q, targetNode, keyValue, targetObject, _r, _s, sbNode, key, obj, dotObject, startObject, i, nestedProp, node_2, _t, funcCallNode, func, pms, _u, _v, p, _w, _x, createObjectNode, obj, _y, _z, p, _0, _1, arrayNode, res, _2, _3, item, _4, _5;
            return __generator(this, function (_6) {
                switch (_6.label) {
                    case 0:
                        if (node.type === 'import') {
                            throw new Error('Import should be defined at the start');
                        }
                        if (node.type === 'comment') {
                            return [2 /*return*/, null];
                        }
                        if (!(node.type === 'if')) return [3 /*break*/, 6];
                        ifNode = node;
                        return [4 /*yield*/, this.evalNodeAsync(ifNode.conditionNode, blockContext)];
                    case 1:
                        if (!_6.sent()) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody }, blockContext)];
                    case 2:
                        _6.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        if (!ifNode.elseBody) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody }, blockContext)];
                    case 4:
                        _6.sent();
                        _6.label = 5;
                    case 5: return [2 /*return*/];
                    case 6:
                        if (node.type === 'raise') {
                            raiseNode = node;
                            err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, raiseNode.errorMessage || "");
                            throw err;
                        }
                        if (!(node.type === 'tryExcept')) return [3 /*break*/, 17];
                        tryNode = node;
                        _6.label = 7;
                    case 7:
                        _6.trys.push([7, 11, 13, 16]);
                        return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody }, blockContext)];
                    case 8:
                        _6.sent();
                        if (!(((_a = tryNode.elseBody) === null || _a === void 0 ? void 0 : _a.length) || 0 > 0)) return [3 /*break*/, 10];
                        return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody }, blockContext)];
                    case 9:
                        _6.sent();
                        _6.label = 10;
                    case 10: return [3 /*break*/, 16];
                    case 11:
                        err_2 = _6.sent();
                        name_1 = (err_2 instanceof JspyError) ? err_2.name : typeof (err_2);
                        message = (err_2 instanceof JspyError) ? err_2.message : (_b = err_2 === null || err_2 === void 0 ? void 0 : err_2.message) !== null && _b !== void 0 ? _b : String(err_2);
                        moduleName = (err_2 instanceof JspyError) ? err_2.module : 0;
                        line = (err_2 instanceof JspyError) ? err_2.line : 0;
                        column = (err_2 instanceof JspyError) ? err_2.column : 0;
                        firstExept = tryNode.exepts[0];
                        catchBody = firstExept.body;
                        ctx = blockContext;
                        ctx.blockScope.set(((_c = firstExept.error) === null || _c === void 0 ? void 0 : _c.alias) || "error", { name: name_1, message: message, line: line, column: column, moduleName: moduleName });
                        return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: catchBody }, ctx)];
                    case 12:
                        _6.sent();
                        ctx.blockScope.set(((_d = firstExept.error) === null || _d === void 0 ? void 0 : _d.alias) || "error", null);
                        return [3 /*break*/, 16];
                    case 13:
                        if (!(((_e = tryNode.finallyBody) === null || _e === void 0 ? void 0 : _e.length) || 0 > 0)) return [3 /*break*/, 15];
                        return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.finallyBody }, blockContext)];
                    case 14:
                        _6.sent();
                        _6.label = 15;
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                    case 17:
                        if (!(node.type === 'return')) return [3 /*break*/, 21];
                        returnNode = node;
                        blockContext.returnCalled = true;
                        _f = blockContext;
                        if (!returnNode.returnValue) return [3 /*break*/, 19];
                        return [4 /*yield*/, this.evalNodeAsync(returnNode.returnValue, blockContext)];
                    case 18:
                        _g = _6.sent();
                        return [3 /*break*/, 20];
                    case 19:
                        _g = null;
                        _6.label = 20;
                    case 20:
                        _f.returnObject = _g;
                        return [2 /*return*/, blockContext.returnObject];
                    case 21:
                        if (node.type === 'continue') {
                            blockContext.continueCalled = true;
                            return [2 /*return*/];
                        }
                        if (node.type === 'break') {
                            blockContext.breakCalled = true;
                            return [2 /*return*/];
                        }
                        if (!(node.type === 'for')) return [3 /*break*/, 27];
                        forNode = node;
                        return [4 /*yield*/, this.evalNodeAsync(forNode.sourceArray, blockContext)];
                    case 22:
                        array = _6.sent();
                        i = 0;
                        _6.label = 23;
                    case 23:
                        if (!(i < array.length)) return [3 /*break*/, 26];
                        item = array[i];
                        blockContext.blockScope.set(forNode.itemVarName, item);
                        return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'for', body: forNode.body }, blockContext)];
                    case 24:
                        _6.sent();
                        if (blockContext.continueCalled) {
                            blockContext.continueCalled = false;
                        }
                        if (blockContext.breakCalled) {
                            return [3 /*break*/, 26];
                        }
                        _6.label = 25;
                    case 25:
                        i++;
                        return [3 /*break*/, 23];
                    case 26:
                        if (blockContext.breakCalled) {
                            blockContext.breakCalled = false;
                        }
                        return [2 /*return*/];
                    case 27:
                        if (!(node.type === 'while')) return [3 /*break*/, 32];
                        whileNode = node;
                        _6.label = 28;
                    case 28: return [4 /*yield*/, this.evalNodeAsync(whileNode.condition, blockContext)];
                    case 29:
                        if (!_6.sent()) return [3 /*break*/, 31];
                        return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'while', body: whileNode.body }, blockContext)];
                    case 30:
                        _6.sent();
                        if (blockContext.continueCalled) {
                            blockContext.continueCalled = false;
                        }
                        if (blockContext.breakCalled) {
                            return [3 /*break*/, 31];
                        }
                        return [3 /*break*/, 28];
                    case 31:
                        if (blockContext.breakCalled) {
                            blockContext.breakCalled = false;
                        }
                        return [2 /*return*/];
                    case 32:
                        if (node.type === "const") {
                            return [2 /*return*/, node.value];
                        }
                        if (node.type === "getSingleVar") {
                            name_2 = node.name;
                            value = blockContext.blockScope.get(name_2);
                            if (value === undefined) {
                                if (name_2.charAt(name_2.length - 1) === ';') {
                                    throw new Error("Unexpected ';' in the end.");
                                }
                                else {
                                    throw new Error("Variable '" + name_2 + "' is not defined.");
                                }
                            }
                            return [2 /*return*/, value];
                        }
                        if (!(node.type === "binOp")) return [3 /*break*/, 35];
                        binOpNode = node;
                        return [4 /*yield*/, this.evalNodeAsync(binOpNode.left, blockContext)];
                    case 33:
                        left = _6.sent();
                        return [4 /*yield*/, this.evalNodeAsync(binOpNode.right, blockContext)];
                    case 34:
                        right = _6.sent();
                        return [2 /*return*/, OperationFuncs[binOpNode.op](left, right)];
                    case 35:
                        if (!(node.type === "logicalOp")) return [3 /*break*/, 39];
                        logicalGroups = node;
                        ind = 0;
                        gResult = true;
                        _6.label = 36;
                    case 36:
                        if (!(ind < logicalGroups.items.length)) return [3 /*break*/, 38];
                        eg = logicalGroups.items[ind++];
                        return [4 /*yield*/, this.evalNodeAsync(eg.node, blockContext)];
                    case 37:
                        gResult = _6.sent();
                        if (eg.op === 'and' && !gResult) {
                            return [2 /*return*/, false];
                        }
                        if (eg.op === 'or' && gResult) {
                            return [2 /*return*/, gResult];
                        }
                        return [3 /*break*/, 36];
                    case 38: return [2 /*return*/, gResult];
                    case 39:
                        if (node.type === "arrowFuncDef") {
                            arrowFuncDef_1 = node;
                            return [2 /*return*/, function () {
                                    var _a;
                                    var args = [];
                                    for (var _i = 0; _i < arguments.length; _i++) {
                                        args[_i] = arguments[_i];
                                    }
                                    return (_a = new Evaluator()).jspyFuncInvoker.apply(_a, __spreadArray([arrowFuncDef_1, blockContext], args));
                                }];
                        }
                        if (!(node.type === "funcCall")) return [3 /*break*/, 45];
                        funcCallNode = node;
                        func = blockContext.blockScope.get(funcCallNode.name);
                        if (typeof func !== 'function') {
                            throw Error("'" + funcCallNode.name + "' is not a function or not defined.");
                        }
                        pms = [];
                        _i = 0, _h = funcCallNode.paramNodes || [];
                        _6.label = 40;
                    case 40:
                        if (!(_i < _h.length)) return [3 /*break*/, 43];
                        p = _h[_i];
                        _k = (_j = pms).push;
                        return [4 /*yield*/, this.evalNodeAsync(p, blockContext)];
                    case 41:
                        _k.apply(_j, [_6.sent()]);
                        _6.label = 42;
                    case 42:
                        _i++;
                        return [3 /*break*/, 40];
                    case 43: return [4 /*yield*/, this.invokeFunctionAsync(func, pms, {
                            moduleName: blockContext.moduleName,
                            line: funcCallNode.loc[0],
                            column: funcCallNode.loc[0]
                        })];
                    case 44: return [2 /*return*/, _6.sent()];
                    case 45:
                        if (!(node.type === "assign")) return [3 /*break*/, 55];
                        assignNode = node;
                        if (!(assignNode.target.type === 'getSingleVar')) return [3 /*break*/, 47];
                        node_1 = assignNode.target;
                        _m = (_l = blockContext.blockScope).set;
                        _o = [node_1.name];
                        return [4 /*yield*/, this.evalNodeAsync(assignNode.source, blockContext)];
                    case 46:
                        _m.apply(_l, _o.concat([_6.sent()]));
                        return [3 /*break*/, 54];
                    case 47:
                        if (!(assignNode.target.type === 'dotObjectAccess')) return [3 /*break*/, 50];
                        targetNode = assignNode.target;
                        targetObjectNode = new DotObjectAccessNode(targetNode.nestedProps.slice(0, targetNode.nestedProps.length - 1), targetNode.loc);
                        return [4 /*yield*/, this.evalNodeAsync(targetObjectNode, blockContext)];
                    case 48:
                        targetObject = _6.sent();
                        lastPropertyName = targetNode.nestedProps[targetNode.nestedProps.length - 1].name;
                        _p = targetObject;
                        _q = lastPropertyName;
                        return [4 /*yield*/, this.evalNodeAsync(assignNode.source, blockContext)];
                    case 49:
                        _p[_q] = _6.sent();
                        return [3 /*break*/, 54];
                    case 50:
                        if (!(assignNode.target.type === 'bracketObjectAccess')) return [3 /*break*/, 53];
                        targetNode = assignNode.target;
                        return [4 /*yield*/, this.evalNodeAsync(targetNode.bracketBody, blockContext)];
                    case 51:
                        keyValue = _6.sent();
                        targetObject = blockContext.blockScope.get(targetNode.propertyName);
                        _r = targetObject;
                        _s = keyValue;
                        return [4 /*yield*/, this.evalNodeAsync(assignNode.source, blockContext)];
                    case 52:
                        _r[_s] = _6.sent();
                        return [3 /*break*/, 54];
                    case 53: throw Error('Not implemented Assign operation');
                    case 54: return [2 /*return*/, null];
                    case 55:
                        if (!(node.type === 'bracketObjectAccess')) return [3 /*break*/, 57];
                        sbNode = node;
                        return [4 /*yield*/, this.evalNodeAsync(sbNode.bracketBody, blockContext)];
                    case 56:
                        key = _6.sent();
                        obj = blockContext.blockScope.get(sbNode.propertyName);
                        return [2 /*return*/, (obj[key] === undefined) ? null : obj[key]];
                    case 57:
                        if (!(node.type === "dotObjectAccess")) return [3 /*break*/, 71];
                        dotObject = node;
                        return [4 /*yield*/, this.evalNodeAsync(dotObject.nestedProps[0], blockContext)];
                    case 58:
                        startObject = _6.sent();
                        i = 1;
                        _6.label = 59;
                    case 59:
                        if (!(i < dotObject.nestedProps.length)) return [3 /*break*/, 70];
                        nestedProp = dotObject.nestedProps[i];
                        if (dotObject.nestedProps[i - 1].nullCoelsing && !startObject) {
                            startObject = {};
                        }
                        if (!(nestedProp.type === 'getSingleVar')) return [3 /*break*/, 60];
                        startObject = startObject[nestedProp.name];
                        return [3 /*break*/, 69];
                    case 60:
                        if (!(nestedProp.type === 'bracketObjectAccess')) return [3 /*break*/, 62];
                        node_2 = nestedProp;
                        startObject = startObject[node_2.propertyName];
                        _t = startObject;
                        return [4 /*yield*/, this.evalNodeAsync(node_2.bracketBody, blockContext)];
                    case 61:
                        startObject = _t[_6.sent()];
                        return [3 /*break*/, 69];
                    case 62:
                        if (!(nestedProp.type === 'funcCall')) return [3 /*break*/, 68];
                        funcCallNode = nestedProp;
                        func = startObject[funcCallNode.name];
                        if ((func === undefined || func === null)
                            && dotObject.nestedProps[i - 1].nullCoelsing) {
                            startObject = null;
                            return [3 /*break*/, 69];
                        }
                        if (typeof (func) !== 'function') {
                            throw Error("'" + funcCallNode.name + "' is not a function or not defined.");
                        }
                        pms = [];
                        _u = 0, _v = funcCallNode.paramNodes || [];
                        _6.label = 63;
                    case 63:
                        if (!(_u < _v.length)) return [3 /*break*/, 66];
                        p = _v[_u];
                        _x = (_w = pms).push;
                        return [4 /*yield*/, this.evalNodeAsync(p, blockContext)];
                    case 64:
                        _x.apply(_w, [_6.sent()]);
                        _6.label = 65;
                    case 65:
                        _u++;
                        return [3 /*break*/, 63];
                    case 66: return [4 /*yield*/, this.invokeFunctionAsync(func.bind(startObject), pms, {
                            moduleName: blockContext.moduleName,
                            line: funcCallNode.loc[0],
                            column: funcCallNode.loc[0]
                        })];
                    case 67:
                        startObject = _6.sent();
                        return [3 /*break*/, 69];
                    case 68: throw Error("Can't resolve dotObjectAccess node");
                    case 69:
                        i++;
                        return [3 /*break*/, 59];
                    case 70: 
                    // no undefined values, make it rather null
                    return [2 /*return*/, (startObject === undefined) ? null : startObject];
                    case 71:
                        if (!(node.type === 'createObject')) return [3 /*break*/, 77];
                        createObjectNode = node;
                        obj = {};
                        _y = 0, _z = createObjectNode.props;
                        _6.label = 72;
                    case 72:
                        if (!(_y < _z.length)) return [3 /*break*/, 76];
                        p = _z[_y];
                        _0 = obj;
                        return [4 /*yield*/, this.evalNodeAsync(p.name, blockContext)];
                    case 73:
                        _1 = _6.sent();
                        return [4 /*yield*/, this.evalNodeAsync(p.value, blockContext)];
                    case 74:
                        _0[_1] = _6.sent();
                        _6.label = 75;
                    case 75:
                        _y++;
                        return [3 /*break*/, 72];
                    case 76: return [2 /*return*/, obj];
                    case 77:
                        if (!(node.type === 'createArray')) return [3 /*break*/, 82];
                        arrayNode = node;
                        res = [];
                        _2 = 0, _3 = arrayNode.items;
                        _6.label = 78;
                    case 78:
                        if (!(_2 < _3.length)) return [3 /*break*/, 81];
                        item = _3[_2];
                        _5 = (_4 = res).push;
                        return [4 /*yield*/, this.evalNodeAsync(item, blockContext)];
                    case 79:
                        _5.apply(_4, [_6.sent()]);
                        _6.label = 80;
                    case 80:
                        _2++;
                        return [3 /*break*/, 78];
                    case 81: return [2 /*return*/, res];
                    case 82: return [2 /*return*/];
                }
            });
        });
    };
    return EvaluatorAsync;
}());var INITIAL_SCOPE = {
    jsPython: function () {
        return ["JSPython v2.1.7", "(c) 2021 FalconSoft Ltd. All rights reserved."].join('\n');
    },
    dateTime: function (str) {
        if (str === void 0) { str = null; }
        return parseDatetimeOrNull(str) || new Date();
    },
    range: range,
    print: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        console.log.apply(console, args);
        return args.length > 0 ? args[0] : null;
    },
    isNull: function (v, defValue) {
        if (defValue === void 0) { defValue = null; }
        return defValue === null ? v === null : v || defValue;
    },
    isDate: function (d) { return d instanceof Date; },
    isFunction: function (v) { return typeof v === 'function'; },
    isString: function (v) { return typeof v === 'string'; },
    deleteProperty: function (obj, propName) { return delete obj[propName]; },
    Math: Math,
    Object: Object,
    Array: Array,
    JSON: JSON,
    printExecutionContext: function () { },
    getExecutionContext: function () { } // will be overriden at runtime
};
function range(start, stop, step) {
    if (stop === void 0) { stop = NaN; }
    if (step === void 0) { step = 1; }
    var arr = [];
    var isStopNaN = isNaN(stop);
    stop = isStopNaN ? start : stop;
    start = isStopNaN ? 0 : start;
    var i = start;
    while (i < stop) {
        arr.push(i);
        i += step;
    }
    return arr;
}var InstructionLine = /** @class */ (function () {
    function InstructionLine() {
        this.tokens = [];
    }
    InstructionLine.prototype.startLine = function () {
        return getStartLine(this.tokens[0]);
    };
    InstructionLine.prototype.startColumn = function () {
        return getStartColumn(this.tokens[0]);
    };
    InstructionLine.prototype.endLine = function () {
        return getEndLine(this.tokens[this.tokens.length - 1]);
    };
    InstructionLine.prototype.endColumn = function () {
        return getEndColumn(this.tokens[this.tokens.length - 1]);
    };
    return InstructionLine;
}());
var Parser = /** @class */ (function () {
    function Parser() {
        this._currentToken = null;
        this._moduleName = '';
    }
    /**
     * Parses tokens and return Ast - Abstract Syntax Tree for jsPython code
     * @param tokens tokens
     * @param options parsing options. By default it will exclude comments and include LOC (Line of code)
     */
    Parser.prototype.parse = function (tokens, name, type) {
        var _a;
        if (name === void 0) { name = 'main.jspy'; }
        if (type === void 0) { type = 'module'; }
        this._moduleName = name;
        var ast = { name: name, type: type, funcs: [], body: [] };
        if (!tokens || !tokens.length) {
            return ast;
        }
        try {
            // group all tokens into an Instruction lines.
            var instructions = this.tokensToInstructionLines(tokens, 1);
            // process all instructions
            this.instructionsToNodes(instructions, ast);
        }
        catch (err) {
            var token = (_a = this._currentToken) !== null && _a !== void 0 ? _a : {};
            throw new JspyParserError(ast.name, getStartLine(token), getStartColumn(token), err.message || err);
        }
        return ast;
    };
    Parser.prototype.instructionsToNodes = function (instructions, ast) {
        var _this = this;
        var getBody = function (tokens, startTokenIndex) {
            var instructionLines = _this.tokensToInstructionLines(tokens, getStartLine(tokens[startTokenIndex]));
            var bodyAst = { name: ast.name, body: [], funcs: [] };
            _this.instructionsToNodes(instructionLines, bodyAst);
            return bodyAst.body;
        };
        var findIndexes = function (tkns, operation, result) {
            result.splice(0, result.length);
            findOperators(tkns, operation).forEach(function (r) { return result.push(r); });
            return !!result.length;
        };
        for (var i = 0; i < instructions.length; i++) {
            var instruction = instructions[i];
            // remove comments
            var tt = 0;
            while (tt < instruction.tokens.length) {
                if (getTokenType(instruction.tokens[tt]) === TokenTypes.Comment) {
                    instruction.tokens.splice(tt, 1);
                }
                else {
                    tt++;
                }
            }
            if (!instruction.tokens.length) {
                continue;
            }
            var firstToken = instruction.tokens[0];
            var secondToken = instruction.tokens.length > 1 ? instruction.tokens[1] : null;
            this._currentToken = firstToken;
            var logicOpIndexes = [];
            var assignTokenIndexes = [];
            if (getTokenType(firstToken) === TokenTypes.Comment) {
                ast.body.push(new CommentNode(getTokenValue(firstToken), getTokenLoc(firstToken)));
            }
            else if (getTokenValue(firstToken) === 'def'
                || (getTokenValue(firstToken) === "async" && getTokenValue(secondToken) === "def")) {
                var isAsync = getTokenValue(firstToken) === "async";
                var funcName = getTokenValue(instruction.tokens[isAsync ? 2 : 1]);
                var paramsTokens = instruction.tokens.slice(instruction.tokens.findIndex(function (tkns) { return getTokenValue(tkns) === '('; }) + 1, instruction.tokens.findIndex(function (tkns) { return getTokenValue(tkns) === ')'; }));
                var params = splitTokens(paramsTokens, ',').map(function (t) { return getTokenValue(t[0]); });
                var endDefOfDef = findTokenValueIndex(instruction.tokens, function (v) { return v === ':'; });
                if (endDefOfDef === -1) {
                    throw ("Can't find : for def");
                }
                var instructionLines = this.tokensToInstructionLines(instruction.tokens, getStartLine(instruction.tokens[endDefOfDef + 1]));
                var funcAst = {
                    name: funcName,
                    body: [],
                    funcs: []
                };
                this.instructionsToNodes(instructionLines, funcAst);
                ast.funcs.push(new FunctionDefNode(funcAst, params, isAsync, getTokenLoc(instruction.tokens[0])));
            }
            else if (getTokenValue(firstToken) === 'if') {
                var endDefOfDef = findTokenValueIndex(instruction.tokens, function (v) { return v === ':'; });
                if (endDefOfDef === -1) {
                    throw ("Can't find : for if");
                }
                var ifBody = getBody(instruction.tokens, endDefOfDef + 1);
                var conditionTokens = instruction.tokens.slice(1, endDefOfDef);
                var conditionNode = (findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)) ?
                    this.groupLogicalOperations(logicOpIndexes, conditionTokens)
                    :
                        this.createExpressionNode(conditionTokens);
                var elseBody = undefined;
                if (instructions.length > i + 1
                    && getTokenValue(instructions[i + 1].tokens[0]) === 'else'
                    && getTokenValue(instructions[i + 1].tokens[1]) === ':') {
                    elseBody = getBody(instructions[i + 1].tokens, 2);
                    i++;
                }
                ast.body.push(new IfNode(conditionNode, ifBody, elseBody, getTokenLoc(firstToken)));
            }
            else if (getTokenValue(firstToken) === 'try') {
                if (getTokenValue(instruction.tokens[1]) !== ':') {
                    throw ("'try' statement should be followed by ':'");
                }
                var tryBody = getBody(instruction.tokens, 2);
                var excepts = [];
                var elseBody = undefined;
                var finallyBody = undefined;
                while (instructions.length > i + 1
                    && (getTokenValue(instructions[i + 1].tokens[0]) === 'else'
                        || getTokenValue(instructions[i + 1].tokens[0]) === 'except'
                        || getTokenValue(instructions[i + 1].tokens[0]) === 'finally')) {
                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'else') {
                        if (elseBody) {
                            throw new Error("Only one 'else' is allowed in a 'try'");
                        }
                        elseBody = getBody(instructions[i + 1].tokens, 2);
                    }
                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'finally') {
                        if (finallyBody) {
                            throw new Error("Only one 'else' is allowed in a 'try'");
                        }
                        finallyBody = getBody(instructions[i + 1].tokens, 2);
                    }
                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'except') {
                        var endIndex = findTokenValueIndex(instructions[i + 1].tokens, function (v) { return v === ':'; });
                        var except = {};
                        if (endIndex === 2) {
                            except.error = { name: getTokenValue(instructions[i + 1].tokens[1]) };
                        }
                        else if (endIndex === 3) {
                            except.error = {
                                name: getTokenValue(instructions[i + 1].tokens[1]),
                                alias: getTokenValue(instructions[i + 1].tokens[2]),
                            };
                        }
                        else if (endIndex === 4) {
                            except.error = {
                                name: getTokenValue(instructions[i + 1].tokens[1]),
                                alias: getTokenValue(instructions[i + 1].tokens[3]),
                            };
                        }
                        else if (endIndex !== 1) {
                            throw new Error("Incorrect 'except:' statement. Valid stats: (except: or except Error: or except Error as e:)");
                        }
                        except.body = getBody(instructions[i + 1].tokens, endIndex + 1);
                        excepts.push(except);
                    }
                    i++;
                }
                if (!excepts.length) {
                    throw new Error('Except: is missing');
                }
                ast.body.push(new TryExceptNode(tryBody, excepts, elseBody, finallyBody, getTokenLoc(firstToken)));
            }
            else if (getTokenValue(firstToken) === 'continue') {
                ast.body.push(new ContinueNode());
            }
            else if (getTokenValue(firstToken) === 'break') {
                ast.body.push(new BreakNode());
            }
            else if (getTokenValue(firstToken) === 'return') {
                ast.body.push(new ReturnNode(instruction.tokens.length > 1 ? this.createExpressionNode(instruction.tokens.slice(1)) : undefined, getTokenLoc(firstToken)));
            }
            else if (getTokenValue(firstToken) === 'raise') {
                if (instruction.tokens.length === 1) {
                    throw new Error("Incorrect 'raise' usage. Please specify error name and message ");
                }
                var errorName = getTokenValue(instruction.tokens[1]);
                var errorMessage = (instruction.tokens.length == 5
                    && getTokenValue(instruction.tokens[2]) === "("
                    && getTokenValue(instruction.tokens[4]) === ")") ? getTokenValue(instruction.tokens[3])
                    : undefined;
                ast.body.push(new RaiseNode(errorName, errorMessage, getTokenLoc(firstToken)));
            }
            else if (getTokenValue(firstToken) === 'for') {
                var endDefOfDef = findTokenValueIndex(instruction.tokens, function (v) { return v === ':'; });
                if (endDefOfDef === -1) {
                    throw ("Can't find : for if");
                }
                var itemVarName = getTokenValue(instruction.tokens[1]);
                var sourceArray = this.createExpressionNode(instruction.tokens.slice(3, endDefOfDef));
                var forBody = getBody(instruction.tokens, endDefOfDef + 1);
                ast.body.push(new ForNode(sourceArray, itemVarName, forBody, getTokenLoc(firstToken)));
            }
            else if (getTokenValue(firstToken) === 'while') {
                var endDefOfDef = findTokenValueIndex(instruction.tokens, function (v) { return v === ':'; });
                if (endDefOfDef === -1) {
                    throw ("Can't find : for [while]");
                }
                var conditionTokens = instruction.tokens.slice(1, endDefOfDef);
                var conditionNode = (findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)) ?
                    this.groupLogicalOperations(logicOpIndexes, conditionTokens)
                    :
                        this.createExpressionNode(conditionTokens);
                var body = getBody(instruction.tokens, endDefOfDef + 1);
                ast.body.push(new WhileNode(conditionNode, body, getTokenLoc(firstToken)));
            }
            else if (getTokenValue(firstToken) === 'import') {
                var asIndex = findTokenValueIndex(instruction.tokens, function (v) { return v === 'as'; });
                if (asIndex < 0) {
                    asIndex = instruction.tokens.length;
                }
                var module_1 = {
                    name: instruction.tokens.slice(1, asIndex).map(function (t) { return getTokenValue(t); }).join(''),
                    alias: instruction.tokens.slice(asIndex + 1).map(function (t) { return getTokenValue(t); }).join('') || undefined
                };
                var body = {}; // empty for now
                ast.body.push(new ImportNode(module_1, body, undefined, getTokenLoc(firstToken)));
            }
            else if (getTokenValue(firstToken) === 'from') {
                var importIndex = findTokenValueIndex(instruction.tokens, function (v) { return v === 'import'; });
                if (importIndex < 0) {
                    throw Error("'import' must follow 'from'");
                }
                var module_2 = {
                    name: instruction.tokens.slice(1, importIndex).map(function (t) { return getTokenValue(t); }).join('')
                };
                var parts = splitTokens(instruction.tokens.slice(importIndex + 1), ',')
                    .map(function (t) {
                    return {
                        name: getTokenValue(t[0]),
                        alias: (t.length === 3) ? getTokenValue(t[2]) : undefined
                    };
                });
                var body = {}; // empty for now
                ast.body.push(new ImportNode(module_2, body, parts, getTokenLoc(firstToken)));
            }
            else if (findIndexes(instruction.tokens, OperationTypes.Assignment, assignTokenIndexes)) {
                var assignTokens = splitTokens(instruction.tokens, '=');
                var target = this.createExpressionNode(assignTokens[0]);
                var source = this.createExpressionNode(assignTokens[1]);
                ast.body.push(new AssignNode(target, source, getTokenLoc(assignTokens[0][0])));
            }
            else if (findIndexes(instruction.tokens, OperationTypes.Logical, logicOpIndexes)) {
                ast.body.push(this.groupLogicalOperations(logicOpIndexes, instruction.tokens));
            }
            else {
                ast.body.push(this.createExpressionNode(instruction.tokens));
            }
        }
    };
    Parser.prototype.sliceWithBrackets = function (a, begin, end) {
        // if expression is in brackets, then we need clean brackets
        if (getTokenValue(a[begin]) === '(' && getTokenType(a[begin]) !== TokenTypes.LiteralString) {
            begin++;
            end--;
        }
        return a.slice(begin, end);
    };
    Parser.prototype.groupComparisonOperations = function (indexes, tokens) {
        var start = 0;
        var leftNode = null;
        for (var i = 0; i < indexes.length; i++) {
            var opToken = getTokenValue(tokens[indexes[i]]);
            leftNode = (leftNode) ? leftNode : this.createExpressionNode(this.sliceWithBrackets(tokens, start, indexes[i]));
            var endInd = (i + 1 < indexes.length) ? indexes[i + 1] : tokens.length;
            var rightNode = this.createExpressionNode(this.sliceWithBrackets(tokens, indexes[i] + 1, endInd));
            leftNode = new BinOpNode(leftNode, opToken, rightNode, getTokenLoc(tokens[0]));
        }
        return leftNode;
    };
    Parser.prototype.groupLogicalOperations = function (logicOp, tokens) {
        var start = 0;
        var logicItems = [];
        for (var i = 0; i < logicOp.length; i++) {
            var opToken = tokens[logicOp[i]];
            var logicalSlice = this.sliceWithBrackets(tokens, start, logicOp[i]);
            logicItems.push({
                node: this.createExpressionNode(logicalSlice),
                op: getTokenValue(opToken)
            });
            start = logicOp[i] + 1;
        }
        logicItems.push({
            node: this.createExpressionNode(this.sliceWithBrackets(tokens, start, tokens.length))
        });
        var lop = new LogicalOpNode(logicItems, getTokenLoc(tokens[0]));
        return lop;
    };
    Parser.prototype.tokensToInstructionLines = function (tokens, startLine) {
        var lines = [];
        var column = 0;
        var line = new InstructionLine();
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var sLine = getStartLine(token);
            var sColumn = getStartColumn(token);
            var value = getTokenValue(token);
            this._currentToken = token;
            if (sLine >= startLine) {
                if (column === sColumn && !")}]".includes(value)) {
                    lines.push(line);
                    line = new InstructionLine();
                }
                line.tokens.push(token);
                // first line defines a minimum indent
                if (column === 0) {
                    column = sColumn;
                }
                // stop looping through if line has less indent
                // it means the corrent block finished
                if (sColumn < column) {
                    break;
                }
            }
        }
        if (line.tokens.length) {
            lines.push(line);
        }
        return lines;
    };
    Parser.prototype.createExpressionNode = function (tokens, prevNode) {
        var _this = this;
        if (tokens.length === 0) {
            throw new Error("Tokens length can't empty.");
        }
        var lastToken = tokens[tokens.length - 1];
        if (getTokenValue(lastToken) === ';' && getTokenType(lastToken) !== TokenTypes.LiteralString) {
            throw new Error("Unexpected symbol ';' in the end");
        }
        this._currentToken = tokens[0];
        // const or variable
        if (tokens.length === 1
            || (tokens.length === 2 && getTokenValue(tokens[1]) === '?')) {
            var firstToken = tokens[0];
            var tokenType = getTokenType(firstToken);
            if (isTokenTypeLiteral(tokenType)) {
                return new ConstNode(firstToken);
            }
            else if (tokenType === TokenTypes.Identifier) {
                return new GetSingleVarNode(firstToken, tokens.length === 2 && getTokenValue(tokens[1]) === '?' || undefined);
            }
            throw Error("Unhandled single token: '" + JSON.stringify(firstToken) + "'");
        }
        // arrow function
        var arrowFuncParts = splitTokens(tokens, '=>');
        if (arrowFuncParts.length > 1) {
            var pArray = getTokenValue(arrowFuncParts[0][0]) === '(' ?
                arrowFuncParts[0].splice(1, arrowFuncParts[0].length - 2)
                : arrowFuncParts[0];
            var params = splitTokens(pArray, ',').map(function (t) { return getTokenValue(t[0]); });
            var instructionLines = this.tokensToInstructionLines(arrowFuncParts[1], 0);
            var funcAst = {
                name: this._moduleName,
                body: [],
                funcs: []
            };
            this.instructionsToNodes(instructionLines, funcAst);
            return new ArrowFuncDefNode(funcAst, params, getTokenLoc(tokens[0]));
        }
        // comparison operations
        var comparissonIndexes = findOperators(tokens, OperationTypes.Comparison);
        if (comparissonIndexes.length) {
            return this.groupComparisonOperations(comparissonIndexes, tokens);
        }
        // create arithmetic expression
        var ops = findOperators(tokens);
        if (ops.length) {
            var prevNode_1 = null;
            for (var i = 0; i < ops.length; i++) {
                var opIndex = ops[i];
                var op = getTokenValue(tokens[opIndex]);
                var nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;
                var nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;
                if (nextOpIndex !== null && (nextOp === '*' || nextOp === '/')) {
                    var rightNode = null;
                    // iterate through all continuous '*', '/' operations
                    do {
                        var nextOpIndex2 = i + 2 < ops.length ? ops[i + 2] : null;
                        var leftSlice2 = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex);
                        var rightSlice2 = this.sliceWithBrackets(tokens, nextOpIndex + 1, nextOpIndex2 || tokens.length);
                        var left2 = this.createExpressionNode(leftSlice2);
                        var right2 = this.createExpressionNode(rightSlice2);
                        rightNode = new BinOpNode(left2, nextOp, right2, getTokenLoc(tokens[opIndex + 1]));
                        i++;
                        nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;
                        nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;
                    } while (nextOpIndex !== null && (nextOp === '*' || nextOp === '/'));
                    // add up result
                    if (prevNode_1 === null) {
                        var leftSlice = this.sliceWithBrackets(tokens, 0, opIndex);
                        prevNode_1 = this.createExpressionNode(leftSlice);
                    }
                    prevNode_1 = new BinOpNode(prevNode_1, op, rightNode, getTokenLoc(tokens[0]));
                }
                else {
                    var leftSlice = prevNode_1 ? [] : this.sliceWithBrackets(tokens, 0, opIndex);
                    var rightSlice = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex || tokens.length);
                    var left = prevNode_1 || this.createExpressionNode(leftSlice, prevNode_1);
                    var right = this.createExpressionNode(rightSlice);
                    prevNode_1 = new BinOpNode(left, op, right, getTokenLoc(tokens[0]));
                }
            }
            if (prevNode_1 === null) {
                throw Error("Can't create node ...");
            }
            return prevNode_1;
        }
        // create DotObjectAccessNode
        var subObjects = splitTokens(tokens, '.');
        if (subObjects.length > 1) {
            return new DotObjectAccessNode(subObjects.map(function (tkns) { return _this.createExpressionNode(tkns); }), getTokenLoc(tokens[0]));
        }
        // create function call node
        if (tokens.length > 2 && getTokenValue(tokens[1]) === '(') {
            var isNullCoelsing = getTokenValue(tokens[tokens.length - 1]) === '?';
            if (isNullCoelsing) {
                // remove '?'
                tokens.pop();
            }
            var name_1 = getTokenValue(tokens[0]);
            var paramsTokensSlice = tokens.slice(2, tokens.length - 1);
            var paramsTokens = splitTokens(paramsTokensSlice, ',');
            var paramsNodes = paramsTokens.map(function (tkns) { return _this.createExpressionNode(tkns); });
            var node = new FunctionCallNode(name_1, paramsNodes, getTokenLoc(tokens[0]));
            node.nullCoelsing = isNullCoelsing || undefined;
            return node;
        }
        // create Object Node
        if (getTokenValue(tokens[0]) === '{' && getTokenValue(tokens[tokens.length - 1]) === '}') {
            var keyValueTokens = splitTokens(tokens.splice(1, tokens.length - 2), ',');
            var props = [];
            for (var i = 0; i < keyValueTokens.length; i++) {
                var keyValue = splitTokens(keyValueTokens[i], ':');
                if (keyValue.length === 1) {
                    var pInfo = {
                        name: new ConstNode(keyValue[0][0]),
                        value: this.createExpressionNode(keyValue[0])
                    };
                    props.push(pInfo);
                }
                else if (keyValue.length === 2) {
                    var name_2 = null;
                    var namePart = keyValue[0];
                    if (namePart.length === 1) {
                        name_2 = new ConstNode(namePart[0]);
                    }
                    else if (getTokenValue(namePart[0]) === '['
                        && getTokenValue(namePart[namePart.length - 1]) === ']') {
                        name_2 = this.createExpressionNode(namePart.slice(1, namePart.length - 1));
                    }
                    else {
                        throw new Error("Incorrect JSON. Can't resolve Key field. That should either constant or expression in []");
                    }
                    var pInfo = {
                        name: name_2,
                        value: this.createExpressionNode(keyValue[1])
                    };
                    props.push(pInfo);
                }
                else {
                    throw Error('Incorrect JSON');
                }
            }
            return new CreateObjectNode(props, getTokenLoc(tokens[0]));
        }
        // create Array Node
        if (getTokenValue(tokens[0]) === '[' && getTokenValue(tokens[tokens.length - 1]) === ']') {
            var items = splitTokens(tokens.splice(1, tokens.length - 2), ',')
                .map(function (tkns) { return _this.createExpressionNode(tkns); });
            return new CreateArrayNode(items, getTokenLoc(tokens[0]));
        }
        // bracket access object node
        if (tokens.length > 2 && getTokenValue(tokens[1]) === '[') {
            var name_3 = getTokenValue(tokens[0]);
            var paramsTokensSlice = tokens.slice(2, tokens.length - 1);
            var paramsNodes = this.createExpressionNode(paramsTokensSlice);
            return new BracketObjectAccessNode(name_3, paramsNodes, false, getTokenLoc(tokens[0]));
        }
        throw Error("Undefined node '" + getTokenValue(tokens[0]) + "'.");
    };
    return Parser;
}());var SeparatorsMap = {
    '\n': ['\n'],
    '=': ['=', '==', '=>'],
    '+': ['+', '++', '+='],
    '-': ['-', '--', '-='],
    '*': ['*', '**', '*='],
    '/': ['/', '//', '/='],
    '.': ['.'],
    '?': ['?'],
    '!': ['!='],
    ':': [':'],
    ',': [','],
    '>': ['>', '>='],
    '<': ['<', '<=', '<>'],
    '(': ['('],
    ')': [')'],
    '{': ['{'],
    '}': ['}'],
    '[': ['['],
    ']': [']'],
};
var Keywords = ["async", "def", "for", "while", "if", "return", "in"];
var Tokenizer = /** @class */ (function () {
    function Tokenizer() {
        this._startLine = 1;
        this._startColumn = 1;
        this._currentLine = 1;
        this._currentColumn = 1;
        this._tokenText = '';
        this._cursor = 0;
        this._script = "";
    }
    Object.defineProperty(Tokenizer.prototype, "tokenText", {
        get: function () {
            return this._tokenText;
        },
        set: function (value) {
            if (!this._tokenText && value) {
                this._startLine = this._currentLine;
                this._startColumn = this._currentColumn;
            }
            this._tokenText = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Splits script code into a tokens
     * @param script A jsPython text
     */
    Tokenizer.prototype.tokenize = function (script) {
        if (!script || !script.length) {
            return [];
        }
        script = script
            .replace(new RegExp('\t', 'g'), '  ') // replace all tabs with 2 spaces
            .replace(new RegExp('\r', 'g'), ''); // remove all \r symbols
        this._script = script;
        this._cursor = 0;
        this._startLine = 1;
        this._startColumn = 1;
        this._currentLine = 1;
        this._currentColumn = 1;
        var tokens = [];
        var first = true;
        // handle initial spaces
        while (script[this._cursor] === '\n') {
            this.incrementCursor();
            if (first) {
                this._currentLine++;
                first = false;
            }
            this._currentColumn = 1;
        }
        do {
            var symbol = script[this._cursor];
            if (symbol == ' ' && this.tokenText.length !== 0) {
                this.tokenText = this.processToken(this.tokenText, tokens);
                continue;
            }
            else if ((SeparatorsMap[symbol] !== undefined) && !this.isPartOfNumber(symbol, tokens)) {
                // handle numbers with floating point e.g. 3.14
                this.tokenText = this.processToken(this.tokenText, tokens);
                this.tokenText = symbol;
                var sepsMap = SeparatorsMap[symbol];
                if (sepsMap.length >= 1) {
                    // process longer operators
                    while (sepsMap.includes(this.tokenText + script[this._cursor + 1])) {
                        this.tokenText += script[this.incrementCursor()];
                    }
                }
                this.tokenText = this.processToken(this.tokenText, tokens, false, TokenTypes.Operator);
            }
            else if (symbol === '#') {
                var first_1 = true;
                while (script[this.incrementCursor()] !== '\n') {
                    this.tokenText += script[this._cursor];
                    // correct start column
                    if (first_1) {
                        first_1 = false;
                        this._startColumn = this._startColumn - 1;
                    }
                    if (this._cursor + 1 >= script.length)
                        break;
                }
                this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.Comment);
            }
            else if (symbol === '"' || symbol === "'") {
                // remember either it is single or double quote
                var q = symbol;
                // we are not expecting token to be added here.
                // it should pass a failt to parser
                this.tokenText = this.processToken(this.tokenText, tokens);
                // handle """ comment """"
                if (script[this._cursor + 1] === q && script[this._cursor + 2] === q) {
                    var cLine = this._currentLine;
                    var cColumn = this._currentColumn;
                    this.incrementCursor(2);
                    var passCond = true;
                    while (passCond) {
                        this.tokenText += script[this.incrementCursor()];
                        if (this._cursor + 3 >= script.length
                            || (script[this._cursor + 1] === q && script[this._cursor + 2] === q && script[this._cursor + 3] === q)) {
                            break;
                        }
                    }
                    // a special case when multiline string
                    this._startLine = cLine;
                    this._startColumn = cColumn;
                    this.incrementCursor(3);
                }
                else {
                    while (script[this.incrementCursor()] !== q) {
                        this.tokenText += script[this._cursor];
                        if (this._cursor + 1 >= script.length)
                            break;
                    }
                    //start column needs to take into account a begining quote, not just a string
                    this._startColumn--;
                }
                // a special case when empty string
                if (this.tokenText.length === 0) {
                    this._startLine = this._currentLine;
                    this._startColumn = this._currentColumn;
                }
                this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.LiteralString);
            }
            else if (symbol != ' ') {
                this.tokenText += symbol;
            }
        } while (this.incrementCursor() < script.length);
        this.processToken(this.tokenText, tokens);
        return tokens;
    };
    Tokenizer.prototype.incrementCursor = function (count) {
        if (count === void 0) { count = 1; }
        for (var i = 0; i < count; i++) {
            this._cursor = this._cursor + 1;
            if (this._script[this._cursor] === '\n') {
                this._currentLine++;
                this._currentColumn = 0;
            }
            else {
                this._currentColumn++;
            }
        }
        return this._cursor;
    };
    Tokenizer.prototype.recognizeToken = function (tokenText, type) {
        if (type === void 0) { type = null; }
        var value = tokenText;
        if (type === null) {
            if (tokenText === 'null') {
                type = TokenTypes.LiteralNull;
                value = null;
            }
            else if (tokenText === 'true' || tokenText === 'false') {
                type = TokenTypes.LiteralBool;
                value = tokenText === 'true';
            }
            else if (this.parseNumberOrNull(tokenText) !== null) {
                type = TokenTypes.LiteralNumber;
                value = this.parseNumberOrNull(tokenText);
            }
            else if (Keywords.indexOf(tokenText) >= 0) {
                type = TokenTypes.Keyword;
            }
            else {
                type = TokenTypes.Identifier;
            }
        }
        return {
            value: value,
            type: type
        };
    };
    Tokenizer.prototype.processToken = function (strToken, tokens, allowEmptyString, type) {
        if (allowEmptyString === void 0) { allowEmptyString = false; }
        if (type === void 0) { type = null; }
        // ignore empty tokens
        if (!strToken.length && !allowEmptyString || strToken === '\n')
            return "";
        var token = this.recognizeToken(strToken, type);
        tokens.push([token.value, Uint16Array.of(token.type, this._startLine, this._startColumn, this._currentLine, this._currentColumn)]);
        return "";
    };
    Tokenizer.prototype.parseNumberOrNull = function (value) {
        if (typeof value === 'number') {
            return value;
        }
        if (!value || typeof value !== 'string') {
            return null;
        }
        value = value.trim();
        // Just to make sure string contains digits only and '.', ','. Otherwise, parseFloat can incorrectly parse into number
        for (var i = value.length - 1; i >= 0; i--) {
            var d = value.charCodeAt(i);
            if (d < 48 || d > 57) {
                // '.' - 46 ',' - 44 '-' - 45(but only first char)
                if (d !== 46 && d !== 44 && (d !== 45 || i !== 0))
                    return null;
            }
        }
        var res = parseFloat(value);
        return !isNaN(res) ? res : null;
    };
    Tokenizer.prototype.isPartOfNumber = function (symbol, currentTokens) {
        if (symbol === '-' && !this.tokenText.length) {
            // '-' needs to be handled e.g. -3; 2 + -2 etc
            var prevToken = (currentTokens.length !== 0) ? currentTokens[currentTokens.length - 1] : null;
            return prevToken === null || (getTokenType(prevToken) === TokenTypes.Operator && getTokenValue(prevToken) !== ')');
        }
        else if (symbol === '.' && this.parseNumberOrNull(this.tokenText) !== null) {
            return true;
        }
        return false;
    };
    return Tokenizer;
}());function jsPython() {
    return Interpreter.create();
}
var Interpreter = /** @class */ (function () {
    function Interpreter() {
        this.initialScope = __assign({}, INITIAL_SCOPE);
        this._lastExecutionContext = null;
    }
    Interpreter.create = function () {
        return new Interpreter();
    };
    Object.defineProperty(Interpreter.prototype, "initialExecutionContext", {
        get: function () {
            return this.initialScope;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Interpreter.prototype, "lastExecutionContext", {
        get: function () {
            return this._lastExecutionContext;
        },
        enumerable: false,
        configurable: true
    });
    Interpreter.prototype.cleanUp = function () {
        this._lastExecutionContext = null;
    };
    Interpreter.prototype.jsPythonInfo = function () {
        return INITIAL_SCOPE.jsPython();
    };
    Interpreter.prototype.tokenize = function (script) {
        var tokenizer = new Tokenizer();
        return tokenizer.tokenize(script);
    };
    Interpreter.prototype.parse = function (script, moduleName) {
        if (moduleName === void 0) { moduleName = 'main.jspy'; }
        var tokenizer = new Tokenizer();
        var parser = new Parser();
        var jspyAst = parser.parse(tokenizer.tokenize(script), moduleName);
        return jspyAst;
    };
    Interpreter.prototype.eval = function (codeOrAst, scope, entryFunctionName, moduleName) {
        if (scope === void 0) { scope = {}; }
        if (entryFunctionName === void 0) { entryFunctionName = ''; }
        if (moduleName === void 0) { moduleName = 'main.jspy'; }
        var ast = (typeof codeOrAst === 'string') ? this.parse(codeOrAst, moduleName) : codeOrAst;
        var blockContext = {
            moduleName: moduleName,
            blockScope: new Scope(scope)
        };
        blockContext.blockScope.set('printExecutionContext', function () { return console.log(blockContext.blockScope.getScope()); });
        blockContext.blockScope.set('getExecutionContext', function () { return blockContext.blockScope.getScope(); });
        this._lastExecutionContext = blockContext.blockScope.getScope();
        var result = new Evaluator().evalBlock(ast, blockContext);
        if (!entryFunctionName || !entryFunctionName.length) {
            return result;
        }
        else {
            var func = blockContext.blockScope.get(entryFunctionName);
            if (typeof func !== 'function') {
                throw Error("Function " + entryFunctionName + " does not exists or not a function");
            }
            return func();
        }
    };
    Interpreter.prototype.evalAsync = function (codeOrAst, scope, entryFunctionName, moduleName) {
        if (scope === void 0) { scope = {}; }
        if (entryFunctionName === void 0) { entryFunctionName = ''; }
        if (moduleName === void 0) { moduleName = 'main.jspy'; }
        return __awaiter(this, void 0, void 0, function () {
            var ast, evaluator, blockContext, result, func;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        ast = (typeof codeOrAst === 'string') ? this.parse(codeOrAst, moduleName) : codeOrAst;
                        evaluator = new EvaluatorAsync();
                        blockContext = {
                            moduleName: moduleName,
                            blockScope: new Scope(scope)
                        };
                        blockContext.blockScope.set('printExecutionContext', function () { return console.log(blockContext.blockScope.getScope()); });
                        blockContext.blockScope.set('getExecutionContext', function () { return blockContext.blockScope.getScope(); });
                        this._lastExecutionContext = blockContext.blockScope.getScope();
                        return [4 /*yield*/, evaluator
                                .registerJsonFileLoader(function (modulePath) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, (this.moduleLoader ? this.moduleLoader(modulePath)
                                                : Promise.reject('ModuleLoader is not registered'))];
                                        case 1: return [2 /*return*/, _a.sent()];
                                    }
                                });
                            }); })
                                .registerModuleParser(function (modulePath) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.moduleParser(modulePath)];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            }); }); })
                                .registerBlockContextFactory(function (moduleName, ast) {
                                // enrich context
                                var newContext = _this.assignImportContext(ast, scope);
                                var moduleContext = { moduleName: moduleName, blockScope: new Scope(newContext) };
                                moduleContext.blockScope.set('printExecutionContext', function () { return console.log(moduleContext.blockScope.getScope()); });
                                moduleContext.blockScope.set('getExecutionContext', function () { return moduleContext.blockScope.getScope(); });
                                return moduleContext;
                            })
                                .evalBlockAsync(ast, blockContext)];
                    case 1:
                        result = _a.sent();
                        if (!(!entryFunctionName || !entryFunctionName.length)) return [3 /*break*/, 2];
                        return [2 /*return*/, result];
                    case 2:
                        func = blockContext.blockScope.get(entryFunctionName);
                        if (typeof func !== 'function') {
                            throw Error("Function " + entryFunctionName + " does not exists or not a function");
                        }
                        return [4 /*yield*/, func()];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Compatibility method (with v1). !
     */
    Interpreter.prototype.evaluate = function (script, context, entryFunctionName, moduleName) {
        if (context === void 0) { context = {}; }
        if (entryFunctionName === void 0) { entryFunctionName = ''; }
        if (moduleName === void 0) { moduleName = 'main.jspy'; }
        return __awaiter(this, void 0, void 0, function () {
            var ast, globalScope;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!script || !script.length) {
                            return [2 /*return*/, null];
                        }
                        ast = this.parse(script, moduleName);
                        context = (context && typeof context === 'object') ? context : {};
                        context = this.assignImportContext(ast, context);
                        globalScope = __assign(__assign({}, this.initialScope), context);
                        return [4 /*yield*/, this.evalAsync(ast, globalScope, entryFunctionName, moduleName)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Interpreter.prototype.registerPackagesLoader = function (loader) {
        if (typeof loader === 'function') {
            this.packageLoader = loader;
        }
        else {
            throw Error('PackagesLoader');
        }
        return this;
    };
    Interpreter.prototype.registerModuleLoader = function (loader) {
        if (typeof loader === 'function') {
            this.moduleLoader = loader;
        }
        else {
            throw Error('ModuleLoader should be a function');
        }
        return this;
    };
    Interpreter.prototype.addFunction = function (funcName, fn) {
        this.initialScope[funcName] = fn;
        return this;
    };
    Interpreter.prototype.assignGlobalContext = function (obj) {
        Object.assign(this.initialScope, obj);
        return this;
    };
    Interpreter.prototype.hasFunction = function (scripts, funcName) {
        if (scripts === void 0) { scripts = ''; }
        return scripts.indexOf("def " + funcName) > -1;
    };
    Interpreter.prototype.assignImportContext = function (ast, context) {
        var nodeToPackage = function (im) {
            var _a;
            return {
                name: im.module.name,
                as: im.module.alias,
                properties: (_a = im.parts) === null || _a === void 0 ? void 0 : _a.map(function (p) { return ({ name: p.name, as: p.alias }); })
            };
        };
        var importNodes = ast.body.filter(function (n) { return n.type === 'import'; });
        var jsImport = importNodes
            .filter(function (im) { return getImportType(im.module.name) === 'jsPackage'; })
            .map(function (im) { return nodeToPackage(im); });
        if (jsImport.length && this.packageLoader) {
            var libraries = this.packageResolver(jsImport);
            context = __assign(__assign({}, context), libraries);
        }
        return context;
    };
    Interpreter.prototype.moduleParser = function (modulePath) {
        return __awaiter(this, void 0, void 0, function () {
            var content;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.moduleLoader) {
                            throw new Error('Module Loader is not registered');
                        }
                        return [4 /*yield*/, this.moduleLoader(modulePath)];
                    case 1:
                        content = _a.sent();
                        return [2 /*return*/, this.parse(content, modulePath)];
                }
            });
        });
    };
    Interpreter.prototype.packageResolver = function (packages) {
        var _this = this;
        if (!this.packageLoader) {
            throw Error('Package loader not provided.');
        }
        var libraries = {};
        packages.forEach(function (_a) {
            var name = _a.name, as = _a.as, properties = _a.properties;
            var lib = _this.packageLoader && _this.packageLoader(name);
            if (properties === null || properties === void 0 ? void 0 : properties.length) {
                properties.forEach(function (prop) {
                    libraries[prop.as || prop.name] = lib[prop.name];
                });
            }
            else if (as) {
                libraries[as] = lib;
            }
            else {
                libraries[name] = lib;
            }
            if (as) {
                libraries[as] = lib;
            }
        });
        return libraries;
    };
    return Interpreter;
}());export{Interpreter,jsPython};//# sourceMappingURL=jspython-interpreter.esm.js.map
