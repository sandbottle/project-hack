{"version":3,"file":"jspython-interpreter.min.js","sources":["../src/common/utils.ts","../src/common/operators.ts","../src/common/token-types.ts","../src/common/ast-types.ts","../src/evaluator/scope.ts","../src/evaluator/evaluator.ts","../src/evaluator/evaluatorAsync.ts","../src/initialScope.ts","../src/parser/parser.ts","../src/tokenizer/tokenizer.ts","../src/interpreter.ts"],"sourcesContent":["import { Token } from \"./token-types\";\r\n\r\nexport function parseDatetimeOrNull(value: string | Date): Date | null {\r\n    if (!value) { return null; }\r\n    if (value instanceof Date && !isNaN(value.valueOf())) { return value; }\r\n    // only string values can be converted to Date\r\n    if (typeof value !== 'string') { return null; }\r\n\r\n    const strValue = String(value);\r\n    if (!strValue.length) { return null; }\r\n\r\n    const parseMonth = (mm: string): number => {\r\n        if (!mm || !mm.length) {\r\n            return NaN;\r\n        }\r\n\r\n        const m = parseInt(mm, 10);\r\n        if (!isNaN(m)) {\r\n            return m - 1;\r\n        }\r\n\r\n        // make sure english months are coming through\r\n        if (mm.startsWith('jan')) { return 0; }\r\n        if (mm.startsWith('feb')) { return 1; }\r\n        if (mm.startsWith('mar')) { return 2; }\r\n        if (mm.startsWith('apr')) { return 3; }\r\n        if (mm.startsWith('may')) { return 4; }\r\n        if (mm.startsWith('jun')) { return 5; }\r\n        if (mm.startsWith('jul')) { return 6; }\r\n        if (mm.startsWith('aug')) { return 7; }\r\n        if (mm.startsWith('sep')) { return 8; }\r\n        if (mm.startsWith('oct')) { return 9; }\r\n        if (mm.startsWith('nov')) { return 10; }\r\n        if (mm.startsWith('dec')) { return 11; }\r\n\r\n        return NaN;\r\n    };\r\n\r\n    const correctYear = (yy: number) => {\r\n        if (yy < 100) {\r\n            return yy < 68 ? yy + 2000 : yy + 1900;\r\n        } else {\r\n            return yy;\r\n        }\r\n    };\r\n\r\n    const validDateOrNull =\r\n        (yyyy: number, month: number, day: number, hours: number, mins: number, ss: number): Date | null => {\r\n            if (month > 11 || day > 31 || hours >= 60 || mins >= 60 || ss >= 60) { return null; }\r\n\r\n            const dd = new Date(yyyy, month, day, hours, mins, ss, 0);\r\n            return !isNaN(dd.valueOf()) ? dd : null;\r\n        };\r\n\r\n    const strTokens = strValue.replace('T', ' ').toLowerCase().split(/[: /-]/);\r\n    const dt = strTokens.map(parseFloat);\r\n\r\n    // try ISO first\r\n    let d = validDateOrNull(dt[0], dt[1] - 1, dt[2], dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    // then UK\r\n    d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[1]), dt[0], dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    // then US\r\n    d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[0]), correctYear(dt[1]), dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    return null;\r\n}\r\n\r\nexport function getImportType(name: string): 'jspyModule' | 'jsPackage' | 'json' {\r\n\r\n    if (name.startsWith('/') || name.startsWith('./')) {\r\n        return (name.endsWith('.json')) ? 'json' : 'jspyModule';\r\n    }\r\n\r\n    return 'jsPackage';\r\n}\r\n\r\nfunction jspyErrorMessage(error: string, module: string, line: number, column: number, message: string): string {\r\n    return `${error}: ${module}(${line},${column}): ${message}`;\r\n}\r\n\r\nexport class JspyTokenizerError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyTokenizerError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyTokenizerError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyParserError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyParserError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyParserError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyEvalError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyEvalError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyEvalError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyError extends Error {\r\n\r\n    constructor(public module: string, public line: number, public column: number, public name: string, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyError\", module || 'name.jspy', line, column, message);\r\n        Object.setPrototypeOf(this, JspyError.prototype);\r\n    }\r\n}\r\n","export enum OperationTypes {\r\n    Arithmetic, Assignment, Comparison, Logical, Membership\r\n};\r\n\r\nexport type AssignmentOperators = \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"++\" | \"--\";\r\nexport type ArithmeticOperators = \"+\" | \"-\" | \"*\" | \"/\" | \"%\" | \"**\" | \"//\";\r\nexport type ComparisonOperators = \">\" | \">=\" | \"==\" | \"!=\" | \"<>\" | \"<\" | \"<=\";\r\nexport type LogicalOperators = \"and\" | \"or\"; // | \"not\" | \"not in\";\r\nexport type MembershipOperators = \"in\";\r\n\r\nexport type Operators = AssignmentOperators | ArithmeticOperators | ComparisonOperators | LogicalOperators | MembershipOperators;\r\n\r\nexport const OperatorsMap: Record<Operators, OperationTypes> = {\r\n    \"+\": OperationTypes.Arithmetic,\r\n    \"-\": OperationTypes.Arithmetic,\r\n    \"*\": OperationTypes.Arithmetic,\r\n    \"/\": OperationTypes.Arithmetic,\r\n    \"%\": OperationTypes.Arithmetic,\r\n    \"**\": OperationTypes.Arithmetic,\r\n    \"//\": OperationTypes.Arithmetic,\r\n\r\n    \">\": OperationTypes.Comparison,\r\n    \">=\": OperationTypes.Comparison,\r\n    \"==\": OperationTypes.Comparison,\r\n    \"!=\": OperationTypes.Comparison,\r\n    \"<>\": OperationTypes.Comparison,\r\n    \"<\": OperationTypes.Comparison,\r\n    \"<=\": OperationTypes.Comparison,\r\n\r\n    \"and\": OperationTypes.Logical,\r\n    \"or\": OperationTypes.Logical,\r\n    // \"not\": OperationTypes.Logical,\r\n    // \"not in\": OperationTypes.Logical,\r\n\r\n    \"in\": OperationTypes.Membership,\r\n\r\n    \"=\": OperationTypes.Assignment,\r\n    \"+=\": OperationTypes.Assignment,\r\n    \"-=\": OperationTypes.Assignment,\r\n    \"*=\": OperationTypes.Assignment,\r\n    \"/=\": OperationTypes.Assignment,\r\n    \"++\": OperationTypes.Assignment,\r\n    \"--\": OperationTypes.Assignment,\r\n};\r\n\r\nexport type Primitive = string | number | boolean | null;\r\n\r\nexport type ExpressionOperators = ArithmeticOperators | ComparisonOperators | LogicalOperators | MembershipOperators;\r\ntype ExpressionOperation = (l: Primitive, r: Primitive) => Primitive;\r\n\r\nexport const OperationFuncs: Record<ExpressionOperators, ExpressionOperation> = {\r\n    \"+\": (l, r) => arithmeticOperation(l, r, \"+\"),\r\n    \"-\": (l, r) => arithmeticOperation(l, r, \"-\"),\r\n    \"/\": (l, r) => arithmeticOperation(l, r, \"/\"),\r\n    \"*\": (l, r) => arithmeticOperation(l, r, \"*\"),\r\n    \"%\": (l, r) => arithmeticOperation(l, r, \"%\"),\r\n    \"**\": (l, r) => arithmeticOperation(l, r, \"**\"),\r\n    \"//\": (l, r) => arithmeticOperation(l, r, \"//\"),\r\n\r\n    \">\": (l, r) => comparissonOperation(l, r, \">\"),\r\n    \">=\": (l, r) => comparissonOperation(l, r, \">=\"),\r\n    \"<\": (l, r) => comparissonOperation(l, r, \"<\"),\r\n    \"<=\": (l, r) => comparissonOperation(l, r, \"<=\"),\r\n    \"==\": (l, r) => comparissonOperation(l, r, \"==\"),\r\n    \"!=\": (l, r) => comparissonOperation(l, r, \"!=\"),\r\n    \"<>\": (l, r) => comparissonOperation(l, r, \"<>\"),\r\n\r\n    \"and\": (l, r) => logicalOperation(l, r, \"and\"),\r\n    \"or\": (l, r) => logicalOperation(l, r, \"or\"),\r\n    // \"not\": (l, r) => logicalOperation(l, r, \"not\"),\r\n    // \"not in\": (l, r) => logicalOperation(l, r, \"not in\"),\r\n\r\n    \"in\": (l, r) => membershipOperation(l, r, \"in\")\r\n}\r\n\r\nfunction membershipOperation(l: Primitive, r: Primitive, op: MembershipOperators): Primitive {\r\n    if(typeof l === 'string'){\r\n        return (l as string).includes(String(r));\r\n    }\r\n\r\n    if(Array.isArray(l)){\r\n        return (l as any[]).includes(r);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction logicalOperation(l: Primitive, r: Primitive, op: LogicalOperators): Primitive {\r\n    switch (op) {\r\n        case 'and':\r\n            return l as any && r as any;\r\n\r\n        case 'or':\r\n            return (l as any) || (r as any);\r\n    }\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction comparissonOperation(l: Primitive, r: Primitive, op: ComparisonOperators): Primitive {\r\n    switch (op) {\r\n        case '==':\r\n            return l as any === r as any;\r\n\r\n        case '!=':\r\n            return (l as any) !== (r as any);\r\n\r\n        case '<>':\r\n            return (l as any) !== (r as any);\r\n\r\n        case '>':\r\n            return (l as number) > (r as number);\r\n\r\n        case '<':\r\n            return (l as number) < (r as number);\r\n\r\n        case '>=':\r\n            return (l as number) >= (r as number);\r\n\r\n        case '<=':\r\n            return (l as number) <= (r as number);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction arithmeticOperation(l: Primitive, r: Primitive, op: ArithmeticOperators): Primitive {\r\n\r\n    switch (op) {\r\n        case '+':\r\n            return l as any + r as any;\r\n\r\n        case '-':\r\n            return (l as any) - (r as any);\r\n\r\n        case '*':\r\n            return (l as number) * (r as number);\r\n\r\n        case '/':\r\n            return (l as number) / (r as number);\r\n\r\n        case '%':\r\n            return (l as number) % (r as number);\r\n\r\n        case '**':\r\n            return Math.pow(l as number, r as number);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}","import { OperationTypes, Operators, OperatorsMap } from \"./operators\";\r\n\r\nexport enum TokenTypes {\r\n    Identifier = 0,\r\n    Keyword = 1,\r\n    Separator = 2,\r\n    Operator = 3,\r\n    LiteralNumber = 4,\r\n    LiteralBool = 5,\r\n    LiteralString = 6,\r\n    LiteralNull = 7,\r\n    Comment = 8\r\n}\r\n/**\r\n * Token represent a single considered token in a script. Is represented as an array, where element at:\r\n *  0 : value\r\n *  1 : token details. For a memory and performance reasons we use Uint16Array with 5 elements in it:\r\n *    [\r\n *      0 - tokenType number equivalent of @TokenTypes\r\n *      1 - beginLine\r\n *      2 - beginColumn\r\n *      3 - endLine\r\n *      4 - endColumn\r\n *    ]\r\n * [(value). Uint16Array[5]([tokenType, beginLine, beginColumn, endLine, endColumn])]\r\n * tokenType\r\n */\r\nexport type Token = [string | number | boolean | null, Uint16Array];\r\nexport type TokenValue = string | number | boolean | null;\r\n\r\nexport function isTokenTypeLiteral(tokenType: TokenTypes): boolean {\r\n    return tokenType === TokenTypes.LiteralString\r\n        || tokenType === TokenTypes.LiteralNumber\r\n        || tokenType === TokenTypes.LiteralBool\r\n        || tokenType === TokenTypes.LiteralNull;\r\n}\r\n\r\nexport function getTokenType(token: Token): TokenTypes {\r\n    return token[1][0] as TokenTypes;\r\n}\r\n\r\nexport function getTokenValue(token: Token | null): TokenValue {\r\n    return token ? token[0] : null;\r\n}\r\n\r\nexport function getTokenLoc(token: Token): Uint16Array {\r\n    return token[1].subarray(1);\r\n}\r\n\r\nexport function getStartLine(token: Token): number {\r\n    return token[1][1];\r\n}\r\n\r\nexport function getStartColumn(token: Token): number {\r\n    return token[1][2];\r\n}\r\n\r\nexport function getEndLine(token: Token): number {\r\n    return token[1][3];\r\n}\r\n\r\nexport function getEndColumn(token: Token): number {\r\n    return token[1][4];\r\n}\r\n\r\nexport function splitTokens(tokens: Token[], separator: string): Token[][] {\r\n    const result: Token[][] = [];\r\n\r\n    if (!tokens.length) { return []; }\r\n\r\n    const sepIndexes = findTokenValueIndexes(tokens, value => value === separator);\r\n\r\n    let start = 0;\r\n    for (let i = 0; i < sepIndexes.length; i++) {\r\n        const ind = sepIndexes[i];\r\n        result.push(tokens.slice(start, ind));\r\n        start = ind + 1\r\n    }\r\n\r\n    result.push(tokens.slice(start, tokens.length));\r\n    return result;\r\n}\r\n\r\nexport function findTokenValueIndex(tokens: Token[], predicate: (value: TokenValue) => boolean, start = 0): number {\r\n    for (let i = start; i < tokens.length; i++) {\r\n        if (getTokenType(tokens[i]) === TokenTypes.LiteralString) { continue; }\r\n\r\n        if (getTokenValue(tokens[i]) === '(') {\r\n            i = skipInnerBrackets(tokens, i, '(', ')');\r\n        } else if (getTokenValue(tokens[i]) === '[') {\r\n            i = skipInnerBrackets(tokens, i, '[', ']');\r\n        } else if (getTokenValue(tokens[i]) === '{') {\r\n            i = skipInnerBrackets(tokens, i, '{', '}');\r\n        } else if (predicate(getTokenValue(tokens[i]))) {\r\n            return i;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nexport function findTokenValueIndexes(tokens: Token[], predicate: (value: TokenValue) => boolean): number[] {\r\n    const opIndexes: number[] = [];\r\n\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        const tValue = getTokenValue(tokens[i]);\r\n        const tType = getTokenType(tokens[i]);\r\n\r\n        if (tType === TokenTypes.LiteralString) { continue; }\r\n\r\n        if (tValue === '(') {\r\n            i = skipInnerBrackets(tokens, i, '(', ')');\r\n        } else if (tValue === '[') {\r\n            i = skipInnerBrackets(tokens, i, '[', ']');\r\n        } else if (tValue === '{') {\r\n            i = skipInnerBrackets(tokens, i, '{', '}');\r\n        } else if (predicate(tValue)) {\r\n            opIndexes.push(i);\r\n        }\r\n    }\r\n\r\n    return opIndexes;\r\n}\r\n\r\nexport function findOperators(tokens: Token[], operationType: OperationTypes | null = null): number[] {\r\n    return !operationType ? findTokenValueIndexes(tokens, value => OperatorsMap[value as Operators] !== undefined)\r\n        :\r\n        findTokenValueIndexes(tokens, value => OperatorsMap[value as Operators] === operationType);\r\n}\r\n\r\nfunction skipInnerBrackets(tokens: Token[], i: number, openChar: string, closeChar: string): number {\r\n    let innerBrackets = 0;\r\n    while (getTokenValue(tokens[++i]) !== closeChar || innerBrackets !== 0) {\r\n        if (i + 1 >= tokens.length) {\r\n            throw new Error(`Closing '${closeChar}' is missing`);\r\n        }\r\n\r\n        const tokenValue = getTokenValue(tokens[i]);\r\n        if (tokenValue === openChar) { innerBrackets++; }\r\n        if (tokenValue === closeChar) { innerBrackets--; }\r\n    }\r\n    return i;\r\n};\r\n","import { ExpressionOperators, LogicalOperators, OperationTypes, Operators } from \"./operators\";\r\nimport { getTokenLoc, getTokenValue, Token } from \"./token-types\";\r\n\r\nexport type AstNodeType = 'assign' | 'binOp' | 'const'\r\n    | 'logicalOp'\r\n    | 'getSingleVar' | 'setSingleVar' | 'dotObjectAccess' | 'bracketObjectAccess'\r\n    | 'funcCall' | 'funcDef' | 'arrowFuncDef'\r\n    | 'createObject' | 'createArray'\r\n    | 'if' | 'for' | 'while' | 'tryExcept' | 'raise'\r\n    | 'import' | 'comment'\r\n    | 'return' | 'continue' | 'break';\r\n\r\nexport interface NameAlias {\r\n    name: string,\r\n    alias: string | undefined\r\n}\r\n\r\nexport interface ExceptBody {\r\n    error: NameAlias;\r\n    body: AstNode[];\r\n}\r\n    \r\nexport interface FuncDefNode {\r\n    params: string[];\r\n    funcAst: AstBlock;\r\n}\r\n\r\nexport interface IsNullCoelsing {\r\n    nullCoelsing: boolean | undefined\r\n}\r\n\r\nexport interface ObjectPropertyInfo {\r\n    name: AstNode;\r\n    value: AstNode;\r\n}\r\n\r\nexport abstract class AstNode {\r\n    loc: Uint16Array | undefined = undefined;\r\n    constructor(public type: AstNodeType) { }\r\n}\r\n\r\nexport class AssignNode extends AstNode {\r\n    constructor(\r\n        public target: AstNode,\r\n        public source: AstNode,\r\n        public loc: Uint16Array) {\r\n        super('assign');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ConstNode extends AstNode {\r\n    public value: number | string | boolean | null;\r\n\r\n    constructor(token: Token) {\r\n        super('const');\r\n        this.value = getTokenValue(token);\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class CommentNode extends AstNode {\r\n    constructor(public comment: string, public loc: Uint16Array) {\r\n        super('comment');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ReturnNode extends AstNode {\r\n    constructor(public returnValue: AstNode | undefined = undefined, public loc: Uint16Array) {\r\n        super('return');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class RaiseNode extends AstNode {\r\n    constructor(public errorName: string, public errorMessage: string | undefined, public loc: Uint16Array) {\r\n        super('raise');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ContinueNode extends AstNode {\r\n    constructor() {\r\n        super('continue');\r\n    }\r\n}\r\n\r\nexport class BreakNode extends AstNode {\r\n    constructor() {\r\n        super('break');\r\n    }\r\n}\r\n\r\nexport class SetSingleVarNode extends AstNode {\r\n    public name: string;\r\n    constructor(token: Token) {\r\n        super('setSingleVar');\r\n        this.name = token[0] as string\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class FunctionCallNode extends AstNode implements IsNullCoelsing {\r\n    public nullCoelsing: boolean | undefined = undefined;\r\n\r\n    constructor(public name: string, public paramNodes: AstNode[] | null, public loc: Uint16Array) {\r\n        super('funcCall');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class FunctionDefNode extends AstNode implements FuncDefNode {\r\n    constructor(public funcAst: AstBlock, public params: string[], public isAsync: boolean, public loc: Uint16Array) {\r\n        super('funcDef');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ArrowFuncDefNode extends AstNode implements FuncDefNode {\r\n    constructor(public funcAst: AstBlock, public params: string[], public loc: Uint16Array) {\r\n        super('arrowFuncDef');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class IfNode extends AstNode {\r\n    constructor(\r\n        public conditionNode: AstNode,\r\n        public ifBody: AstNode[],\r\n        public elseBody: AstNode[] | undefined = undefined,\r\n        public loc: Uint16Array) {\r\n        super('if');\r\n        this.loc = loc\r\n    }\r\n}\r\n\r\nexport class TryExceptNode extends AstNode {\r\n    constructor(\r\n        public tryBody: AstNode[],\r\n        public exepts: ExceptBody[],\r\n        public elseBody: AstNode[] | undefined,\r\n        public finallyBody: AstNode[] | undefined,\r\n        \r\n        public loc: Uint16Array) {\r\n        super('tryExcept');\r\n        this.loc = loc\r\n    }\r\n}\r\n\r\nexport class ForNode extends AstNode {\r\n    constructor(public sourceArray: AstNode, public itemVarName: string, public body: AstNode[], public loc: Uint16Array) {\r\n        super('for');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class WhileNode extends AstNode {\r\n    constructor(public condition: AstNode, public body: AstNode[], public loc: Uint16Array) {\r\n        super('while');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ImportNode extends AstNode {\r\n    constructor(public module: NameAlias, public body: AstBlock, public parts: NameAlias[] | undefined = undefined, public loc: Uint16Array) {\r\n        super('import');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class GetSingleVarNode extends AstNode implements IsNullCoelsing {\r\n    name: string;\r\n    nullCoelsing: boolean | undefined = undefined;\r\n\r\n    constructor(token: Token, nullCoelsing: boolean | undefined = undefined) {\r\n        super('getSingleVar');\r\n        this.name = token[0] as string;\r\n        this.nullCoelsing = nullCoelsing;\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class DotObjectAccessNode extends AstNode {\r\n    constructor(public nestedProps: AstNode[], public loc: Uint16Array) {\r\n        super('dotObjectAccess');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class CreateObjectNode extends AstNode {\r\n    constructor(public props: ObjectPropertyInfo[], public loc: Uint16Array) {\r\n        super('createObject');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class CreateArrayNode extends AstNode {\r\n    constructor(public items: AstNode[], public loc: Uint16Array) {\r\n        super('createArray');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class BracketObjectAccessNode extends AstNode {\r\n    constructor(\r\n        public propertyName: string,\r\n        public bracketBody: AstNode,\r\n        public nullCoalescing: boolean | undefined = undefined,\r\n        public loc: Uint16Array) {\r\n        super('bracketObjectAccess');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport interface LogicalNodeItem {\r\n    node: AstNode,\r\n    op: LogicalOperators | undefined\r\n}\r\n\r\nexport class LogicalOpNode extends AstNode {\r\n    constructor(public items: LogicalNodeItem[],\r\n        public loc: Uint16Array) {\r\n        super('logicalOp');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class BinOpNode extends AstNode {\r\n    constructor(\r\n        public left: AstNode,\r\n        public op: ExpressionOperators,\r\n        public right: AstNode,\r\n        public loc: Uint16Array) {\r\n        super('binOp');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport interface AstBlock {\r\n    name: string;\r\n    type: 'module' | 'func' | 'if' | 'for' | 'while' | 'trycatch'\r\n    funcs: FunctionDefNode[];\r\n    body: AstNode[];\r\n}\r\n\r\n\r\n","\r\nexport interface BlockContext {\r\n    moduleName: string;\r\n    blockScope: Scope;\r\n    returnCalled?: boolean;\r\n    breakCalled?: boolean;\r\n    continueCalled?: boolean;\r\n    returnObject?: any;\r\n}\r\n\r\nexport function cloneContext(context: BlockContext): BlockContext {\r\n    return {\r\n        moduleName: context.moduleName,\r\n        blockScope: context.blockScope.clone()\r\n    } as BlockContext;\r\n}\r\n\r\nexport class Scope {\r\n    private readonly scope: Record<string, unknown> = {};\r\n\r\n    constructor(initialScope: Record<string, unknown>) {\r\n        this.scope = { ...initialScope };\r\n    }\r\n\r\n    getScope(): Record<string, unknown> {\r\n        return this.scope;\r\n    }\r\n\r\n    clone(): Scope {\r\n        return new Scope(this.scope);\r\n    }\r\n    set(key: string, value: unknown, path: string = '\\\\'): void {\r\n        this.scope[key] = value;\r\n    }\r\n\r\n    get(key: string, path: string = '\\\\'): unknown {\r\n        return this.scope[key];\r\n    }\r\n}\r\n","import {\r\n    ArrowFuncDefNode,\r\n    AssignNode, AstBlock, AstNode, BinOpNode, BracketObjectAccessNode, ConstNode, CreateArrayNode,\r\n    CreateObjectNode, DotObjectAccessNode, ForNode, FuncDefNode, FunctionCallNode, FunctionDefNode, GetSingleVarNode,\r\n    IfNode, IsNullCoelsing, LogicalOpNode, OperationFuncs, Primitive, RaiseNode, ReturnNode, SetSingleVarNode, TryExceptNode, WhileNode\r\n} from '../common';\r\nimport { JspyError, JspyEvalError } from '../common/utils';\r\nimport { BlockContext, cloneContext, Scope } from './scope';\r\n\r\nexport class Evaluator {\r\n\r\n    evalBlock(ast: AstBlock, blockContext: BlockContext): unknown {\r\n        let lastResult = null;\r\n\r\n        for (let node of ast?.funcs || []) {\r\n            const funcDef = node as FunctionDefNode;\r\n\r\n            // a child scope needs to be created here\r\n            const newScope = blockContext.blockScope;\r\n\r\n            newScope.set(funcDef.funcAst.name,\r\n                (...args: unknown[]): unknown => this.jspyFuncInvoker(funcDef, blockContext, ...args)\r\n            );\r\n        }\r\n\r\n        for (const node of ast.body) {\r\n            if (node.type === 'comment') { continue; }\r\n            if (node.type === 'import') {\r\n                // we can't use it here, because loader has to be promise\r\n                throw new Error(`Import is not support with 'eval'. Use method 'evalAsync' instead`);\r\n            }\r\n            try {\r\n                lastResult = this.evalNode(node, blockContext);\r\n\r\n                if (blockContext.returnCalled) {\r\n                    const res = blockContext.returnObject;\r\n\r\n                    // stop processing return\r\n                    if (ast.type == 'func' || ast.type == 'module') {\r\n                        blockContext.returnCalled = false;\r\n                        blockContext.returnObject = null;\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                if (blockContext.continueCalled) {\r\n                    break;\r\n                }\r\n                if (blockContext.breakCalled) {\r\n                    break;\r\n                }\r\n            } catch (err) {\r\n                const loc = node.loc ? node.loc : [0, 0]\r\n                if (err instanceof JspyError) {\r\n                    throw err;\r\n                } else if (err instanceof JspyEvalError) {\r\n                    throw err;\r\n                } else {\r\n                    throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], err.message || err)\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return lastResult;\r\n    }\r\n\r\n    jspyFuncInvoker(funcDef: FuncDefNode, context: BlockContext, ...args: unknown[]): unknown {\r\n        const ast = Object.assign({}, funcDef.funcAst);\r\n        ast.type = 'func';\r\n\r\n        const blockContext = cloneContext(context);\r\n\r\n        // set parameters into new scope, based incomming arguments        \r\n        for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n            const argValue = args?.length > i ? args[i] : null;\r\n            blockContext.blockScope.set(funcDef.params[i], argValue);\r\n        }\r\n\r\n        return this.evalBlock(ast, blockContext);\r\n    }\r\n\r\n    private invokeFunction(func: (...args: unknown[]) => unknown, fps: unknown[],\r\n        loc: { moduleName: string, line: number, column: number }): unknown {\r\n\r\n        if (fps.length === 0) { return func(); }\r\n        if (fps.length === 1) { return func(fps[0]); }\r\n        if (fps.length === 2) { return func(fps[0], fps[1]); }\r\n        if (fps.length === 3) { return func(fps[0], fps[1], fps[2]); }\r\n        if (fps.length === 4) {\r\n            return func(fps[0], fps[1], fps[2], fps[3]);\r\n        }\r\n        if (fps.length === 5) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4]);\r\n        }\r\n\r\n        if (fps.length === 6) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5]);\r\n        }\r\n\r\n        if (fps.length === 7) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6]);\r\n        }\r\n\r\n        if (fps.length === 8) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7]);\r\n        }\r\n\r\n        if (fps.length === 9) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8]);\r\n        }\r\n\r\n        if (fps.length === 10) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9]);\r\n        }\r\n\r\n        if (fps.length === 11) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10]);\r\n        }\r\n\r\n        if (fps.length === 12) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11]);\r\n        }\r\n\r\n        if (fps.length === 13) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12]);\r\n        }\r\n\r\n        if (fps.length === 14) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13]);\r\n        }\r\n\r\n        if (fps.length === 15) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13], fps[14]);\r\n        }\r\n\r\n        throw Error('Function has too many parameters. Current limitation is 15');\r\n\r\n    }\r\n\r\n    private evalNode(node: AstNode, blockContext: BlockContext): unknown {\r\n        if (node.type === 'import') {\r\n            // skip this for now. As modules are implemented externally\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'comment') {\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'if') {\r\n            const ifNode = node as IfNode;\r\n            if (this.evalNode(ifNode.conditionNode, blockContext)) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock, blockContext);\r\n            } else if (ifNode.elseBody) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock, blockContext);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'raise') {\r\n            const raiseNode = node as RaiseNode;\r\n            const err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, raiseNode.errorMessage || \"\");\r\n            throw err;\r\n        }\r\n\r\n        if (node.type === 'tryExcept') {\r\n            const tryNode = node as TryExceptNode;\r\n            try {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock, blockContext);\r\n\r\n                if (tryNode.elseBody?.length || 0 > 0) {\r\n                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n            catch (err) {\r\n                const name = (err instanceof JspyError) ? (err as JspyError).name : typeof (err);\r\n                const message = (err instanceof JspyError) ? (err as JspyError).message : err?.message ?? String(err);\r\n                const moduleName = (err instanceof JspyError) ? (err as JspyError).module : 0;\r\n                const line = (err instanceof JspyError) ? (err as JspyError).line : 0;\r\n                const column = (err instanceof JspyError) ? (err as JspyError).column : 0;\r\n\r\n                const firstExept = tryNode.exepts[0];\r\n                const catchBody = firstExept.body;\r\n                const ctx = blockContext;// cloneContext(blockContext);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", { name, message, line, column, moduleName })\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock, ctx);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", null)\r\n            }\r\n            finally {\r\n                if (tryNode.finallyBody?.length || 0 > 0) {\r\n                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.finallyBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'return') {\r\n            const returnNode = node as ReturnNode;\r\n            blockContext.returnCalled = true;\r\n            blockContext.returnObject = returnNode.returnValue ?\r\n                this.evalNode(returnNode.returnValue, blockContext)\r\n                : null;\r\n\r\n            return blockContext.returnObject;\r\n        }\r\n\r\n        if (node.type === 'continue') {\r\n            blockContext.continueCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'break') {\r\n            blockContext.breakCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'for') {\r\n            const forNode = node as ForNode;\r\n\r\n            const array = this.evalNode(forNode.sourceArray, blockContext) as unknown[] | string;\r\n\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n\r\n                blockContext.blockScope.set(forNode.itemVarName, item);\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock, blockContext);\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'while') {\r\n            const whileNode = node as WhileNode;\r\n\r\n            while (this.evalNode(whileNode.condition, blockContext)) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock, blockContext);\r\n\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === \"const\") {\r\n            return (node as ConstNode).value;\r\n        }\r\n\r\n        if (node.type === \"getSingleVar\") {\r\n            const name = (node as GetSingleVarNode).name;\r\n\r\n            const value = blockContext.blockScope.get((node as GetSingleVarNode).name);\r\n            if (value === undefined) {\r\n                if (name.charAt(name.length - 1) === ';') {\r\n                    throw new Error(`Unexpected ';' in the end.`);\r\n                } else {\r\n                    throw new Error(`Variable '${name}' is not defined.`);\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n\r\n        if (node.type === \"binOp\") {\r\n            const binOpNode = (node as BinOpNode);\r\n            var left = this.evalNode(binOpNode.left, blockContext);\r\n            var right = this.evalNode(binOpNode.right, blockContext);\r\n            return OperationFuncs[binOpNode.op](left as Primitive, right as Primitive);\r\n        }\r\n\r\n        if (node.type === \"logicalOp\") {\r\n            const logicalGroups = (node as LogicalOpNode);\r\n            let ind = 0;\r\n            let gResult: any = true;\r\n\r\n            while (ind < logicalGroups.items.length) {\r\n                const eg = logicalGroups.items[ind++];\r\n\r\n                gResult = this.evalNode(eg.node, blockContext)\r\n\r\n                if (eg.op === 'and' && !gResult) { return false; }\r\n                if (eg.op === 'or' && gResult) { return gResult; }\r\n            }\r\n\r\n            return gResult;\r\n        }\r\n\r\n        if (node.type === \"arrowFuncDef\") {\r\n            const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n            return (...args: unknown[]): unknown => this.jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n        }\r\n\r\n        if (node.type === \"funcCall\") {\r\n            const funcCallNode = node as FunctionCallNode;\r\n            const func = blockContext.blockScope.get(funcCallNode.name) as (...args: unknown[]) => unknown;\r\n            if (typeof func !== 'function') {\r\n                throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n            }\r\n\r\n            const pms = funcCallNode.paramNodes?.map(n => this.evalNode(n, blockContext)) || []\r\n\r\n            return this.invokeFunction(func, pms, {\r\n                moduleName: blockContext.moduleName,\r\n                line: funcCallNode.loc[0],\r\n                column: funcCallNode.loc[1]\r\n            });\r\n        }\r\n\r\n        if (node.type === \"assign\") {\r\n            const assignNode = node as AssignNode;\r\n\r\n            if (assignNode.target.type === 'getSingleVar') {\r\n                const node = assignNode.target as SetSingleVarNode;\r\n                blockContext.blockScope.set(node.name, this.evalNode(assignNode.source, blockContext));\r\n            } else if (assignNode.target.type === 'dotObjectAccess') {\r\n                const targetNode = assignNode.target as DotObjectAccessNode;\r\n\r\n                // create a node for all but last property token\r\n                // potentially it can go to parser\r\n                const targetObjectNode = new DotObjectAccessNode(targetNode.nestedProps.slice(0, targetNode.nestedProps.length - 1), targetNode.loc);\r\n                const targetObject = this.evalNode(targetObjectNode, blockContext) as Record<string, unknown>;\r\n\r\n                // not sure nested properties should be GetSingleVarNode\r\n                // can be factored in the parser\r\n                const lastPropertyName = (targetNode.nestedProps[targetNode.nestedProps.length - 1] as GetSingleVarNode).name\r\n\r\n                targetObject[lastPropertyName] = this.evalNode(assignNode.source, blockContext);\r\n            } else if (assignNode.target.type === 'bracketObjectAccess') {\r\n                const targetNode = assignNode.target as BracketObjectAccessNode;\r\n                const keyValue = this.evalNode(targetNode.bracketBody, blockContext) as string | number;\r\n                const targetObject = blockContext.blockScope.get(targetNode.propertyName as string) as Record<string, unknown>;\r\n\r\n                targetObject[keyValue] = this.evalNode(assignNode.source, blockContext);\r\n            } else {\r\n                throw Error('Not implemented Assign operation');\r\n                // get chaining calls\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'bracketObjectAccess') {\r\n            const sbNode = node as BracketObjectAccessNode;\r\n            const key = this.evalNode(sbNode.bracketBody, blockContext) as string;\r\n            const obj = blockContext.blockScope.get(sbNode.propertyName as string) as Record<string, unknown>;\r\n            return (obj[key] === undefined) ? null : obj[key];\r\n        }\r\n\r\n        if (node.type === \"dotObjectAccess\") {\r\n            const dotObject = node as DotObjectAccessNode;\r\n\r\n            let startObject = this.evalNode(dotObject.nestedProps[0], blockContext) as any;\r\n            for (let i = 1; i < dotObject.nestedProps.length; i++) {\r\n                const nestedProp = dotObject.nestedProps[i];\r\n\r\n                if ((dotObject.nestedProps[i - 1] as any).nullCoelsing && !startObject) {\r\n                    startObject = {};\r\n                }\r\n\r\n                if (nestedProp.type === 'getSingleVar') {\r\n                    startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n                } else if (nestedProp.type === 'bracketObjectAccess') {\r\n                    const node = nestedProp as BracketObjectAccessNode;\r\n                    startObject = startObject[node.propertyName] as unknown;\r\n                    startObject = startObject[this.evalNode(node.bracketBody, blockContext) as string] as unknown;\r\n                } else if (nestedProp.type === 'funcCall') {\r\n                    const funcCallNode = nestedProp as FunctionCallNode;\r\n                    const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n                    if ((func === undefined || func === null)\r\n                        && (dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing) {\r\n                        startObject = null;\r\n                        continue;\r\n                    }\r\n\r\n                    if (typeof func !== 'function') {\r\n                        throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n                    }\r\n                    const pms = funcCallNode.paramNodes?.map(n => this.evalNode(n, blockContext)) || []\r\n                    startObject = this.invokeFunction(func.bind(startObject), pms, {\r\n                        moduleName: blockContext.moduleName,\r\n                        line: funcCallNode.loc[0],\r\n                        column: funcCallNode.loc[1]\r\n                    });\r\n\r\n                } else {\r\n                    throw Error(\"Can't resolve dotObjectAccess node\")\r\n                }\r\n            }\r\n\r\n            // no undefined values, make it rather null\r\n            return (startObject === undefined) ? null : startObject;\r\n        }\r\n\r\n        if (node.type === 'createObject') {\r\n            const createObjectNode = node as CreateObjectNode;\r\n            const obj = {} as Record<string, unknown>;\r\n\r\n            for (const p of createObjectNode.props) {\r\n                obj[this.evalNode(p.name, blockContext) as string] = this.evalNode(p.value, blockContext);\r\n            }\r\n\r\n            return obj;\r\n        }\r\n\r\n        if (node.type === 'createArray') {\r\n            const arrayNode = node as CreateArrayNode;\r\n            const res = [] as unknown[];\r\n\r\n            for (const item of arrayNode.items) {\r\n                res.push(this.evalNode(item, blockContext));\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n    }\r\n}\r\n","import {\r\n    ArrowFuncDefNode,\r\n    AssignNode, AstBlock, AstNode, BinOpNode, BracketObjectAccessNode, ConstNode, CreateArrayNode,\r\n    CreateObjectNode, DotObjectAccessNode, ForNode, FuncDefNode, FunctionCallNode, FunctionDefNode, GetSingleVarNode,\r\n    getStartLine,\r\n    getTokenLoc,\r\n    IfNode, ImportNode, IsNullCoelsing, LogicalOpNode, OperationFuncs, Primitive, RaiseNode, ReturnNode, SetSingleVarNode, TryExceptNode, WhileNode\r\n} from '../common';\r\nimport { JspyEvalError, JspyError, getImportType } from '../common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { BlockContext, cloneContext, Scope } from './scope';\r\n\r\n/**\r\n * This is copy/paste from Evaluator.\r\n * Sadly, we have to copy code around to support both async and non async methods.\r\n * So, any changes to this method, should be replicated in the evaluator.ts\r\n */\r\nexport class EvaluatorAsync {\r\n\r\n    private moduleParser: (modulePath: string) => Promise<AstBlock> = () => Promise.reject('Module parser is not registered!');\r\n    private jsonFileLoader: (jsonFilePath: string) => Promise<string> = () => Promise.reject('{}');\r\n    private blockContextFactory?: (modulePath: string, ast: AstBlock) => BlockContext;\r\n\r\n    registerModuleParser(moduleParser: (modulePath: string) => Promise<AstBlock>): EvaluatorAsync {\r\n        this.moduleParser = moduleParser;\r\n        return this;\r\n    }\r\n\r\n    registerJsonFileLoader(jsonFileLoader: (modulePath: string) => Promise<string>): EvaluatorAsync {\r\n        this.jsonFileLoader = jsonFileLoader;\r\n        return this;\r\n    }\r\n\r\n    registerBlockContextFactory(blockContextFactory: (modulePath: string, ast: AstBlock) => BlockContext): EvaluatorAsync {\r\n        this.blockContextFactory = blockContextFactory;\r\n        return this;\r\n    }\r\n\r\n    async evalBlockAsync(ast: AstBlock, blockContext: BlockContext): Promise<unknown> {\r\n        let lastResult = null;\r\n\r\n        for (let node of ast?.funcs || []) {\r\n            const funcDef = node as FunctionDefNode;\r\n\r\n            // a child scope needs to be created here\r\n            const newScope = blockContext.blockScope;\r\n\r\n            const invoker = (funcDef.isAsync) ?\r\n                async (...args: unknown[]): Promise<unknown> => await this.jspyFuncInvokerAsync(funcDef, blockContext, ...args)\r\n                : (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(funcDef, blockContext, ...args);\r\n\r\n            newScope.set(funcDef.funcAst.name, invoker);\r\n        }\r\n\r\n        for (const node of ast.body) {\r\n            if (node.type === 'comment') { continue; }\r\n            if (node.type === 'import') {\r\n                const importNode = node as ImportNode;\r\n                const iType = getImportType(importNode.module.name);\r\n\r\n                if (iType === 'json') {\r\n                    const jsonValue = JSON.parse(await this.jsonFileLoader(importNode.module.name));\r\n                    blockContext.blockScope\r\n                        .set(importNode.module.alias || this.defaultModuleName(importNode.module.name), jsonValue);\r\n                    continue;\r\n                } else if (iType !== 'jspyModule') {\r\n                    // it is not JSPY import. It is JS and should be handled externally\r\n                    continue;\r\n                }\r\n\r\n                if (typeof this.blockContextFactory !== 'function') {\r\n                    throw new Error('blockContextFactory is not initialized');\r\n                }\r\n\r\n                const moduleAst = await this.moduleParser(importNode.module.name);\r\n                const moduleBlockContext = this.blockContextFactory(importNode.module.name, moduleAst);\r\n                await this.evalBlockAsync(moduleAst, moduleBlockContext);\r\n\r\n                let scope = blockContext.blockScope.getScope();\r\n\r\n                if (!importNode.parts?.length) {\r\n                    // if no parts, then we need to assign to a separate object\r\n                    scope = {};\r\n                    blockContext.blockScope.set(importNode.module.alias || this.defaultModuleName(importNode.module.name), scope);\r\n                }\r\n\r\n                this.assignFunctionsToScope(scope, moduleBlockContext, moduleAst, importNode.parts?.map(p => p.name));\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                lastResult = await this.evalNodeAsync(node, blockContext);\r\n                if (blockContext.returnCalled) {\r\n                    const res = blockContext.returnObject;\r\n                    // stop processing return\r\n                    if (ast.type == 'func' || ast.type == 'module') {\r\n                        blockContext.returnCalled = false;\r\n                        blockContext.returnObject = null;\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                if (blockContext.continueCalled) {\r\n                    break;\r\n                }\r\n                if (blockContext.breakCalled) {\r\n                    break;\r\n                }\r\n            } catch (err) {\r\n                const loc = node.loc ? node.loc : [0, 0]\r\n                if (err instanceof JspyError) {\r\n                    throw err;\r\n                } else if (err instanceof JspyEvalError) {\r\n                    throw err;\r\n                } else {\r\n                    throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], err.message || err)\r\n                }\r\n            }\r\n        }\r\n\r\n        return lastResult;\r\n    }\r\n\r\n    private assignFunctionsToScope(scope: Record<string, unknown>, moduleBlockContext: BlockContext,\r\n        moduleAst: AstBlock, parts?: string[]): void {\r\n\r\n        const funcs = moduleAst.funcs.filter(f => !parts || parts.indexOf(f.funcAst?.name) >= 0);\r\n\r\n        for (let i = 0; i < funcs.length; i++) {\r\n            const funcDef = funcs[i] as FunctionDefNode;\r\n\r\n            const invoker = (funcDef.isAsync) ?\r\n                async (...args: unknown[]): Promise<unknown> => await this.jspyFuncInvokerAsync(funcDef, moduleBlockContext, ...args)\r\n                : (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(funcDef, moduleBlockContext, ...args);\r\n\r\n            scope[funcDef.funcAst.name] = invoker;\r\n        }\r\n    }\r\n\r\n    private defaultModuleName(name: string): string {\r\n        return name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.'))\r\n    }\r\n\r\n    private async jspyFuncInvokerAsync(funcDef: FuncDefNode, context: BlockContext, ...args: unknown[]): Promise<unknown> {\r\n\r\n        const ast = Object.assign({}, funcDef.funcAst);\r\n        ast.type = 'func';\r\n\r\n        const blockContext = cloneContext(context);\r\n\r\n        // set parameters into new scope, based incomming arguments        \r\n        for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n            const argValue = args?.length > i ? args[i] : null;\r\n            blockContext.blockScope.set(funcDef.params[i], argValue);\r\n        }\r\n\r\n        return await this.evalBlockAsync(ast, blockContext);\r\n    }\r\n\r\n    private async invokeFunctionAsync(func: (...args: unknown[]) => unknown, fps: unknown[],\r\n        loc?: { moduleName: string, line: number, column: number }): Promise<unknown> {\r\n\r\n        if (fps.length === 0) { return await func(); }\r\n        if (fps.length === 1) { return await func(fps[0]); }\r\n        if (fps.length === 2) { return await func(fps[0], fps[1]); }\r\n        if (fps.length === 3) { return await func(fps[0], fps[1], fps[2]); }\r\n        if (fps.length === 4) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3]);\r\n        }\r\n        if (fps.length === 5) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4]);\r\n        }\r\n\r\n        if (fps.length === 6) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5]);\r\n        }\r\n\r\n        if (fps.length === 7) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6]);\r\n        }\r\n\r\n        if (fps.length === 8) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7]);\r\n        }\r\n\r\n        if (fps.length === 9) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8]);\r\n        }\r\n\r\n        if (fps.length === 10) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9]);\r\n        }\r\n\r\n        if (fps.length === 11) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10]);\r\n        }\r\n\r\n        if (fps.length === 12) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11]);\r\n        }\r\n\r\n        if (fps.length === 13) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12]);\r\n        }\r\n\r\n        if (fps.length === 14) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13]);\r\n        }\r\n\r\n        if (fps.length === 15) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13], fps[14]);\r\n        }\r\n\r\n        throw Error('Function has too many parameters. Current limitation is 15');\r\n\r\n    }\r\n\r\n    private async evalNodeAsync(node: AstNode, blockContext: BlockContext): Promise<unknown> {\r\n        if (node.type === 'import') {\r\n            throw new Error('Import should be defined at the start');\r\n        }\r\n\r\n        if (node.type === 'comment') {\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'if') {\r\n            const ifNode = node as IfNode;\r\n            if (await this.evalNodeAsync(ifNode.conditionNode, blockContext)) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock, blockContext);\r\n            } else if (ifNode.elseBody) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock, blockContext);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'raise') {\r\n            const raiseNode = node as RaiseNode;\r\n            const err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, raiseNode.errorMessage || \"\");\r\n            throw err;\r\n        }\r\n\r\n        if (node.type === 'tryExcept') {\r\n            const tryNode = node as TryExceptNode;\r\n            try {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock, blockContext);\r\n\r\n                if (tryNode.elseBody?.length || 0 > 0) {\r\n                    await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n            catch (err) {\r\n                // catches here all exceptions. Including JSPY Eval errors\r\n                const name = (err instanceof JspyError) ? (err as JspyError).name : typeof (err);\r\n                const message = (err instanceof JspyError) ? (err as JspyError).message : err?.message ?? String(err);\r\n                const moduleName = (err instanceof JspyError) ? (err as JspyError).module : 0;\r\n                const line = (err instanceof JspyError) ? (err as JspyError).line : 0;\r\n                const column = (err instanceof JspyError) ? (err as JspyError).column : 0;\r\n\r\n                const firstExept = tryNode.exepts[0];\r\n                const catchBody = firstExept.body;\r\n                const ctx = blockContext;\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", { name, message, line, column, moduleName })\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock, ctx);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", null);\r\n            }\r\n            finally {\r\n                if (tryNode.finallyBody?.length || 0 > 0) {\r\n                    await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.finallyBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'return') {\r\n            const returnNode = node as ReturnNode;\r\n            blockContext.returnCalled = true;\r\n            blockContext.returnObject = returnNode.returnValue ?\r\n                await this.evalNodeAsync(returnNode.returnValue, blockContext)\r\n                : null;\r\n\r\n            return blockContext.returnObject;\r\n        }\r\n\r\n        if (node.type === 'continue') {\r\n            blockContext.continueCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'break') {\r\n            blockContext.breakCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'for') {\r\n            const forNode = node as ForNode;\r\n\r\n            const array = await this.evalNodeAsync(forNode.sourceArray, blockContext) as unknown[] | string;\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n                blockContext.blockScope.set(forNode.itemVarName, item);\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock, blockContext);\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'while') {\r\n            const whileNode = node as WhileNode;\r\n\r\n            while (await this.evalNodeAsync(whileNode.condition, blockContext)) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock, blockContext);\r\n\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === \"const\") {\r\n            return (node as ConstNode).value;\r\n        }\r\n\r\n        if (node.type === \"getSingleVar\") {\r\n            const name = (node as GetSingleVarNode).name;\r\n            const value = blockContext.blockScope.get(name);\r\n\r\n            if (value === undefined) {\r\n                if (name.charAt(name.length - 1) === ';') {\r\n                    throw new Error(`Unexpected ';' in the end.`);\r\n                } else {\r\n                    throw new Error(`Variable '${name}' is not defined.`);\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n\r\n        if (node.type === \"binOp\") {\r\n            const binOpNode = (node as BinOpNode);\r\n            var left = await this.evalNodeAsync(binOpNode.left, blockContext);\r\n            var right = await this.evalNodeAsync(binOpNode.right, blockContext);\r\n            return OperationFuncs[binOpNode.op](left as Primitive, right as Primitive);\r\n        }\r\n\r\n        if (node.type === \"logicalOp\") {\r\n            const logicalGroups = (node as LogicalOpNode);\r\n            let ind = 0;\r\n            let gResult: any = true;\r\n\r\n            while (ind < logicalGroups.items.length) {\r\n                const eg = logicalGroups.items[ind++];\r\n\r\n                gResult = await this.evalNodeAsync(eg.node, blockContext)\r\n\r\n                if (eg.op === 'and' && !gResult) { return false; }\r\n                if (eg.op === 'or' && gResult) { return gResult; }\r\n            }\r\n\r\n            return gResult;\r\n        }\r\n\r\n        if (node.type === \"arrowFuncDef\") {\r\n            const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n            return (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n        }\r\n\r\n        if (node.type === \"funcCall\") {\r\n            const funcCallNode = node as FunctionCallNode;\r\n            const func = blockContext.blockScope.get(funcCallNode.name) as (...args: unknown[]) => unknown;\r\n\r\n            if (typeof func !== 'function') {\r\n                throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n            }\r\n\r\n            const pms = [];\r\n            for (let p of funcCallNode.paramNodes || []) {\r\n                pms.push(await this.evalNodeAsync(p, blockContext));\r\n            }\r\n\r\n            return await this.invokeFunctionAsync(func, pms, {\r\n                moduleName: blockContext.moduleName,\r\n                line: funcCallNode.loc[0],\r\n                column: funcCallNode.loc[0]\r\n            });\r\n        }\r\n\r\n        if (node.type === \"assign\") {\r\n            const assignNode = node as AssignNode;\r\n\r\n            if (assignNode.target.type === 'getSingleVar') {\r\n                const node = assignNode.target as SetSingleVarNode;\r\n                blockContext.blockScope.set(node.name, await this.evalNodeAsync(assignNode.source, blockContext));\r\n            } else if (assignNode.target.type === 'dotObjectAccess') {\r\n                const targetNode = assignNode.target as DotObjectAccessNode;\r\n\r\n                // create a node for all but last property token\r\n                // potentially it can go to parser\r\n                const targetObjectNode = new DotObjectAccessNode(targetNode.nestedProps.slice(0, targetNode.nestedProps.length - 1), targetNode.loc);\r\n                const targetObject = await this.evalNodeAsync(targetObjectNode, blockContext) as Record<string, unknown>;\r\n\r\n                // not sure nested properties should be GetSingleVarNode\r\n                // can be factored in the parser\r\n                const lastPropertyName = (targetNode.nestedProps[targetNode.nestedProps.length - 1] as GetSingleVarNode).name\r\n\r\n                targetObject[lastPropertyName] = await this.evalNodeAsync(assignNode.source, blockContext);\r\n            } else if (assignNode.target.type === 'bracketObjectAccess') {\r\n                const targetNode = assignNode.target as BracketObjectAccessNode;\r\n                const keyValue = await this.evalNodeAsync(targetNode.bracketBody, blockContext) as string | number;\r\n                const targetObject = blockContext.blockScope.get(targetNode.propertyName as string) as Record<string, unknown>;\r\n\r\n                targetObject[keyValue] = await this.evalNodeAsync(assignNode.source, blockContext);\r\n            } else {\r\n                throw Error('Not implemented Assign operation');\r\n                // get chaining calls\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'bracketObjectAccess') {\r\n            const sbNode = node as BracketObjectAccessNode;\r\n            const key = await this.evalNodeAsync(sbNode.bracketBody, blockContext) as string;\r\n            const obj = blockContext.blockScope.get(sbNode.propertyName as string) as Record<string, unknown>;\r\n            return (obj[key] === undefined) ? null : obj[key];\r\n        }\r\n\r\n        if (node.type === \"dotObjectAccess\") {\r\n            const dotObject = node as DotObjectAccessNode;\r\n\r\n            let startObject = await this.evalNodeAsync(dotObject.nestedProps[0], blockContext) as any;\r\n            for (let i = 1; i < dotObject.nestedProps.length; i++) {\r\n                const nestedProp = dotObject.nestedProps[i];\r\n\r\n                if ((dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing && !startObject) {\r\n                    startObject = {};\r\n                }\r\n\r\n                if (nestedProp.type === 'getSingleVar') {\r\n                    startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n                } else if (nestedProp.type === 'bracketObjectAccess') {\r\n                    const node = nestedProp as BracketObjectAccessNode;\r\n                    startObject = startObject[node.propertyName] as unknown;\r\n                    startObject = startObject[await this.evalNodeAsync(node.bracketBody, blockContext) as string] as unknown;\r\n                } else if (nestedProp.type === 'funcCall') {\r\n                    const funcCallNode = nestedProp as FunctionCallNode;\r\n                    const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n                    if ((func === undefined || func === null)\r\n                        && (dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing) {\r\n                        startObject = null;\r\n                        continue;\r\n                    }\r\n\r\n                    if (typeof (func) !== 'function') {\r\n                        throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n                    }\r\n                    const pms = []\r\n                    for (let p of funcCallNode.paramNodes || []) {\r\n                        pms.push(await this.evalNodeAsync(p, blockContext));\r\n                    }\r\n\r\n                    startObject = await this.invokeFunctionAsync(func.bind(startObject), pms, {\r\n                        moduleName: blockContext.moduleName,\r\n                        line: funcCallNode.loc[0],\r\n                        column: funcCallNode.loc[0]\r\n                    });\r\n\r\n                } else {\r\n                    throw Error(\"Can't resolve dotObjectAccess node\")\r\n                }\r\n            }\r\n\r\n            // no undefined values, make it rather null\r\n            return (startObject === undefined) ? null : startObject;\r\n        }\r\n\r\n        if (node.type === 'createObject') {\r\n            const createObjectNode = node as CreateObjectNode;\r\n            const obj = {} as Record<string, unknown>;\r\n\r\n            for (const p of createObjectNode.props) {\r\n                obj[await this.evalNodeAsync(p.name, blockContext) as string] = await this.evalNodeAsync(p.value, blockContext);\r\n            }\r\n\r\n            return obj;\r\n        }\r\n\r\n        if (node.type === 'createArray') {\r\n            const arrayNode = node as CreateArrayNode;\r\n            const res = [] as unknown[];\r\n\r\n            for (const item of arrayNode.items) {\r\n                res.push(await this.evalNodeAsync(item, blockContext));\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n    }\r\n}\r\n","import { parseDatetimeOrNull } from \"./common/utils\";\r\n\r\nexport const INITIAL_SCOPE = {\r\n    jsPython(): string {\r\n        return [`JSPython v2.1.7`, \"(c) 2021 FalconSoft Ltd. All rights reserved.\"].join('\\n')\r\n    },\r\n    dateTime: (str: number | string | any = null) => parseDatetimeOrNull(str) || new Date(),\r\n    range: range,\r\n    print: (...args: any[]) => { console.log(...args); return args.length > 0 ? args[0] : null; },\r\n    isNull: (v: any, defValue: any = null): boolean | any => defValue === null ? v === null : v || defValue,\r\n    isDate: (d: any): boolean => d instanceof Date,\r\n    isFunction: (v: any): boolean => typeof v === 'function',\r\n    isString: (v: any): boolean => typeof v === 'string',\r\n    deleteProperty: (obj: any, propName: string): boolean => delete obj[propName],\r\n    Math: Math,\r\n    Object: Object,\r\n    Array: Array,\r\n    JSON: JSON,\r\n    printExecutionContext: () => {}, // will be overriden at runtime\r\n    getExecutionContext: () => {} // will be overriden at runtime\r\n};\r\n\r\n/**\r\n * This interface needs to be replaced\r\n */\r\nexport interface PackageToImport {\r\n    name: string;\r\n    properties?: { name: string, as?: string }[];\r\n    as?: string;\r\n}\r\n\r\nfunction range(start: number, stop: number = NaN, step: number = 1): number[] {\r\n    const arr: number[] = [];\r\n    const isStopNaN = isNaN(stop);\r\n    stop = isStopNaN ? start : stop;\r\n    start = isStopNaN ? 0 : start;\r\n    let i = start;\r\n    while (i < stop) {\r\n        arr.push(i);\r\n        i += step;\r\n    }\r\n    return arr;\r\n}\r\n","import {\r\n    BinOpNode, ConstNode, AstBlock, Token, ParserOptions, AstNode, Operators, AssignNode, TokenTypes,\r\n    GetSingleVarNode, FunctionCallNode, getTokenType, getTokenValue, isTokenTypeLiteral, getStartLine,\r\n    getStartColumn, getEndColumn, getEndLine, findOperators, splitTokens, DotObjectAccessNode, BracketObjectAccessNode,\r\n    findTokenValueIndex, FunctionDefNode, CreateObjectNode, ObjectPropertyInfo, CreateArrayNode, ArrowFuncDefNode,\r\n    ExpressionOperators, IfNode, ForNode, WhileNode, ImportNode, NameAlias, ContinueNode, BreakNode, ReturnNode, CommentNode,\r\n    getTokenLoc, OperationTypes, LogicalNodeItem, LogicalOperators, LogicalOpNode, ComparisonOperators, TryExceptNode, ExceptBody, RaiseNode\r\n} from '../common';\r\nimport { JspyParserError } from '../common/utils';\r\n\r\nclass InstructionLine {\r\n    readonly tokens: Token[] = [];\r\n\r\n    startLine(): number {\r\n        return getStartLine(this.tokens[0]);\r\n    }\r\n\r\n    startColumn(): number {\r\n        return getStartColumn(this.tokens[0]);\r\n    }\r\n\r\n    endLine(): number {\r\n        return getEndLine(this.tokens[this.tokens.length - 1]);\r\n    }\r\n\r\n    endColumn(): number {\r\n        return getEndColumn(this.tokens[this.tokens.length - 1]);\r\n    }\r\n}\r\n\r\nexport class Parser {\r\n    private _currentToken: Token | null = null;\r\n    private _moduleName = '';\r\n\r\n    /**\r\n     * Parses tokens and return Ast - Abstract Syntax Tree for jsPython code\r\n     * @param tokens tokens\r\n     * @param options parsing options. By default it will exclude comments and include LOC (Line of code)\r\n     */\r\n    parse(tokens: Token[], name = 'main.jspy', type = 'module'): AstBlock {\r\n        this._moduleName = name;\r\n        const ast = { name, type, funcs: [], body: [] } as AstBlock;\r\n\r\n        if (!tokens || !tokens.length) { return ast; }\r\n\r\n        try {\r\n\r\n            // group all tokens into an Instruction lines.\r\n            const instructions = this.tokensToInstructionLines(tokens, 1);\r\n\r\n            // process all instructions\r\n            this.instructionsToNodes(instructions, ast);\r\n\r\n        } catch (err) {\r\n            const token = this._currentToken ?? {} as Token\r\n            throw new JspyParserError(ast.name, getStartLine(token), getStartColumn(token), err.message || err)\r\n        }\r\n        return ast;\r\n    }\r\n\r\n    private instructionsToNodes(instructions: InstructionLine[], ast: AstBlock): void {\r\n\r\n        const getBody = (tokens: Token[], startTokenIndex: number): AstNode[] => {\r\n            const instructionLines = this.tokensToInstructionLines(tokens, getStartLine(tokens[startTokenIndex]));\r\n            const bodyAst = { name: ast.name, body: [] as AstNode[], funcs: [] as AstNode[] } as AstBlock;\r\n            this.instructionsToNodes(instructionLines, bodyAst);\r\n            return bodyAst.body;\r\n        }\r\n\r\n        const findIndexes = (tkns: Token[], operation: OperationTypes, result: number[]): boolean => {\r\n            result.splice(0, result.length);\r\n            findOperators(tkns, operation).forEach(r => result.push(r));\r\n            return !!result.length;\r\n        }\r\n\r\n        for (let i = 0; i < instructions.length; i++) {\r\n            const instruction = instructions[i];\r\n\r\n            // remove comments\r\n            let tt = 0;\r\n            while (tt < instruction.tokens.length) {\r\n                if (getTokenType(instruction.tokens[tt]) === TokenTypes.Comment) {\r\n                    instruction.tokens.splice(tt, 1);\r\n                } else {\r\n                    tt++;\r\n                }\r\n            }\r\n            if (!instruction.tokens.length) {\r\n                continue;\r\n            }\r\n\r\n            const firstToken = instruction.tokens[0];\r\n            const secondToken = instruction.tokens.length > 1 ? instruction.tokens[1] : null;\r\n            this._currentToken = firstToken;\r\n\r\n            const logicOpIndexes: number[] = [];\r\n            const comparisonOpIndexs: number[] = [];\r\n            const assignTokenIndexes: number[] = [];\r\n\r\n            if (getTokenType(firstToken) === TokenTypes.Comment) {\r\n                ast.body.push(new CommentNode(getTokenValue(firstToken) as string, getTokenLoc(firstToken)));\r\n            } else if (getTokenValue(firstToken) === 'def'\r\n                || (getTokenValue(firstToken) === \"async\" && getTokenValue(secondToken) === \"def\")) {\r\n\r\n                const isAsync = getTokenValue(firstToken) === \"async\";\r\n                const funcName = getTokenValue(instruction.tokens[isAsync ? 2 : 1]) as string;\r\n                const paramsTokens = instruction.tokens.slice(\r\n                    instruction.tokens.findIndex(tkns => getTokenValue(tkns) === '(') + 1,\r\n                    instruction.tokens.findIndex(tkns => getTokenValue(tkns) === ')')\r\n                );\r\n\r\n                const params = splitTokens(paramsTokens, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for def`)\r\n                }\r\n\r\n                const instructionLines = this.tokensToInstructionLines(instruction.tokens, getStartLine(instruction.tokens[endDefOfDef + 1]));\r\n                const funcAst = {\r\n                    name: funcName,\r\n                    body: [] as AstNode[],\r\n                    funcs: [] as AstNode[]\r\n                } as AstBlock;\r\n                this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n                ast.funcs.push(new FunctionDefNode(funcAst, params, isAsync, getTokenLoc(instruction.tokens[0])))\r\n\r\n            } else if (getTokenValue(firstToken) === 'if') {\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for if`)\r\n                }\r\n\r\n                const ifBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n                const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n\r\n                const conditionNode = (findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)) ?\r\n                    this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n                    :\r\n                    this.createExpressionNode(conditionTokens);\r\n\r\n                let elseBody: AstNode[] | undefined = undefined;\r\n                if (instructions.length > i + 1\r\n                    && getTokenValue(instructions[i + 1].tokens[0]) === 'else'\r\n                    && getTokenValue(instructions[i + 1].tokens[1]) === ':') {\r\n                    elseBody = getBody(instructions[i + 1].tokens, 2);\r\n                    i++;\r\n                }\r\n\r\n                ast.body.push(new IfNode(conditionNode, ifBody, elseBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'try') {\r\n\r\n                if (getTokenValue(instruction.tokens[1]) !== ':') {\r\n                    throw (`'try' statement should be followed by ':'`)\r\n                }\r\n\r\n                const tryBody = getBody(instruction.tokens, 2);\r\n                const excepts: ExceptBody[] = [];\r\n\r\n                let elseBody: AstNode[] | undefined = undefined;\r\n                let finallyBody: AstNode[] | undefined = undefined;\r\n\r\n                while (instructions.length > i + 1\r\n                    && (\r\n                        getTokenValue(instructions[i + 1].tokens[0]) === 'else'\r\n                        || getTokenValue(instructions[i + 1].tokens[0]) === 'except'\r\n                        || getTokenValue(instructions[i + 1].tokens[0]) === 'finally'\r\n                    )\r\n                ) {\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'else') {\r\n                        if (elseBody) {\r\n                            throw new Error(`Only one 'else' is allowed in a 'try'`)\r\n                        }\r\n\r\n                        elseBody = getBody(instructions[i + 1].tokens, 2);\r\n                    }\r\n\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'finally') {\r\n                        if (finallyBody) {\r\n                            throw new Error(`Only one 'else' is allowed in a 'try'`)\r\n                        }\r\n\r\n                        finallyBody = getBody(instructions[i + 1].tokens, 2);\r\n                    }\r\n\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'except') {\r\n\r\n                        const endIndex = findTokenValueIndex(instructions[i + 1].tokens, v => v === ':');\r\n                        const except = {} as ExceptBody;\r\n\r\n                        if (endIndex === 2) {\r\n                            except.error = { name: getTokenValue(instructions[i + 1].tokens[1]) } as NameAlias;\r\n                        } else if (endIndex === 3) {\r\n                            except.error = {\r\n                                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                                alias: getTokenValue(instructions[i + 1].tokens[2]),\r\n                            } as NameAlias;\r\n                        } else if (endIndex === 4) {\r\n                            except.error = {\r\n                                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                                alias: getTokenValue(instructions[i + 1].tokens[3]),\r\n                            } as NameAlias;\r\n                        } else if (endIndex !== 1) {\r\n                            throw new Error(`Incorrect 'except:' statement. Valid stats: (except: or except Error: or except Error as e:)`)\r\n                        }\r\n\r\n                        except.body = getBody(instructions[i + 1].tokens, endIndex + 1);\r\n\r\n                        excepts.push(except);\r\n                    }\r\n\r\n                    i++;\r\n                }\r\n\r\n                if (!excepts.length) {\r\n                    throw new Error('Except: is missing');\r\n                }\r\n\r\n                ast.body.push(new TryExceptNode(tryBody, excepts, elseBody, finallyBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'continue') {\r\n                ast.body.push(new ContinueNode());\r\n            } else if (getTokenValue(firstToken) === 'break') {\r\n                ast.body.push(new BreakNode());\r\n            } else if (getTokenValue(firstToken) === 'return') {\r\n                ast.body.push(new ReturnNode(\r\n                    instruction.tokens.length > 1 ? this.createExpressionNode(instruction.tokens.slice(1)) : undefined,\r\n                    getTokenLoc(firstToken))\r\n                );\r\n            } else if (getTokenValue(firstToken) === 'raise') {\r\n\r\n                if (instruction.tokens.length === 1) {\r\n                    throw new Error(`Incorrect 'raise' usage. Please specify error name and message `);\r\n                }\r\n                const errorName = getTokenValue(instruction.tokens[1]) as string;\r\n\r\n                const errorMessage = (\r\n                    instruction.tokens.length == 5\r\n                    && getTokenValue(instruction.tokens[2]) === \"(\"\r\n                    && getTokenValue(instruction.tokens[4]) === \")\"\r\n                ) ? getTokenValue(instruction.tokens[3]) as string\r\n                    : undefined;\r\n\r\n                ast.body.push(new RaiseNode(errorName, errorMessage, getTokenLoc(firstToken)));\r\n            } else if (getTokenValue(firstToken) === 'for') {\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for if`)\r\n                }\r\n\r\n                const itemVarName = getTokenValue(instruction.tokens[1]) as string;\r\n                const sourceArray = this.createExpressionNode(instruction.tokens.slice(3, endDefOfDef))\r\n                const forBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n                ast.body.push(new ForNode(sourceArray, itemVarName, forBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'while') {\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for [while]`)\r\n                }\r\n\r\n\r\n                const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n                const conditionNode = (findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)) ?\r\n                    this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n                    :\r\n                    this.createExpressionNode(conditionTokens);\r\n\r\n                const body = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n                ast.body.push(new WhileNode(conditionNode, body, getTokenLoc(firstToken)));\r\n\r\n            } else if (getTokenValue(firstToken) === 'import') {\r\n                let asIndex = findTokenValueIndex(instruction.tokens, v => v === 'as');\r\n                if (asIndex < 0) {\r\n                    asIndex = instruction.tokens.length;\r\n                }\r\n\r\n                const module = {\r\n                    name: instruction.tokens.slice(1, asIndex).map(t => getTokenValue(t)).join(''),\r\n                    alias: instruction.tokens.slice(asIndex + 1).map(t => getTokenValue(t)).join('') || undefined\r\n                } as NameAlias;\r\n\r\n                const body = {} as AstBlock; // empty for now\r\n                ast.body.push(new ImportNode(module, body, undefined, getTokenLoc(firstToken)))\r\n            } else if (getTokenValue(firstToken) === 'from') {\r\n                const importIndex = findTokenValueIndex(instruction.tokens, v => v === 'import');\r\n                if (importIndex < 0) {\r\n                    throw Error(`'import' must follow 'from'`);\r\n                }\r\n\r\n                const module = {\r\n                    name: instruction.tokens.slice(1, importIndex).map(t => getTokenValue(t)).join('')\r\n                } as NameAlias;\r\n\r\n                const parts = splitTokens(instruction.tokens.slice(importIndex + 1), ',')\r\n                    .map(t => {\r\n                        return {\r\n                            name: getTokenValue(t[0]),\r\n                            alias: (t.length === 3) ? getTokenValue(t[2]) : undefined\r\n                        } as NameAlias\r\n                    });\r\n\r\n                const body = {} as AstBlock; // empty for now\r\n\r\n                ast.body.push(new ImportNode(module, body, parts, getTokenLoc(firstToken)))\r\n            } else if (findIndexes(instruction.tokens, OperationTypes.Assignment, assignTokenIndexes)) {\r\n                const assignTokens = splitTokens(instruction.tokens, '=');\r\n                const target = this.createExpressionNode(assignTokens[0]);\r\n                const source = this.createExpressionNode(assignTokens[1]);\r\n                ast.body.push(new AssignNode(target, source, getTokenLoc(assignTokens[0][0])));\r\n            } else if (findIndexes(instruction.tokens, OperationTypes.Logical, logicOpIndexes)) {\r\n                ast.body.push(this.groupLogicalOperations(logicOpIndexes, instruction.tokens));\r\n            } else {\r\n                ast.body.push(this.createExpressionNode(instruction.tokens))\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    private sliceWithBrackets(a: Token[], begin: number, end: number): Token[] {\r\n        // if expression is in brackets, then we need clean brackets\r\n        if (getTokenValue(a[begin]) === '(' && getTokenType(a[begin]) !== TokenTypes.LiteralString) {\r\n            begin++;\r\n            end--;\r\n        }\r\n\r\n        return a.slice(begin, end);\r\n    }\r\n\r\n    private groupComparisonOperations(indexes: number[], tokens: Token[]): AstNode {\r\n        const start = 0;\r\n\r\n        let leftNode: AstNode | null = null;\r\n        for (let i = 0; i < indexes.length; i++) {\r\n            const opToken = getTokenValue(tokens[indexes[i]]) as ComparisonOperators;\r\n            leftNode = (leftNode) ? leftNode : this.createExpressionNode(this.sliceWithBrackets(tokens, start, indexes[i]))\r\n\r\n            const endInd = (i + 1 < indexes.length) ? indexes[i + 1] : tokens.length;\r\n            const rightNode = this.createExpressionNode(this.sliceWithBrackets(tokens, indexes[i] + 1, endInd))\r\n\r\n            leftNode = new BinOpNode(leftNode, opToken, rightNode, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        return leftNode as AstNode;\r\n    }\r\n\r\n    private groupLogicalOperations(logicOp: number[], tokens: Token[]): LogicalOpNode {\r\n        let start = 0;\r\n        const logicItems: LogicalNodeItem[] = [];\r\n        for (let i = 0; i < logicOp.length; i++) {\r\n            const opToken = tokens[logicOp[i]];\r\n            const logicalSlice = this.sliceWithBrackets(tokens, start, logicOp[i]);\r\n            logicItems.push({\r\n                node: this.createExpressionNode(logicalSlice),\r\n                op: getTokenValue(opToken) as LogicalOperators\r\n            });\r\n\r\n            start = logicOp[i] + 1;\r\n        }\r\n\r\n        logicItems.push({\r\n            node: this.createExpressionNode(this.sliceWithBrackets(tokens, start, tokens.length))\r\n        } as LogicalNodeItem);\r\n\r\n        const lop = new LogicalOpNode(logicItems, getTokenLoc(tokens[0]));\r\n        return lop;\r\n    }\r\n\r\n    private tokensToInstructionLines(tokens: Token[], startLine: number): InstructionLine[] {\r\n        const lines: InstructionLine[] = [];\r\n\r\n        let column = 0;\r\n        let currentLine = startLine;\r\n        let line = new InstructionLine();\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            const token = tokens[i];\r\n            const sLine = getStartLine(token);\r\n            const sColumn = getStartColumn(token);\r\n            const value = getTokenValue(token);\r\n            this._currentToken = token;\r\n\r\n            if (sLine >= startLine) {\r\n\r\n                if (currentLine !== sLine) {\r\n                    currentLine = sLine;\r\n                }\r\n\r\n                if (column === sColumn && !\")}]\".includes(value as string)) {\r\n                    currentLine = sLine;\r\n                    lines.push(line);\r\n                    line = new InstructionLine();\r\n                }\r\n\r\n                line.tokens.push(token);\r\n\r\n                // first line defines a minimum indent\r\n                if (column === 0) {\r\n                    column = sColumn;\r\n                }\r\n\r\n                // stop looping through if line has less indent\r\n                // it means the corrent block finished\r\n                if (sColumn < column) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (line.tokens.length) {\r\n            lines.push(line)\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    private createExpressionNode(tokens: Token[], prevNode: AstNode | null = null): AstNode {\r\n        if (tokens.length === 0) {\r\n            throw new Error(`Tokens length can't empty.`)\r\n        }\r\n        const lastToken = tokens[tokens.length - 1];\r\n        if (getTokenValue(lastToken) === ';' && getTokenType(lastToken) !== TokenTypes.LiteralString) {\r\n            throw new Error(`Unexpected symbol ';' in the end`)\r\n        }\r\n\r\n        this._currentToken = tokens[0];\r\n\r\n        // const or variable\r\n        if (tokens.length === 1\r\n            || (tokens.length === 2 && getTokenValue(tokens[1]) === '?')\r\n        ) {\r\n            const firstToken = tokens[0];\r\n            const tokenType = getTokenType(firstToken);\r\n\r\n            if (isTokenTypeLiteral(tokenType)) {\r\n                return new ConstNode(firstToken);\r\n            } else if (tokenType === TokenTypes.Identifier) {\r\n                return new GetSingleVarNode(firstToken, tokens.length === 2 && getTokenValue(tokens[1]) === '?' || undefined);\r\n            }\r\n\r\n            throw Error(`Unhandled single token: '${JSON.stringify(firstToken)}'`);\r\n        }\r\n\r\n        // arrow function\r\n        const arrowFuncParts = splitTokens(tokens, '=>');\r\n        if (arrowFuncParts.length > 1) {\r\n            const pArray = getTokenValue(arrowFuncParts[0][0]) === '(' ?\r\n                arrowFuncParts[0].splice(1, arrowFuncParts[0].length - 2)\r\n                : arrowFuncParts[0];\r\n            const params = splitTokens(pArray, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n            const instructionLines = this.tokensToInstructionLines(arrowFuncParts[1], 0);\r\n            const funcAst = {\r\n                name: this._moduleName,\r\n                body: [] as AstNode[],\r\n                funcs: [] as AstNode[]\r\n            } as AstBlock;\r\n            this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n            return new ArrowFuncDefNode(funcAst, params, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // comparison operations\r\n        const comparissonIndexes = findOperators(tokens, OperationTypes.Comparison);\r\n        if (comparissonIndexes.length) {\r\n            return this.groupComparisonOperations(comparissonIndexes, tokens);\r\n        }\r\n\r\n        // create arithmetic expression\r\n        const ops = findOperators(tokens);\r\n        if (ops.length) {\r\n\r\n            let prevNode: AstNode | null = null;\r\n            for (let i = 0; i < ops.length; i++) {\r\n                const opIndex = ops[i];\r\n                const op = getTokenValue(tokens[opIndex]) as Operators;\r\n\r\n                let nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n                let nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n                if (nextOpIndex !== null && (nextOp === '*' || nextOp === '/')) {\r\n                    let rightNode: AstNode | null = null;\r\n                    // iterate through all continuous '*', '/' operations\r\n                    do {\r\n                        const nextOpIndex2 = i + 2 < ops.length ? ops[i + 2] : null;\r\n\r\n                        const leftSlice2 = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex);\r\n                        const rightSlice2 = this.sliceWithBrackets(tokens, nextOpIndex + 1, nextOpIndex2 || tokens.length);\r\n\r\n                        const left2 = this.createExpressionNode(leftSlice2);\r\n                        const right2 = this.createExpressionNode(rightSlice2);\r\n                        rightNode = new BinOpNode(left2, nextOp, right2, getTokenLoc(tokens[opIndex + 1]));\r\n\r\n                        i++;\r\n                        nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n                        nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n                    }\r\n                    while (nextOpIndex !== null && (nextOp === '*' || nextOp === '/'))\r\n\r\n                    // add up result\r\n                    if (prevNode === null) {\r\n                        const leftSlice = this.sliceWithBrackets(tokens, 0, opIndex);\r\n                        prevNode = this.createExpressionNode(leftSlice);\r\n                    }\r\n                    prevNode = new BinOpNode(prevNode, op as ExpressionOperators, rightNode, getTokenLoc(tokens[0]))\r\n\r\n                } else {\r\n                    const leftSlice = prevNode ? [] : this.sliceWithBrackets(tokens, 0, opIndex);\r\n                    const rightSlice = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex || tokens.length);\r\n                    const left: AstNode = prevNode || this.createExpressionNode(leftSlice, prevNode);\r\n                    const right = this.createExpressionNode(rightSlice);\r\n                    prevNode = new BinOpNode(left, op as ExpressionOperators, right, getTokenLoc(tokens[0]));\r\n                }\r\n            }\r\n\r\n            if (prevNode === null) {\r\n                throw Error(`Can't create node ...`)\r\n            }\r\n\r\n            return prevNode;\r\n        }\r\n\r\n        // create DotObjectAccessNode\r\n        const subObjects = splitTokens(tokens, '.');\r\n        if (subObjects.length > 1) {\r\n            return new DotObjectAccessNode(subObjects.map(tkns => this.createExpressionNode(tkns)), getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // create function call node\r\n        if (tokens.length > 2 && getTokenValue(tokens[1]) === '(') {\r\n\r\n            const isNullCoelsing = getTokenValue(tokens[tokens.length - 1]) === '?';\r\n            if (isNullCoelsing) {\r\n                // remove '?'\r\n                tokens.pop();\r\n            }\r\n            const name = getTokenValue(tokens[0]) as string;\r\n            const paramsTokensSlice = tokens.slice(2, tokens.length - 1);\r\n            const paramsTokens = splitTokens(paramsTokensSlice, ',')\r\n            const paramsNodes = paramsTokens.map(tkns => this.createExpressionNode(tkns));\r\n            const node = new FunctionCallNode(name, paramsNodes, getTokenLoc(tokens[0]));\r\n            node.nullCoelsing = isNullCoelsing || undefined;\r\n            return node;\r\n        }\r\n\r\n        // create Object Node\r\n        if (getTokenValue(tokens[0]) === '{' && getTokenValue(tokens[tokens.length - 1]) === '}') {\r\n            const keyValueTokens = splitTokens(tokens.splice(1, tokens.length - 2), ',');\r\n            const props = [] as ObjectPropertyInfo[];\r\n            for (let i = 0; i < keyValueTokens.length; i++) {\r\n                const keyValue = splitTokens(keyValueTokens[i], ':');\r\n                if (keyValue.length === 1) {\r\n                    const pInfo = {\r\n                        name: new ConstNode(keyValue[0][0]),\r\n                        value: this.createExpressionNode(keyValue[0])\r\n                    } as ObjectPropertyInfo;\r\n\r\n                    props.push(pInfo);\r\n                } else if (keyValue.length === 2) {\r\n\r\n                    let name: AstNode | null = null;\r\n                    const namePart = keyValue[0];\r\n\r\n                    if (namePart.length === 1) {\r\n                        name = new ConstNode(namePart[0]);\r\n                    } else if (getTokenValue(namePart[0]) === '['\r\n                        && getTokenValue(namePart[namePart.length - 1]) === ']') {\r\n                        name = this.createExpressionNode(namePart.slice(1, namePart.length - 1))\r\n                    } else {\r\n                        throw new Error(`Incorrect JSON. Can't resolve Key field. That should either constant or expression in []`)\r\n                    }\r\n\r\n                    const pInfo = {\r\n                        name,\r\n                        value: this.createExpressionNode(keyValue[1])\r\n                    } as ObjectPropertyInfo;\r\n\r\n                    props.push(pInfo);\r\n                } else {\r\n                    throw Error('Incorrect JSON')\r\n                }\r\n            }\r\n\r\n            return new CreateObjectNode(props, getTokenLoc(tokens[0]))\r\n        }\r\n\r\n        // create Array Node\r\n        if (getTokenValue(tokens[0]) === '[' && getTokenValue(tokens[tokens.length - 1]) === ']') {\r\n            const items = splitTokens(tokens.splice(1, tokens.length - 2), ',')\r\n                .map(tkns => this.createExpressionNode(tkns));\r\n\r\n            return new CreateArrayNode(items, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // bracket access object node\r\n        if (tokens.length > 2 && getTokenValue(tokens[1]) === '[') {\r\n            const name = getTokenValue(tokens[0]) as string;\r\n            const paramsTokensSlice = tokens.slice(2, tokens.length - 1);\r\n            const paramsNodes = this.createExpressionNode(paramsTokensSlice);\r\n            return new BracketObjectAccessNode(name, paramsNodes, false, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        throw Error(`Undefined node '${getTokenValue(tokens[0])}'.`);\r\n    }\r\n}\r\n","import { getTokenType, getTokenValue, Token, TokenTypes } from '../common';\r\n\r\nconst SeparatorsMap: Record<string, string[]> = {\r\n    '\\n': ['\\n'],\r\n    '=': ['=', '==', '=>'],\r\n\r\n    '+': ['+', '++', '+='],\r\n    '-': ['-', '--', '-='],\r\n    '*': ['*', '**', '*='],\r\n    '/': ['/', '//', '/='],\r\n\r\n    '.': ['.'],\r\n    '?': ['?'],\r\n    '!': ['!='],\r\n    ':': [':'],\r\n    ',': [','],\r\n\r\n    '>': ['>', '>='],\r\n    '<': ['<', '<=', '<>'],\r\n\r\n    '(': ['('],\r\n    ')': [')'],\r\n    '{': ['{'],\r\n    '}': ['}'],\r\n    '[': ['['],\r\n    ']': [']'],\r\n};\r\n\r\nconst Keywords: string[] = [\"async\", \"def\", \"for\", \"while\", \"if\", \"return\", \"in\"];\r\n\r\nexport class Tokenizer {\r\n    private _startLine = 1;\r\n    private _startColumn = 1;\r\n    private _currentLine = 1;\r\n    private _currentColumn = 1;\r\n    private _tokenText = '';\r\n    private _cursor = 0;\r\n    private _script = \"\";\r\n\r\n    private get tokenText(): string {\r\n        return this._tokenText;\r\n    }\r\n    private set tokenText(value: string) {\r\n        if (!this._tokenText && value) {\r\n            this._startLine = this._currentLine;\r\n            this._startColumn = this._currentColumn;\r\n        }\r\n        this._tokenText = value;\r\n    }\r\n\r\n    /**\r\n     * Splits script code into a tokens\r\n     * @param script A jsPython text\r\n     */\r\n    tokenize(script: string): Token[] {\r\n        if (!script || !script.length) { return []; }\r\n\r\n        script = script\r\n            .replace(new RegExp('\\t', 'g'), '  ') // replace all tabs with 2 spaces\r\n            .replace(new RegExp('\\r', 'g'), ''); // remove all \\r symbols\r\n        this._script = script;\r\n\r\n        this._cursor = 0;\r\n        this._startLine = 1;\r\n        this._startColumn = 1;\r\n        this._currentLine = 1;\r\n        this._currentColumn = 1;\r\n\r\n        const tokens: Token[] = [];\r\n\r\n        let first = true;\r\n        // handle initial spaces\r\n        while (script[this._cursor] === '\\n') {\r\n            this.incrementCursor();\r\n            if (first) {\r\n                this._currentLine++;\r\n                first = false;\r\n            }\r\n            this._currentColumn = 1;\r\n        }\r\n\r\n        do {\r\n            const symbol = script[this._cursor];\r\n\r\n            if (symbol == ' ' && this.tokenText.length !== 0) {\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n                continue;\r\n            } else if ((SeparatorsMap[symbol] !== undefined) && !this.isPartOfNumber(symbol, tokens)) {\r\n                // handle numbers with floating point e.g. 3.14\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n                this.tokenText = symbol;\r\n\r\n                const sepsMap = SeparatorsMap[symbol];\r\n\r\n                if (sepsMap.length >= 1) {\r\n                    // process longer operators\r\n                    while (sepsMap.includes(this.tokenText + script[this._cursor + 1])) {\r\n                        this.tokenText += script[this.incrementCursor()];\r\n                    }\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, false, TokenTypes.Operator);\r\n\r\n            } else if (symbol === '#') {\r\n\r\n                let first = true;\r\n                while (script[this.incrementCursor()] !== '\\n') {\r\n                    this.tokenText += script[this._cursor];\r\n\r\n                    // correct start column\r\n                    if (first) {\r\n                        first = false;\r\n                        this._startColumn = this._startColumn - 1\r\n                    }\r\n\r\n                    if (this._cursor + 1 >= script.length) break;\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.Comment);\r\n\r\n            } else if (symbol === '\"' || symbol === \"'\") {\r\n                // remember either it is single or double quote\r\n                const q = symbol;\r\n                // we are not expecting token to be added here.\r\n                // it should pass a failt to parser\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n\r\n                // handle \"\"\" comment \"\"\"\"\r\n                if (script[this._cursor + 1] === q && script[this._cursor + 2] === q) {\r\n                    const cLine = this._currentLine;\r\n                    const cColumn = this._currentColumn;\r\n                    this.incrementCursor(2);\r\n                    const passCond = true;\r\n                    while (passCond) {\r\n                        this.tokenText += script[this.incrementCursor()];\r\n                        if (this._cursor + 3 >= script.length\r\n                            || (script[this._cursor + 1] === q && script[this._cursor + 2] === q && script[this._cursor + 3] === q)) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    // a special case when multiline string\r\n                    this._startLine = cLine;\r\n                    this._startColumn = cColumn;\r\n\r\n                    this.incrementCursor(3);\r\n                } else {\r\n                    while (script[this.incrementCursor()] !== q) {\r\n                        this.tokenText += script[this._cursor];\r\n                        if (this._cursor + 1 >= script.length) break;\r\n                    }\r\n\r\n                    //start column needs to take into account a begining quote, not just a string\r\n                    this._startColumn--;\r\n                }\r\n\r\n                // a special case when empty string\r\n                if (this.tokenText.length === 0) {\r\n                    this._startLine = this._currentLine;\r\n                    this._startColumn = this._currentColumn;\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.LiteralString);\r\n            } else if (symbol != ' ') {\r\n                this.tokenText += symbol;\r\n            }\r\n        }\r\n        while (this.incrementCursor() < script.length)\r\n\r\n        this.processToken(this.tokenText, tokens);\r\n\r\n        return tokens;\r\n    }\r\n\r\n    private incrementCursor(count = 1): number {\r\n        for (let i = 0; i < count; i++) {\r\n            this._cursor = this._cursor + 1;\r\n            if (this._script[this._cursor] === '\\n') {\r\n                this._currentLine++;\r\n                this._currentColumn = 0;\r\n            } else {\r\n                this._currentColumn++;\r\n            }\r\n        }\r\n\r\n        return this._cursor;\r\n    }\r\n\r\n    private recognizeToken(tokenText: string, type: TokenTypes | null = null): { value: string | number | boolean | null, type: TokenTypes } {\r\n\r\n        let value: string | number | boolean | null = tokenText;\r\n\r\n        if (type === null) {\r\n            if (tokenText === 'null') {\r\n                type = TokenTypes.LiteralNull;\r\n                value = null;\r\n            } else if (tokenText === 'true' || tokenText === 'false') {\r\n                type = TokenTypes.LiteralBool;\r\n                value = tokenText === 'true';\r\n            } else if (this.parseNumberOrNull(tokenText) !== null) {\r\n                type = TokenTypes.LiteralNumber;\r\n                value = this.parseNumberOrNull(tokenText);\r\n            } else if (Keywords.indexOf(tokenText) >= 0) {\r\n                type = TokenTypes.Keyword;\r\n            } else {\r\n                type = TokenTypes.Identifier\r\n            }\r\n        }\r\n\r\n        return {\r\n            value: value,\r\n            type: type\r\n        }\r\n\r\n    }\r\n\r\n    private processToken(strToken: string, tokens: Token[], allowEmptyString = false, type: TokenTypes | null = null): string {\r\n        // ignore empty tokens\r\n        if (!strToken.length && !allowEmptyString || strToken === '\\n') return \"\";\r\n\r\n        const token = this.recognizeToken(strToken, type);\r\n        tokens.push([token.value, Uint16Array.of(token.type as number,\r\n            this._startLine, this._startColumn,\r\n            this._currentLine, this._currentColumn)] as Token)\r\n        return \"\";\r\n    }\r\n\r\n    private parseNumberOrNull(value: string | number): number | null {\r\n        if (typeof value === 'number') {\r\n            return value;\r\n        }\r\n\r\n        if (!value || typeof value !== 'string') {\r\n            return null;\r\n        }\r\n\r\n        value = value.trim();\r\n\r\n        // Just to make sure string contains digits only and '.', ','. Otherwise, parseFloat can incorrectly parse into number\r\n        for (let i = value.length - 1; i >= 0; i--) {\r\n            const d = value.charCodeAt(i);\r\n            if (d < 48 || d > 57) {\r\n                // '.' - 46 ',' - 44 '-' - 45(but only first char)\r\n                if (d !== 46 && d !== 44 && (d !== 45 || i !== 0))\r\n                    return null;\r\n            }\r\n        }\r\n\r\n        const res = parseFloat(value);\r\n        return !isNaN(res) ? res : null;\r\n    }\r\n\r\n    private isPartOfNumber(symbol: string, currentTokens: Token[]): boolean {\r\n        if (symbol === '-' && !this.tokenText.length) {\r\n            // '-' needs to be handled e.g. -3; 2 + -2 etc\r\n            const prevToken = (currentTokens.length !== 0) ? currentTokens[currentTokens.length - 1] : null;\r\n            return prevToken === null || (getTokenType(prevToken) === TokenTypes.Operator && getTokenValue(prevToken) !== ')');\r\n        } else if (symbol === '.' && this.parseNumberOrNull(this.tokenText) !== null) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}","import { AstBlock, ImportNode, Token } from './common';\r\nimport { getImportType } from './common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { EvaluatorAsync } from './evaluator/evaluatorAsync';\r\nimport { BlockContext, Scope } from './evaluator/scope';\r\nimport { INITIAL_SCOPE, PackageToImport } from './initialScope';\r\nimport { Parser } from './parser';\r\nimport { Tokenizer } from './tokenizer';\r\n\r\nexport type PackageLoader = (packageName: string) => any;\r\nexport type ModuleLoader = (filePath: string) => Promise<string>;\r\n\r\nexport function jsPython(): Interpreter {\r\n    return Interpreter.create();\r\n}\r\n\r\nexport class Interpreter {\r\n    private readonly initialScope: Record<string, unknown> = { ...INITIAL_SCOPE };\r\n\r\n    private _lastExecutionContext: Record<string, unknown> | null = null;\r\n\r\n    private packageLoader?: PackageLoader;\r\n    private moduleLoader?: ModuleLoader;\r\n\r\n    constructor() { }\r\n\r\n    static create(): Interpreter {\r\n        return new Interpreter();\r\n    }\r\n\r\n    get initialExecutionContext(): Record<string, unknown> {\r\n        return this.initialScope;\r\n    }\r\n\r\n    get lastExecutionContext(): Record<string, unknown> | null {\r\n        return this._lastExecutionContext;\r\n    }\r\n\r\n    cleanUp(): void {\r\n        this._lastExecutionContext = null;\r\n    }\r\n\r\n    jsPythonInfo(): string {\r\n        return INITIAL_SCOPE.jsPython();\r\n    }\r\n\r\n    tokenize(script: string): Token[] {\r\n        const tokenizer = new Tokenizer();\r\n        return tokenizer.tokenize(script);\r\n    }\r\n\r\n    parse(script: string, moduleName: string = 'main.jspy'): AstBlock {\r\n        const tokenizer = new Tokenizer();\r\n        const parser = new Parser();\r\n        const jspyAst = parser.parse(tokenizer.tokenize(script), moduleName);\r\n        return jspyAst;\r\n    }\r\n\r\n    eval(codeOrAst: string | AstBlock, scope: Record<string, unknown> = {}\r\n        , entryFunctionName: string = '', moduleName: string = 'main.jspy'): unknown {\r\n        const ast = (typeof codeOrAst === 'string') ? this.parse(codeOrAst as string, moduleName) : codeOrAst as AstBlock;\r\n\r\n        const blockContext = {\r\n            moduleName: moduleName,\r\n            blockScope: new Scope(scope)\r\n        } as BlockContext;\r\n\r\n        blockContext.blockScope.set('printExecutionContext', () => console.log(blockContext.blockScope.getScope()));\r\n        blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n        this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n        const result = new Evaluator().evalBlock(ast, blockContext);\r\n        if (!entryFunctionName || !entryFunctionName.length) {\r\n            return result;\r\n        } else {\r\n            const func = blockContext.blockScope.get(entryFunctionName);\r\n            if (typeof func !== 'function') {\r\n                throw Error(`Function ${entryFunctionName} does not exists or not a function`)\r\n            }\r\n            return func();\r\n        }\r\n    }\r\n\r\n    async evalAsync(codeOrAst: string | AstBlock, scope: Record<string, unknown> = {}\r\n        , entryFunctionName: string = '', moduleName: string = 'main.jspy'): Promise<unknown> {\r\n        const ast = (typeof codeOrAst === 'string') ? this.parse(codeOrAst as string, moduleName) : codeOrAst as AstBlock;\r\n        const evaluator = new EvaluatorAsync();\r\n        const blockContext = {\r\n            moduleName: moduleName,\r\n            blockScope: new Scope(scope)\r\n        } as BlockContext;\r\n\r\n        blockContext.blockScope.set('printExecutionContext', () => console.log(blockContext.blockScope.getScope()));\r\n        blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n        this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n        const result = await evaluator\r\n            .registerJsonFileLoader(async (modulePath: string) =>\r\n                await (this.moduleLoader ? this.moduleLoader(modulePath)\r\n                    : Promise.reject('ModuleLoader is not registered')\r\n                )\r\n            )\r\n            .registerModuleParser(async (modulePath) => await this.moduleParser(modulePath))\r\n            .registerBlockContextFactory((moduleName, ast: AstBlock) => {\r\n                // enrich context\r\n                const newContext = this.assignImportContext(ast, scope);\r\n                const moduleContext = { moduleName, blockScope: new Scope(newContext) }\r\n                moduleContext.blockScope.set('printExecutionContext', () => console.log(moduleContext.blockScope.getScope()));\r\n                moduleContext.blockScope.set('getExecutionContext', () => moduleContext.blockScope.getScope());\r\n                return moduleContext;\r\n            })\r\n            .evalBlockAsync(ast, blockContext);\r\n\r\n        if (!entryFunctionName || !entryFunctionName.length) {\r\n            return result;\r\n        } else {\r\n            const func = blockContext.blockScope.get(entryFunctionName);\r\n            if (typeof func !== 'function') {\r\n                throw Error(`Function ${entryFunctionName} does not exists or not a function`)\r\n            }\r\n            return await func();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compatibility method (with v1). !\r\n     */\r\n    async evaluate(script: string, context: object = {}, entryFunctionName: string = ''\r\n        , moduleName: string = 'main.jspy'): Promise<any> {\r\n        if (!script || !script.length) { return null; }\r\n        const ast = this.parse(script, moduleName);\r\n\r\n        context = (context && typeof context === 'object') ? context : {};\r\n        context = this.assignImportContext(ast, context);\r\n\r\n        const globalScope = {\r\n            ...this.initialScope,\r\n            ...context\r\n        } as Record<string, unknown>;\r\n\r\n        return await this.evalAsync(ast, globalScope, entryFunctionName, moduleName);\r\n    }\r\n\r\n    registerPackagesLoader(loader: PackageLoader): Interpreter {\r\n        if (typeof loader === 'function') {\r\n            this.packageLoader = loader;\r\n        } else {\r\n            throw Error('PackagesLoader');\r\n        }\r\n        return this;\r\n    }\r\n\r\n    registerModuleLoader(loader: ModuleLoader): Interpreter {\r\n        if (typeof loader === 'function') {\r\n            this.moduleLoader = loader;\r\n        } else {\r\n            throw Error('ModuleLoader should be a function');\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    addFunction(funcName: string, fn: (...args: any[]) => void | any | Promise<any>): Interpreter {\r\n        this.initialScope[funcName] = fn;\r\n        return this;\r\n    }\r\n\r\n    assignGlobalContext(obj: object): Interpreter {\r\n        Object.assign(this.initialScope, obj);\r\n        return this;\r\n    }\r\n\r\n    hasFunction(scripts: string = '', funcName: string): boolean {\r\n        return scripts.indexOf(`def ${funcName}`) > -1;\r\n    }\r\n\r\n    private assignImportContext(ast: AstBlock, context: object): Record<string, unknown> {\r\n\r\n        const nodeToPackage = (im: ImportNode): PackageToImport => {\r\n            return {\r\n                name: im.module.name,\r\n                as: im.module.alias,\r\n                properties: im.parts?.map(p => ({ name: p.name, as: p.alias }))\r\n            } as PackageToImport\r\n        }\r\n\r\n        const importNodes = ast.body.filter(n => n.type === 'import') as ImportNode[];\r\n\r\n        const jsImport = importNodes\r\n            .filter(im => getImportType(im.module.name) === 'jsPackage')\r\n            .map(im => nodeToPackage(im));\r\n\r\n        if (jsImport.length && this.packageLoader) {\r\n            const libraries = this.packageResolver(jsImport);\r\n            context = { ...context, ...libraries };\r\n        }\r\n\r\n        return context as Record<string, unknown>;\r\n    }\r\n\r\n    private async moduleParser(modulePath: string): Promise<AstBlock> {\r\n        if (!this.moduleLoader) {\r\n            throw new Error('Module Loader is not registered')\r\n        }\r\n\r\n        const content = await this.moduleLoader(modulePath);\r\n        return this.parse(content, modulePath);\r\n    }\r\n\r\n    private packageResolver(packages: PackageToImport[]): object {\r\n        if (!this.packageLoader) {\r\n            throw Error('Package loader not provided.');\r\n        }\r\n        const libraries: any = {};\r\n        packages.forEach(({ name, as, properties }: PackageToImport) => {\r\n            const lib = this.packageLoader && this.packageLoader(name);\r\n            if (properties?.length) {\r\n                properties.forEach((prop) => {\r\n                    libraries[prop.as || prop.name] = lib[prop.name];\r\n                })\r\n            } else if (as) {\r\n                libraries[as] = lib;\r\n            } else {\r\n                libraries[name] = lib;\r\n            }\r\n            if (as) {\r\n                libraries[as] = lib;\r\n            }\r\n        });\r\n        return libraries;\r\n    }\r\n\r\n}\r\n"],"names":["getImportType","name","startsWith","endsWith","jspyErrorMessage","error","module","line","column","message","_super","_this","Object","setPrototypeOf","JspyTokenizerError","prototype","__extends","Error","OperationTypes","JspyParserError","JspyEvalError","JspyError","TokenTypes","OperatorsMap","Arithmetic","Comparison","and","Logical","or","in","Membership","Assignment","OperationFuncs","l","r","arithmeticOperation","comparissonOperation","logicalOperation","op","includes","String","Array","isArray","membershipOperation","Math","pow","getTokenType","token","getTokenValue","getTokenLoc","subarray","getStartLine","getStartColumn","splitTokens","tokens","separator","result","length","sepIndexes","findTokenValueIndexes","value","start","i","ind","push","slice","findTokenValueIndex","predicate","LiteralString","skipInnerBrackets","opIndexes","tValue","findOperators","operationType","undefined","openChar","closeChar","innerBrackets","tokenValue","type","this","target","source","loc","AstNode","comment","returnValue","errorName","errorMessage","paramNodes","funcAst","params","isAsync","conditionNode","ifBody","elseBody","tryBody","exepts","finallyBody","sourceArray","itemVarName","body","condition","parts","nullCoelsing","nestedProps","props","items","propertyName","bracketBody","nullCoalescing","left","right","cloneContext","context","moduleName","blockScope","clone","initialScope","scope","Scope","key","path","Evaluator","ast","blockContext","lastResult","node","funcDef","set","_i","args","jspyFuncInvoker","_a","funcs","_c","_b","evalNode","returnCalled","res","returnObject","continueCalled","breakCalled","err","assign","argValue","evalBlock","func","fps","raiseNode","returnNode","name_2","get","charAt","binOpNode","logicalGroups","gResult","eg","arrowFuncDef_1","funcCallNode","pms","map","n","invokeFunction","assignNode","node_1","targetNode","targetObjectNode","DotObjectAccessNode","keyValue","sbNode","obj","dotObject","startObject","nestedProp","node_2","bind","_h","p","_k","_j","item","whileNode","forNode","array","tryNode","name_1","firstExept","catchBody","ctx","alias","ifNode","Promise","reject","EvaluatorAsync","moduleParser","jsonFileLoader","blockContextFactory","newScope","invoker","jspyFuncInvokerAsync","_e","_d","iType","importNode","_g","_f","JSON","parse","jsonValue","defaultModuleName","moduleAst","moduleBlockContext","evalBlockAsync","getScope","assignFunctionsToScope","evalNodeAsync","err_1","filter","f","indexOf","substring","lastIndexOf","_6","err_2","invokeFunctionAsync","_m","_l","targetObject","lastPropertyName","_p","_q","_r","_s","_t","_v","_u","_x","_w","_z","_y","_0","_1","_3","_2","_5","_4","INITIAL_SCOPE","jsPython","join","dateTime","str","Date","isNaN","valueOf","strValue","parseMonth","mm","NaN","m","parseInt","correctYear","yy","validDateOrNull","yyyy","month","day","hours","mins","ss","dd","strTokens","replace","toLowerCase","split","dt","parseFloat","d","parseDatetimeOrNull","range","stop","step","arr","isStopNaN","print","console","log","isNull","v","defValue","isDate","isFunction","isString","deleteProperty","propName","printExecutionContext","getExecutionContext","InstructionLine","Parser","_moduleName","instructions","tokensToInstructionLines","instructionsToNodes","_currentToken","getBody","startTokenIndex","instructionLines","bodyAst","findIndexes","tkns","operation","splice","forEach","instruction","tt","Comment","firstToken","secondToken","logicOpIndexes","CommentNode","funcName","findIndex","t","endDefOfDef","FunctionDefNode","conditionTokens","groupLogicalOperations","createExpressionNode","IfNode","excepts","endIndex","except","TryExceptNode","ContinueNode","BreakNode","ReturnNode","RaiseNode","forBody","ForNode","WhileNode","asIndex","module_1","ImportNode","importIndex","module_2","assignTokens","AssignNode","a","begin","end","indexes","leftNode","opToken","sliceWithBrackets","endInd","rightNode","BinOpNode","logicOp","logicItems","logicalSlice","LogicalOpNode","startLine","lines","sLine","sColumn","prevNode","lastToken","tokenType","LiteralNumber","LiteralBool","LiteralNull","isTokenTypeLiteral","ConstNode","Identifier","GetSingleVarNode","stringify","arrowFuncParts","ArrowFuncDefNode","comparissonIndexes","groupComparisonOperations","ops","prevNode_1","opIndex","nextOpIndex","nextOp","leftSlice","rightSlice","nextOpIndex2","leftSlice2","rightSlice2","left2","right2","subObjects","isNullCoelsing","pop","paramsNodes","paramsTokensSlice","FunctionCallNode","keyValueTokens","pInfo","namePart","CreateObjectNode","CreateArrayNode","name_3","BracketObjectAccessNode","SeparatorsMap","Keywords","Tokenizer","_tokenText","_startLine","_currentLine","_startColumn","_currentColumn","script","RegExp","_script","_cursor","first","incrementCursor","symbol","tokenText","isPartOfNumber","first_1","processToken","q","cLine","cColumn","sepsMap","Operator","count","parseNumberOrNull","Keyword","strToken","allowEmptyString","recognizeToken","Uint16Array","of","trim","charCodeAt","currentTokens","prevToken","Interpreter","_lastExecutionContext","tokenize","tokenizer","codeOrAst","entryFunctionName","evaluator","registerJsonFileLoader","modulePath","moduleLoader","registerModuleParser","registerBlockContextFactory","newContext","assignImportContext","moduleContext","globalScope","__assign","evalAsync","loader","packageLoader","fn","scripts","jsImport","im","as","properties","nodeToPackage","libraries","packageResolver","content","packages","lib","prop","create"],"mappings":"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"}